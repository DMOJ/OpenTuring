#include "cinterface"
static struct {
    TLint4	dummy;
    char	dummy2[1241];
} TLFTAB =
    { 21,
    {'/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'c', 'o', 'm', 'p', 'e', 'r', 'r', '.', 'b', 'd', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'c', 'o', 'm', 'p', 'e', 'r', 'r', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', '.', '.', '/', 'f', 'i', 'l', 'e', 'm', 'a', 'n', '/', 'f', 'i', 'l', 'e', 'm', 'a', 'n', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'd', 'u', 'm', 'm', 'y', '.', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'e', 'n', 'v', 'i', 'r', 'o', 'n', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'm', 's', 'g', 's', '.', 'd', 'e', 'f', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'd', 'e', 'b', 'u', 'g', '.', 'd', 'e', 'f', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '.', 'b', 'd', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'u', 'n', 'i', 't', 'm', 'a', 'n', '/', 'u', 'n', 'i', 't', 'm', 'a', 'n', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'e', 'r', 'r', 'o', 'r', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'p', 's', 'e', 'u', 'd', 'o', '.', 'd', 'e', 'f', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'o', 'p', 'c', 'o', 'd', 'e', '.', 'i', 'n', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'd', 'e', 'b', 'u', 'g', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', '.', 'b', 'd', '\0',
    '/', 'l', 'o', 'c', 'a', 'l', '/', 'i', 'n', 'c', 'l', 'u', 'd', 'e', '/', 't', 'p', 'l', 'u', 's', '/', 'D', 'O', 'S', '3', '2', '/', 'm', 'e', 'm', 'o', 'r', 'y', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'g', 'l', 'o', 'b', 'a', 'l', '.', 'i', 'n', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'c', 'o', 'm', 'p', 'e', 'r', 'r', '.', 'd', 'e', 'f', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'c', 'o', 'm', 'p', 'e', 'r', 'r', '.', 'd', 'f', '2', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'c', 'o', 'm', 'p', 'e', 'r', 'r', '.', 'm', 's', 'g', 's', '\0'
    }};
typedef	TLnat2	FileManager_FileNoType;
typedef	TLnat4	FileManager_FileTimeStamp;
typedef	TLint2	FileManager_ResultCode;

extern void FileManager_OpenNamedHandle ();

extern void FileManager_OpenUnnamedHandle ();

extern void FileManager_OpenFileHandle ();

extern void FileManager_SetModified ();

extern void FileManager_WriteFile ();

extern void FileManager_WriteBackup ();

extern void FileManager_WriteTemp ();

extern void FileManager_RmTemp ();

extern void FileManager_CloseFileHandle ();

extern void FileManager_OpenNamedText ();

extern void FileManager_OpenFileText ();

extern void FileManager_CloseFileText ();

extern void FileManager_CloseAllText ();

extern void FileManager_ChangeDirectory ();

extern void FileManager_GetDirectory ();

extern void FileManager_ChangeExecDirectory ();

extern void FileManager_GetExecDirectory ();

extern void FileManager_ShortName ();

extern void FileManager_RelativeName ();

extern void FileManager_PathName ();

extern void FileManager_ExecPathName ();

extern void FileManager_ExtendName ();

extern void FileManager_FileName ();

extern TLboolean FileManager_IsUnnamed ();

extern TLboolean FileManager_IsOnDisk ();

extern TLboolean FileManager_IsSameFile ();

extern TLboolean FileManager_IsReadOK ();

extern TLboolean FileManager_IsWriteOK ();

extern TLboolean FileManager_IsOlder ();

extern TLboolean FileManager_FileExists ();

extern void FileManager_AddReference ();

extern void FileManager_DeleteReference ();

extern void FileManager_ReadTimeStamp ();

extern void FileManager_FlushUnreferencedFiles ();

extern void FileManager_CheckReferencedFiles ();

extern void FileManager_RmFile ();

extern void FileManager_SetDefaultInclude ();

extern void FileManager_AssertTextClosed ();

extern void FileManager_Dump ();

extern TLboolean AbortCheck ();

extern void FeedBack ();
struct	SrcPosition {
    TLnat2	lineNo;
    FileManager_FileNoType	fileNo;
    TLnat2	linePos;
    TLnat2	tokLen;
};
typedef	TLchar	__x1974[256];
struct	ErrMsgDef {
    struct ErrMsgDef	*next;
    struct SrcPosition	srcPos;
    __x1974	text;
};
typedef	TLint4	CookieKind;
struct	Cookie {
    CookieKind	kind;
    TLaddressint	item;
    TLaddressint	fp;
    TLaddressint	data;
};
struct	CallDef {
    struct CallDef	*next;
    TLstring	routineName;
    struct SrcPosition	srcPos;
    struct Cookie	cookie;
};
struct	ThreadDef {
    struct ThreadDef	*next;
    TLaddressint	threadId;
    TLaddressint	threadName;
    struct CallDef	*traceback;
};
struct	ThreadQueueDef {
    struct ThreadQueueDef	*next;
    TLaddressint	queueId;
    TLstring	queueName;
    struct ThreadDef	*threadList;
};
struct	DumpIndexDef {
    struct DumpIndexDef	*next;
    TLint4	lowerBound;
    TLint4	upperBound;
};
struct	DumpSymbolDef {
    struct DumpSymbolDef	*next;
    TLaddressint	symbolName;
    TLaddressint	typeName;
    struct SrcPosition	srcPos;
    TLstring	value;
    struct Cookie	cookie;
    TLboolean	isPredef;
};
struct	DumpScopeDef {
    struct DumpSymbolDef	symbolInfo;
    struct Cookie	expandCookie;
    struct DumpSymbolDef	*parameters;
    struct DumpSymbolDef	*declarations;
};

extern void Language_Debugging ();

extern void Language_Paragraph ();

extern void Language_Reset ();

extern void Language_SetMaxErrorCount ();
typedef	TLstring	__x1975[20];

extern void Language_EnterPreprocSymbols ();

extern void Language_CompileUnit ();

extern void Language_CompileProgram ();

extern void Language_WriteObjectFile ();
typedef	TLstring	__x1978[21];
typedef	TLstring	__x1982[21];

extern void Language_SetupExecution ();
typedef	TLint1	Language_Step;

extern void Language_SetStep ();
typedef	TLint1	Language_ReturnState;
struct	Language_RunStatus {
    Language_ReturnState	state;
    struct SrcPosition	srcPos;
    TLaddressint	threadId;
};

extern void Language_ExecuteProgram ();

extern void Language_EndExecution ();

extern void Language_StopExecution ();

extern void Language_DumpThreadList ();

extern void Language_DumpUnitList ();

extern void Language_DumpScopeInfo ();

extern void Language_DumpSymbolInfo ();

extern void Language_DumpArrayBounds ();

extern void Language_DumpArrayValues ();
extern TLboolean	Language_debug;
extern struct SrcPosition	Language_nullSrcPosition;
extern struct Cookie	Language_nullCookie;
extern struct DumpSymbolDef	Language_nullSymbolDef;
extern struct DumpScopeDef	Language_nullScopeDef;
typedef	TLint1	Language_UnitManager_UnitKind;
typedef	TLint1	Language_UnitManager_UnitStatus;

extern void Language_UnitManager_AddDepend ();

extern void Language_UnitManager_AddIncludeFile ();

extern void Language_UnitManager_AllocateCompileChunk ();

extern void * Language_UnitManager_BodyUnit ();

extern void Language_UnitManager_ClearAllMarks ();

extern void Language_UnitManager_ClearConfiguration ();

extern TLaddressint Language_UnitManager_CodeTable ();

extern FileManager_FileNoType Language_UnitManager_FileNo ();

extern void Language_UnitManager_FlushOldUnits ();

extern void Language_UnitManager_GetNextDepend ();

extern void Language_UnitManager_GetNextUnit ();

extern void Language_UnitManager_GetUnitPtr ();

extern TLaddressint Language_UnitManager_GlobalArea ();

extern TLint4 Language_UnitManager_GlobalSize ();

extern TLboolean Language_UnitManager_IsCompiled ();

extern TLboolean Language_UnitManager_IsMarked ();

extern TLboolean Language_UnitManager_IsPredef ();

extern Language_UnitManager_UnitKind Language_UnitManager_Kind ();

extern TLaddressint Language_UnitManager_ManifestTable ();

extern void * Language_UnitManager_OverrideBody ();

extern void Language_UnitManager_PrepareForCompile ();

extern void Language_UnitManager_PrepareForDepends ();

extern void Language_UnitManager_PrepareForScan ();

extern void Language_UnitManager_Reset ();

extern void Language_UnitManager_RewindDependList ();

extern void Language_UnitManager_RewindUnitList ();

extern void Language_UnitManager_SetCodeTable ();

extern void Language_UnitManager_SetDefaultBody ();

extern void Language_UnitManager_SetGlobalArea ();

extern void Language_UnitManager_SetKind ();

extern void Language_UnitManager_SetManifestTable ();

extern void Language_UnitManager_SetMark ();

extern void Language_UnitManager_SetOverrideBody ();

extern void Language_UnitManager_SetPredef ();

extern void Language_UnitManager_SetStub ();

extern void Language_UnitManager_SetSymbolTable ();

extern void Language_UnitManager_StartNewProgram ();

extern void * Language_UnitManager_StubUnit ();

extern void Language_UnitManager_SuccessfulCompile ();

extern TLaddressint Language_UnitManager_SymbolTable ();
typedef	TLint1	Language_ErrorModule_Severity;

extern void Language_ErrorModule_Initialize ();

extern void Language_ErrorModule_SetMaxErrors ();

extern void Language_ErrorModule_Message ();

extern void Language_ErrorModule_AbortIfErrors ();

extern void Language_ErrorModule_ReturnErrors ();
typedef	Language_ErrorModule_Severity	Language_ErrorSeverity;
typedef	TLstring	Language_StringDef;
typedef	TLnat4	Language_Offset;
extern TLint4	Language_codeOprSize;
extern TLint4	Language_codeInt1Size;
extern TLint4	Language_codeInt2Size;
extern TLint4	Language_codeIntSize;
extern TLint4	Language_codeRealSize;
extern TLint4	Language_codeAddrSize;
extern TLint4	Language_codeOffsetSize;
typedef	TLchar	Language_string1[2];
typedef	TLnat1	Language_set8;
typedef	TLnat2	Language_set16;
typedef	TLnat4	Language_set32;
typedef	TLint2	Language_Opcode;
typedef	TLchar	Language___x1986[22];
typedef	Language___x1986	Language___x1985[255];
extern Language___x1985	Language_OpcodeName;
struct	Language_CodeHeader {
    TLaddressint	bodyCode;
};
struct	Language___x1988 {
    TLint4	lower, range;
};
typedef	struct Language___x1988	Language___x1987[255];
struct	Language_ArrayDescriptor {
    TLnat4	sizeArray;
    TLnat4	sizeElement;
    TLnat4	elementCount;
    TLnat4	numDimensions;
    Language___x1987	dim;
};
struct	Language_ForDescriptor {
    TLint4	counter;
    TLint4	right;
    TLint4	step;
    TLaddressint	savedSP;
};
typedef	Language_Offset	Language___x1989[1001];
struct	Language_CaseDescriptor {
    TLint4	lower, upper;
    Language_Offset	otherwise;
    Language___x1989	caseVector;
};
struct	Language_PointerDescriptor {
    TLaddressint	dataPtr;
    TLint4	timestamp;
};
typedef	TLnat2	Language___x1990[301];
struct	Language_UnionMapDescriptor {
    TLint4	lower, upper;
    Language___x1990	map;
};
typedef	TLnat4	Language_ClassAttr;
struct	Language_ClassDescriptor {
    TLaddressint	baseClass;
    TLaddressint	expandClass;
    Language_ClassAttr	attributes;
    TLnat4	objSize;
    TLaddressint	classId;
    TLaddressint	initRoutine;
    TLnat4	numOperations;
};
typedef	TLint1	Language_OpenKind;
typedef	TLint1	Language_PutKind;
typedef	TLint1	Language_GetKind;
typedef	TLint1	Language_SetStreamKind;
typedef	TLnat1	Language_StreamModeSet;
typedef	TLint1	Language_SubstringKind;
typedef	TLint1	Language_RangeCheckKind;
typedef	TLint1	Language_ConditionKind;

extern void Language_DebugModule_Initialize ();

extern void Language_DebugModule_NewQueue ();

extern void Language_DebugModule_NewThread ();

extern void Language_DebugModule_NewCall ();

extern void Language_DebugModule_ReturnThreadDump ();

extern void Language_DebugModule_NewSymbolList ();

extern void Language_DebugModule_NewSymbol ();

extern void Language_DebugModule_ReturnSymbolDump ();

extern void Language_DebugModule_NewIndexList ();

extern void Language_DebugModule_NewIndex ();

extern void Language_DebugModule_ReturnIndexDump ();

extern void Language_Compile_Reset ();

extern void Language_Compile_Initialize ();
typedef	TLstring	__x1993[20];

extern void Language_Compile_EnterPreprocSymbols ();

extern void Language_Compile_ScanUnit ();

extern void Language_Compile_CompileUnit ();

extern void Language_Compile_InstallUnit ();

extern void Language_Compile_CallInfo ();

extern void Language_Compile_DumpUnitList ();

extern void Language_Compile_DumpScopeInfo ();

extern void Language_Compile_DumpSymbolInfo ();

extern void Language_Compile_DumpArrayBounds ();

extern void Language_Compile_DumpArrayValues ();

extern void Language_Compile_SetObjectFileStream ();

/*





*/
typedef	TLnat1	Language_Compile_Tok;
typedef	TLchar	Language_Compile___x1998[16];
struct	Language_Compile___x1997 {
    Language_Compile___x1998	Name;
    TLnat2	Precedence;
};
typedef	struct Language_Compile___x1997	Language_Compile___x1996[159];
extern Language_Compile___x1996	Language_Compile_TokData;
typedef	TLint1	Language_Compile_PPTok;
typedef	TLchar	Language_Compile___x2000[8];
typedef	Language_Compile___x2000	Language_Compile___x1999[16];
extern Language_Compile___x1999	Language_Compile_PPTokName;
typedef	TLint1	Language_Compile_TypeKind;
typedef	TLchar	Language_Compile___x2002[16];
typedef	Language_Compile___x2002	Language_Compile___x2001[33];
extern Language_Compile___x2001	Language_Compile_TypeKindName;
typedef	TLchar	Language_Compile___x2004[16];
typedef	Language_Compile___x2004	Language_Compile___x2003[33];
extern Language_Compile___x2003	Language_Compile_TypeKindKeyword;
typedef	TLint1	Language_Compile_TyModes;
typedef	TLchar	Language_Compile___x2006[12];
typedef	Language_Compile___x2006	Language_Compile___x2005[10];
extern Language_Compile___x2005	Language_Compile_TyModeName;
typedef	TLnat2	Language_Compile_TyModesSet;
typedef	TLint2	Language_Compile_PredType;
typedef	Language_Compile_TypeKind	Language_Compile___x2007[27];
extern Language_Compile___x2007	Language_Compile_PredTypeKind;
typedef	Language_Compile_TyModesSet	Language_Compile___x2008[27];
extern Language_Compile___x2008	Language_Compile_PredTypeMode;
typedef	TLint2	Language_Compile_FormalType;
typedef	TLint2	Language_Compile_Predef;
typedef	TLchar	Language_Compile___x2011[20];
struct	Language_Compile___x2010 {
    Language_Compile___x2011	Name;
    Language_Compile_FormalType	FormalList;
    Language_Compile_PredType	ResultType;
};
typedef	struct Language_Compile___x2010	Language_Compile___x2009[25];
extern Language_Compile___x2009	Language_Compile_PredefData;
typedef	TLchar	Language_Compile___x2012[256];
struct	Language_Compile_CharDef {
    TLint4	len;
    Language_Compile___x2012	val;
};
struct	Language_Compile_IdentDef {
    struct Language_Compile_IdentDef	*nextIdent;
    Language_Compile_Tok	tok;
    Language_Compile_PPTok	ppTok;
    Language_StringDef	str;
};
typedef	TLint1	Language_Compile_SymbolKind;
typedef	TLchar	Language_Compile___x2014[14];
typedef	Language_Compile___x2014	Language_Compile___x2013[10];
extern Language_Compile___x2013	Language_Compile_SymbolKindName;
typedef	TLint1	Language_Compile_Access;
typedef	TLchar	Language_Compile___x2016[6];
typedef	Language_Compile___x2016	Language_Compile___x2015[3];
extern Language_Compile___x2015	Language_Compile_AccessName;
typedef	TLint1	Language_Compile_SyAttributes;
typedef	TLchar	Language_Compile___x2018[16];
typedef	Language_Compile___x2018	Language_Compile___x2017[20];
extern Language_Compile___x2017	Language_Compile_SyAttribName;
typedef	TLnat4	Language_Compile_SyAttributeSet;
typedef	TLnat1	Language_Compile_ImportDepthType;
struct	Language_Compile_IndexDef {
    struct Language_Compile_IndexDef	*next;
    struct Language_Compile_TypeDef	*ty;
};
typedef	TLint1	Language_Compile_ExportKind;
typedef	TLchar	Language_Compile___x2020[16];
typedef	Language_Compile___x2020	Language_Compile___x2019[4];
extern Language_Compile___x2019	Language_Compile_ExportKindName;
typedef	TLnat1	Language_Compile_ExportKindSet;
struct	Language_Compile_ExportDef {
    struct Language_Compile_ExportDef	*next;
    struct Language_Compile_IdentDef	*identPtr;
    struct Language_Compile_SymbolDef	*symbolPtr;
    struct Language_Compile_TypeDef	*opaqueTypePtr;
    Language_Compile_ExportKindSet	kind;
};
struct	Language_Compile_ImportDef {
    struct Language_Compile_ImportDef	*next;
    struct Language_Compile_SymbolDef	*sy;
    Language_Compile_Access	newAccess;
    Language_Compile_Access	oldAccess;
    Language_Compile_ImportDepthType	oldImportDepth;
    TLboolean	overridesExpand;
};
struct	Language_Compile_DynamicDef {
    struct Language_Compile_DynamicDef	*next;
    struct Language_Compile_SymbolDef	*sy;
};
typedef	TLint1	Language_Compile_BlockKind;
typedef	TLchar	Language_Compile___x2022[10];
typedef	Language_Compile___x2022	Language_Compile___x2021[16];
extern Language_Compile___x2021	Language_Compile_BlockKindName;
struct	Language_Compile_BlockDef {
    struct Language_Compile_BlockDef	*parentBlock;
    struct Language_Compile_BlockDef	*siblingBlock;
    struct Language_Compile_BlockDef	*childBlock;
    struct Language_Compile_BlockDef	*expandBlock;
    struct Language_Compile_SymbolDef	*internalSymbols;
    struct Language_Compile_SymbolDef	*parentSymbols;
    struct Language_Compile_SymbolDef	*definingSymbol;
    Language_Offset	codeStartOffset;
    Language_Offset	codeEndOffset;
    struct Language_Compile_DynamicDef	*dynamics;
    Language_Compile_BlockKind	kind;
    TLboolean	reachable;
    TLboolean	resolvingNeeded;
};
typedef	TLint1	Language_Compile_Base;
typedef	TLchar	Language_Compile___x2024[12];
typedef	Language_Compile___x2024	Language_Compile___x2023[10];
extern Language_Compile___x2023	Language_Compile_BaseName;
typedef	TLint1	Language_Compile_Indirection;
typedef	TLchar	Language_Compile___x2026[10];
typedef	Language_Compile___x2026	Language_Compile___x2025[3];
extern Language_Compile___x2025	Language_Compile_IndirName;
struct	Language_Compile_Location {
    void	*unitPtr;
    Language_Compile_Base	base;
    Language_Compile_Indirection	indir;
    Language_Offset	offset;
};
extern struct Language_Compile_Location	Language_Compile_nullLocation;
struct	Language_Compile_DeferredLocDef {
    struct Language_Compile_DeferredLocDef	*next;
    struct Language_Compile_SymbolDef	*sy;
    struct Language_Compile_Location	loc;
};
struct	Language_Compile___x2027 {
    Language_Compile_SymbolKind	syTag;
    union {
	struct {
	    struct Language_Compile_SymbolDef	*mExpandSy;
	    struct Language_Compile_ImportDef	*mImportsOf;
	    struct Language_Compile_ExportDef	*mExportsOf;
	    Language_Compile_ExportKindSet	mExportAllKind;
	    struct Language_Compile_SymbolDef	*mMonitorVar;
	    struct Language_Compile_SymbolDef	*mClassTagSy;
	    TLint4	mDeferredNum;
	    struct Language_Compile_DeferredLocDef	*mDeferredLocs;
	} __u2;
	struct {
	    struct Language_Compile_ValueDef	*cValue;
	} __u3;
	struct {
	    struct Language_Compile_SymbolDef	*fFormalsOf;
	    struct Language_Compile_ImportDef	*fImportsOf;
	    struct Language_Compile_SymbolDef	*ResultsId;
	    struct Language_Compile_TypeDef	*ResultType;
	} __u4;
	struct {
	    struct Language_Compile_SymbolDef	*pFormalsOf;
	    struct Language_Compile_ImportDef	*pImportsOf;
	    struct Language_Compile_ValueDef	*pValue;
	} __u5;
	struct {
	    TLint4	unionNumber;
	} __u6;
    } __u1;
} ;
struct	Language_Compile_SymbolDef {
    struct Language_Compile_SymbolDef	*next;
    struct Language_Compile_IdentDef	*identPtr;
    struct Language_Compile_TypeDef	*tyPtr;
    Language_Compile_Access	access;
    Language_Compile_ImportDepthType	importDepth;
    Language_Compile_Predef	predefined;
    Language_Compile_SyAttributeSet	attributes;
    struct Language_Compile_SymbolDef	*definingSy;
    struct Language_Compile_BlockDef	*blockScope;
    struct Language_Compile_Location	loc;
    struct SrcPosition	srcPos;
    Language_Offset	definingOffset;
    struct Language_Compile___x2027	u;
};
struct	Language_Compile_IntListDef {
    struct Language_Compile_IntListDef	*next;
    TLint4	value;
};
struct	Language_Compile_UnionDef {
    struct Language_Compile_UnionDef	*next;
    struct Language_Compile_SymbolDef	*firstSym;
    TLint4	numSyms;
    struct Language_Compile_IntListDef	*values;
    TLint4	uloc;
};
struct	Language_Compile___x2028 {
    Language_Compile_TypeKind	tyTag;
    union {
	struct {
	    struct Language_Compile_IndexDef	*IndexOf;
	    struct Language_Compile_TypeDef	*aElementOf;
	    struct Language_Compile_Location	aDescriptor;
	} __u8;
	struct {
	    struct Language_Compile_SymbolDef	*cNameOf;
	    struct Language_Compile_TypeDef	*cPointerTy;
	    struct Language_Compile_TypeDef	*cUPointerTy;
	} __u9;
	struct {
	    struct Language_Compile_SymbolDef	*EnumIds;
	    struct Language_Compile_Location	eDescriptor;
	} __u10;
	struct {
	    struct Language_Compile_BlockDef	*blockLevel;
	} __u11;
	struct {
	    struct Language_Compile_SymbolDef	*sNameOf;
	} __u12;
	struct {
	    struct Language_Compile_SymbolDef	*oNameOf;
	    struct Language_Compile_TypeDef	*tyOf;
	} __u13;
	struct {
	    struct Language_Compile_SymbolDef	*pNameOf;
	    struct Language_Compile_TypeDef	*pElementOf;
	} __u14;
	struct {
	    struct Language_Compile_SymbolDef	*rFieldsOf;
	} __u15;
	struct {
	    struct Language_Compile_TypeDef	*BaseOf;
	    TLboolean	sIsScalar;
	} __u16;
	struct {
	    TLint4	stringSize;
	} __u17;
	struct {
	    struct Language_Compile_Location	sDescriptor;
	} __u18;
	struct {
	    TLint4	low;
	    TLint4	high;
	    struct Language_Compile_TypeDef	*Root;
	} __u19;
	struct {
	    struct Language_Compile_SymbolDef	*TagOf;
	    struct Language_Compile_SymbolDef	*uFieldsOf;
	    struct Language_Compile_UnionDef	*map;
	    struct Language_Compile_Location	mapLocation;
	    struct Language_Compile_Location	uninitMap;
	} __u20;
	struct {
	    struct Language_Compile_TypeDef	*tyPtr;
	} __u21;
    } __u7;
} ;
struct	Language_Compile_TypeDef {
    struct Language_Compile_SymbolDef	*typeName;
    Language_Compile_TyModesSet	mode;
    TLint1	alignment;
    struct Language_Compile_Location	uninitTableLoc;
    TLint4	tSize;
    struct Language_Compile___x2028	u;
};
typedef	TLint1	Language_Compile_ValueKind;
typedef	TLchar	Language_Compile___x2030[16];
typedef	Language_Compile___x2030	Language_Compile___x2029[9];
extern Language_Compile___x2029	Language_Compile_ValueKindName;
typedef	TLnat4	Language_Compile_ValueSetType;
struct	Language_Compile___x2031 {
    Language_Compile_ValueKind	valTag;
    union {
	struct {
	    struct Language_Compile_ValueDef	*next;
	} __u23;
	struct {
	    TLboolean	boolVal;
	} __u24;
	struct {
	    TLchar	charVal;
	} __u25;
	struct {
	    struct Language_Compile_CharDef	*cstrVal;
	} __u26;
	struct {
	    TLboolean	negative;
	    TLnat4	natVal;
	} __u27;
	struct {
	    TLreal8	realVal;
	} __u28;
	struct {
	    Language_Compile_ValueSetType	setVal;
	} __u29;
	struct {
	    Language_StringDef	*stringVal;
	} __u30;
    } __u22;
} ;
struct	Language_Compile_ValueDef {
    TLboolean	saved;
    struct Language_Compile___x2031	u;
};
struct	Language_Compile___x2032 {
    Language_Compile_Tok	tok;
    union {
	struct {
	    struct Language_Compile_CharDef	*cstrPtr;
	} __u32;
	struct {
	    TLnat4	natVal;
	} __u33;
	struct {
	    TLreal8	realVal;
	} __u34;
	struct {
	    Language_StringDef	*strPtr;
	} __u35;
    } __u31;
} ;
struct	Language_Compile_TokRecord {
    struct SrcPosition	srcPos;
    struct Language_Compile_IdentDef	*identPtr;
    struct Language_Compile___x2032	u;
};
extern struct Language_Compile_TokRecord	Language_Compile_newTok;
extern struct Language_Compile_TokRecord	Language_Compile_oldTok;

//extern char *strcpy ();

void Language_Compile_CleanChar ();

void Language_Compile_CleanCString ();

void Language_Compile_IdentToName ();

void Language_Compile_TokenToName ();

void Language_Compile_SymbolToName ();
extern void	*Language_Compile_compilingUnit;
extern void	*Language_Compile_predefUnit;

void Language_Compile_CompileError_Add ();

void Language_Compile_CompileError_Initialize ();

TLnat4 Language_Compile_CompileError_Count ();
static struct SrcPosition	Language_Compile_CompileError_lastSrcPos;
static Language_ErrorSeverity	Language_Compile_CompileError_lastStatus;

static TLboolean Language_Compile_CompileError_MultipleErrorsOnLine (srcPos, status)
struct SrcPosition	*srcPos;
Language_ErrorSeverity	status;
{
    TLSTKCHKSLF(100026);
    TLSETF();
    TLSETL(100026);
    if (((((*srcPos).lineNo) <= (Language_Compile_CompileError_lastSrcPos.lineNo)) && (((*srcPos).fileNo) == (Language_Compile_CompileError_lastSrcPos.fileNo))) && (Language_Compile_CompileError_lastStatus != 3)) {
	TLSETL(100029);
	TLRESTORELF();
	return (((TLnat4) status) <= ((TLnat4) Language_Compile_CompileError_lastStatus));
    } else {
	TLSETL(100031);
	TLRESTORELF();
	return (0);
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

static void Language_Compile_CompileError_LineFile (srcPos, status)
struct SrcPosition	*srcPos;
Language_ErrorSeverity	status;
{
    TLSTKCHKSLF(100037);
    TLSETF();
    TLSETL(100037);
    TLSTRCTASS(Language_Compile_CompileError_lastSrcPos, (*srcPos), struct SrcPosition);
    TLINCL();
    Language_Compile_CompileError_lastStatus = status;
    TLRESTORELF();
}
typedef	TLchar	Language_Compile_CompileError___x2053[256];
static Language_Compile_CompileError___x2053	Language_Compile_CompileError_message;
static TLint2	Language_Compile_CompileError_msgLen;

static void Language_Compile_CompileError_Transfer (msg, capitalize)
TLstring	msg;
TLboolean	capitalize;
{
    register TLaddressint	ptr;
    TLSTKCHKSLF(100047);
    TLSETF();
    TLSETL(100047);
    if (Language_Compile_CompileError_msgLen >= (254)) {
	TLSETL(100049);
	TLRESTORELF();
	return;
    };
    TLSETL(100050);
    ptr = (TLaddressint) ((unsigned long)msg);
    TLINCL();
    if ((capitalize && (((* (TLchar *) ptr)) >= 'a')) && (((* (TLchar *) ptr)) <= 'z')) {
	TLSETL(100052);
	Language_Compile_CompileError_msgLen += 1;
	TLINCL();
	Language_Compile_CompileError_message[(Language_Compile_CompileError_msgLen - 1)] = ((TLchar) ((((TLnat4) ((* (TLchar *) ptr))) + 65) - 97));
	TLINCL();
	ptr += 1;
    };
    TLSETL(100057);
    for(;;) {
	TLSETL(100057);
	if ((((* (TLchar *) ptr)) == '\0') || (Language_Compile_CompileError_msgLen >= (254))) {
	    break;
	};
	TLSETL(100058);
	Language_Compile_CompileError_msgLen += 1;
	TLINCL();
	Language_Compile_CompileError_message[(Language_Compile_CompileError_msgLen - 1)] = (* (TLchar *) ptr);
	TLINCL();
	ptr += 1;
    };
    TLRESTORELF();
}
static TLstring	Language_Compile_CompileError_errorString1;
static TLstring	Language_Compile_CompileError_errorString2;

static void Language_Compile_CompileError_DisplayMessage (msg)
TLstring	msg;
{
    register TLaddressint	src;
    TLSTKCHKSLF(100070);
    TLSETF();
    TLSETL(100070);
    src = (TLaddressint) ((unsigned long)msg);
    TLSETL(100072);
    for(;;) {
	register TLchar	c;
	TLSETL(100072);
	c = (* (TLchar *) src);
	TLINCL();
	src += 1;
	TLSETL(100075);
	if ((c == '\0') || (Language_Compile_CompileError_msgLen == (254))) {
	    break;
	};
	TLSETL(100076);
	if (c == '\\') {
	    TLSETL(100077);
	    c = (* (TLchar *) src);
	    TLINCL();
	    src += 1;
	    TLINCL();
	    if (c == '1') {
		TLSETL(100081);
		Language_Compile_CompileError_Transfer(Language_Compile_CompileError_errorString1, (TLboolean) ((unsigned long) src == ((unsigned long) ((unsigned long)msg) + 2)));
	    } else {
		TLSETL(100081);
		if (c == '2') {
		    TLSETL(100083);
		    Language_Compile_CompileError_Transfer(Language_Compile_CompileError_errorString2, (TLboolean) ((unsigned long) src == ((unsigned long) ((unsigned long)msg) + 2)));
		} else {
		    TLSETL(100084);
		    Language_Compile_CompileError_msgLen += 1;
		    TLINCL();
		    Language_Compile_CompileError_message[(Language_Compile_CompileError_msgLen - 1)] = c;
		};
	    };
	} else {
	    TLSETL(100087);
	    if ((((unsigned long) src == ((unsigned long) ((unsigned long)msg) + 1)) && (c >= 'a')) && (c <= 'z')) {
		TLSETL(100088);
		Language_Compile_CompileError_msgLen += 1;
		TLINCL();
		Language_Compile_CompileError_message[(Language_Compile_CompileError_msgLen - 1)] = ((TLchar) ((((TLnat4) c) + 65) - 97));
	    } else {
		TLSETL(100091);
		Language_Compile_CompileError_msgLen += 1;
		TLINCL();
		Language_Compile_CompileError_message[(Language_Compile_CompileError_msgLen - 1)] = c;
	    };
	};
    };
    TLSETL(100095);
    Language_Compile_CompileError_msgLen += 1;
    TLINCL();
    Language_Compile_CompileError_message[(Language_Compile_CompileError_msgLen - 1)] = '\0';
    TLRESTORELF();
}
static TLnat4	Language_Compile_CompileError_errorCount;

TLnat4 Language_Compile_CompileError_Count () {
    TLSTKCHKSLF(100102);
    TLSETF();
    TLSETL(100102);
    TLRESTORELF();
    return (Language_Compile_CompileError_errorCount);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

void Language_Compile_CompileError_Add (msgIndex, srcPos, str1, str2, status)
TLint2	msgIndex;
struct SrcPosition	*srcPos;
TLstring	str1;
TLstring	str2;
Language_ErrorSeverity	status;
{
    TLSTKCHKSLF(100108);
    TLSETF();
    TLSETL(100108);
    if (Language_Compile_CompileError_MultipleErrorsOnLine(&((*srcPos)), (Language_ErrorSeverity) status)) {
	TLSETL(100110);
	TLRESTORELF();
	return;
    };
    TLSETL(100112);
    if (status != 0) {
	TLSETL(100113);
	Language_Compile_CompileError_errorCount += 1;
    };
    TLSETL(100118);
    Language_Compile_CompileError_LineFile(&((*srcPos)), (Language_ErrorSeverity) status);
    TLSTRASS(255, Language_Compile_CompileError_errorString1, str1);
    TLINCL();
    TLSTRASS(255, Language_Compile_CompileError_errorString2, str2);
    TLSETL(100121);
    Language_Compile_CompileError_msgLen = 0;
    TLSETL(100123);
    switch (msgIndex) {
	case 10001:
	    {
		TLSETL(2100004);
		Language_Compile_CompileError_DisplayMessage("Argument of \'addr\' is a register variable or \'for\' loop index");
	    }
	    break;
	case 10002:
	    {
		TLSETL(2100007);
		Language_Compile_CompileError_DisplayMessage("Argument of \'addr\' is a scalar constant or expression");
	    }
	    break;
	case 10003:
	    {
		TLSETL(2100010);
		Language_Compile_CompileError_DisplayMessage("Can only declare \\1 types as named types");
	    }
	    break;
	case 10004:
	    {
		TLSETL(2100013);
		Language_Compile_CompileError_DisplayMessage("Argument to \'empty\' must be a condition");
	    }
	    break;
	case 10005:
	    {
		TLSETL(2100016);
		Language_Compile_CompileError_DisplayMessage("Argument is the wrong type");
	    }
	    break;
	case 10006:
	    {
		TLSETL(2100019);
		Language_Compile_CompileError_DisplayMessage("Operands of \'\\1\' must be integer or real");
	    }
	    break;
	case 10007:
	    {
		TLSETL(2100022);
		Language_Compile_CompileError_DisplayMessage("Operands of \'\\1\' must be both integer or real, or compatible sets");
	    }
	    break;
	case 10008:
	    {
		TLSETL(2100025);
		Language_Compile_CompileError_DisplayMessage("Operands of \'\\1\' must be both integer or real, compatible sets, or strings");
	    }
	    break;
	case 10009:
	    {
		TLSETL(2100028);
		Language_Compile_CompileError_DisplayMessage("Implementation restriction -- Array is too large");
	    }
	    break;
	case 10010:
	    {
		TLSETL(2100031);
		Language_Compile_CompileError_DisplayMessage("\'asm\' is not supported in this interpreter");
	    }
	    break;
	case 10011:
	    {
		TLSETL(2100034);
		Language_Compile_CompileError_DisplayMessage("Left side of assignment is not a variable and hence cannot be assigned to");
	    }
	    break;
	case 10012:
	    {
		TLSETL(2100037);
		Language_Compile_CompileError_DisplayMessage("Assigned value is the wrong type");
	    }
	    break;
	case 10013:
	    {
		TLSETL(2100040);
		Language_Compile_CompileError_DisplayMessage("\'\\1\' found, \'\\2\' assumed");
	    }
	    break;
	case 10014:
	    {
		TLSETL(2100043);
		Language_Compile_CompileError_DisplayMessage("Must initialize automatically sized arrays");
	    }
	    break;
	case 10015:
	    {
		TLSETL(2100046);
		Language_Compile_CompileError_DisplayMessage("Argument to \'addr\' must be a variable, nonscalar constant, procedure, function, or process");
	    }
	    break;
	case 10016:
	    {
		TLSETL(2100049);
		Language_Compile_CompileError_DisplayMessage("First argument to \'lower\' must be an array variable or subrange type");
	    }
	    break;
	case 10017:
	    {
		TLSETL(2100052);
		Language_Compile_CompileError_DisplayMessage("Argument to \'sizeof\' must be a variable or type");
	    }
	    break;
	case 10018:
	    {
		TLSETL(2100055);
		Language_Compile_CompileError_DisplayMessage("First argument to \'upper\' must be an array, a string or char variable, or a subrange type");
	    }
	    break;
	case 10019:
	    {
		TLSETL(2100058);
		Language_Compile_CompileError_DisplayMessage("Illegal char found in integer literal");
	    }
	    break;
	case 10020:
	    {
		TLSETL(2100061);
		Language_Compile_CompileError_DisplayMessage("Cannot declare a \\1 within a \\2");
	    }
	    break;
	case 10021:
	    {
		TLSETL(2100064);
		Language_Compile_CompileError_DisplayMessage("\\1 subprograms cannot be subprogram variables");
	    }
	    break;
	case 10022:
	    {
		TLSETL(2100067);
		Language_Compile_CompileError_DisplayMessage("Bind variable \\1 is bound to a non-variable");
	    }
	    break;
	case 10023:
	    {
		TLSETL(2100070);
		Language_Compile_CompileError_DisplayMessage("Variable in \'bits\' assigment must be \'nat\' type");
	    }
	    break;
	case 10024:
	    {
		TLSETL(2100073);
		Language_Compile_CompileError_DisplayMessage("Expression in \'bits\' reference must be integer");
	    }
	    break;
	case 10025:
	    {
		TLSETL(2100076);
		Language_Compile_CompileError_DisplayMessage("Lower bound of \'bits\' range is less than 0");
	    }
	    break;
	case 10026:
	    {
		TLSETL(2100079);
		Language_Compile_CompileError_DisplayMessage("Subrange in \'bits\' reference must be integer");
	    }
	    break;
	case 10027:
	    {
		TLSETL(2100082);
		Language_Compile_CompileError_DisplayMessage("Named type in \'bits\' reference must be a subrange type");
	    }
	    break;
	case 10028:
	    {
		TLSETL(2100085);
		Language_Compile_CompileError_DisplayMessage("Operands of \'\\1\' must be integer");
	    }
	    break;
	case 10029:
	    {
		TLSETL(2100088);
		Language_Compile_CompileError_DisplayMessage("Implementation restriction -- Block nesting too deep");
	    }
	    break;
	case 10030:
	    {
		TLSETL(2100091);
		Language_Compile_CompileError_DisplayMessage("Symbol \\1 is not a forward subprogram");
	    }
	    break;
	case 10031:
	    {
		TLSETL(2100094);
		Language_Compile_CompileError_DisplayMessage("Operands of boolean operators must be boolean");
	    }
	    break;
	case 10032:
	    {
		TLSETL(2100097);
		Language_Compile_CompileError_DisplayMessage("\\1 is a procedure call and hence does not return a value");
	    }
	    break;
	case 10033:
	    {
		TLSETL(2100100);
		Language_Compile_CompileError_DisplayMessage("\\1 is not a procedure and hence cannot be called");
	    }
	    break;
	case 10034:
	    {
		TLSETL(2100103);
		Language_Compile_CompileError_DisplayMessage("Unable to open file \"\\1\" [\"\\2\"]");
	    }
	    break;
	case 10035:
	    {
		TLSETL(2100106);
		Language_Compile_CompileError_DisplayMessage("Case alternative label is the wrong type");
	    }
	    break;
	case 10036:
	    {
		TLSETL(2100109);
		Language_Compile_CompileError_DisplayMessage("\'case\' statement must have at least one non otherwise alternative");
	    }
	    break;
	case 10037:
	    {
		TLSETL(2100112);
		Language_Compile_CompileError_DisplayMessage("Implementation restriction -- Range of case alternatives is too large");
	    }
	    break;
	case 10038:
	    {
		TLSETL(2100115);
		Language_Compile_CompileError_DisplayMessage("Circular dependency of unit \'\\1\'");
	    }
	    break;
	case 10039:
	    {
		TLSETL(2100118);
		Language_Compile_CompileError_DisplayMessage("Size of class variables is too big");
	    }
	    break;
	case 10040:
	    {
		TLSETL(2100121);
		Language_Compile_CompileError_DisplayMessage("Exported symbol \\1 is not a type, collection, or compile-time constant and must be referenced using a pointer to the class");
	    }
	    break;
	case 10041:
	    {
		TLSETL(2100124);
		Language_Compile_CompileError_DisplayMessage("Cannot reference entire class object values");
	    }
	    break;
	case 10042:
	    {
		TLSETL(2100127);
		Language_Compile_CompileError_DisplayMessage("Code table overflow");
	    }
	    break;
	case 10043:
	    {
		TLSETL(2100130);
		Language_Compile_CompileError_DisplayMessage("Comment ends at end of file");
	    }
	    break;
	case 10044:
	    {
		TLSETL(2100133);
		Language_Compile_CompileError_DisplayMessage("/* found inside comment");
	    }
	    break;
	case 10045:
	    {
		TLSETL(2100136);
		Language_Compile_CompileError_DisplayMessage("Operands of comparison operators must be scalars, sets or strings");
	    }
	    break;
	case 10046:
	    {
		TLSETL(2100139);
		Language_Compile_CompileError_DisplayMessage("Operands of comparison operators must be of the same type");
	    }
	    break;
	case 10047:
	    {
		TLSETL(2100142);
		Language_Compile_CompileError_DisplayMessage("Compile time expression expected");
	    }
	    break;
	case 10048:
	    {
		TLSETL(2100145);
		Language_Compile_CompileError_DisplayMessage("Compile time int expression expected");
	    }
	    break;
	case 10049:
	    {
		TLSETL(2100148);
		Language_Compile_CompileError_DisplayMessage("Compile-time \'shr\' or \'shl\' by negative value");
	    }
	    break;
	case 10050:
	    {
		TLSETL(2100151);
		Language_Compile_CompileError_DisplayMessage("Conditions must be \'deferred\' in a device monitor");
	    }
	    break;
	case 10051:
	    {
		TLSETL(2100154);
		Language_Compile_CompileError_DisplayMessage("\'condition\'s may only be declared within monitors");
	    }
	    break;
	case 10052:
	    {
		TLSETL(2100157);
		Language_Compile_CompileError_DisplayMessage("\'register\' const\'s must not be declared at the main program level, or at module or monitor level");
	    }
	    break;
	case 10053:
	    {
		TLSETL(2100160);
		Language_Compile_CompileError_DisplayMessage("Forward subprograms may not be declared as \'deferred\'");
	    }
	    break;
	case 10054:
	    {
		TLSETL(2100163);
		Language_Compile_CompileError_DisplayMessage("Cannot allocate deferred subprogram in orphan module/monitor");
	    }
	    break;
	case 10055:
	    {
		TLSETL(2100166);
		Language_Compile_CompileError_DisplayMessage("Deferred subprogram \\1 must be resolved in its original scope");
	    }
	    break;
	case 10056:
	    {
		TLSETL(2100169);
		Language_Compile_CompileError_DisplayMessage("Device monitor priority must be integer");
	    }
	    break;
	case 10057:
	    {
		TLSETL(2100172);
		Language_Compile_CompileError_DisplayMessage("Compile time \'div\', \'mod\', or \'rem\' by zero");
	    }
	    break;
	case 10058:
	    {
		TLSETL(2100175);
		Language_Compile_CompileError_DisplayMessage("Duplicate \'case\' label");
	    }
	    break;
	case 10059:
	    {
		TLSETL(2100178);
		Language_Compile_CompileError_DisplayMessage("\'\\1\' \'export\'ed more than once");
	    }
	    break;
	case 10060:
	    {
		TLSETL(2100181);
		Language_Compile_CompileError_DisplayMessage("Duplicate \'forward\' declaration");
	    }
	    break;
	case 10061:
	    {
		TLSETL(2100184);
		Language_Compile_CompileError_DisplayMessage("Unit \"\\1\" already implemented by \"\\2\"");
	    }
	    break;
	case 10062:
	    {
		TLSETL(2100187);
		Language_Compile_CompileError_DisplayMessage("Duplicate \'union\' label value");
	    }
	    break;
	case 10063:
	    {
		TLSETL(2100190);
		Language_Compile_CompileError_DisplayMessage("Cannot assign dynamic arrays");
	    }
	    break;
	case 10064:
	    {
		TLSETL(2100193);
		Language_Compile_CompileError_DisplayMessage("\\1 is a dynamic array and cannot be exported from class \\2");
	    }
	    break;
	case 10065:
	    {
		TLSETL(2100196);
		Language_Compile_CompileError_DisplayMessage("Dynamic arrays must not have an \'init\' clause");
	    }
	    break;
	case 10066:
	    {
		TLSETL(2100199);
		Language_Compile_CompileError_DisplayMessage("Dynamic array or string(*) passed to non-dynamic parameter");
	    }
	    break;
	case 10067:
	    {
		TLSETL(2100202);
		Language_Compile_CompileError_DisplayMessage("Char literal must have at least one char");
	    }
	    break;
	case 10068:
	    {
		TLSETL(2100205);
		Language_Compile_CompileError_DisplayMessage("File name is empty");
	    }
	    break;
	case 10069:
	    {
		TLSETL(2100208);
		Language_Compile_CompileError_DisplayMessage("Cannot \\1 symbol \\2 unless it is in the same scope");
	    }
	    break;
	case 10070:
	    {
		TLSETL(2100211);
		Language_Compile_CompileError_DisplayMessage("Cannot \\1 yourself");
	    }
	    break;
	case 10071:
	    {
		TLSETL(2100214);
		Language_Compile_CompileError_DisplayMessage("Expression is not a variable");
	    }
	    break;
	case 10072:
	    {
		TLSETL(2100217);
		Language_Compile_CompileError_DisplayMessage("Implementation restriction -- Expression nesting too deep");
	    }
	    break;
	case 10073:
	    {
		TLSETL(2100220);
		Language_Compile_CompileError_DisplayMessage("Expression passed to \'var\' formal");
	    }
	    break;
	case 10074:
	    {
		TLSETL(2100223);
		Language_Compile_CompileError_DisplayMessage("External address specification must be integer or string");
	    }
	    break;
	case 10075:
	    {
		TLSETL(2100226);
		Language_Compile_CompileError_DisplayMessage("Cannot export external subprogram \\1 from monitor");
	    }
	    break;
	case 10076:
	    {
		TLSETL(2100229);
		Language_Compile_CompileError_DisplayMessage("Extra \'end\'");
	    }
	    break;
	case 10077:
	    {
		TLSETL(2100232);
		Language_Compile_CompileError_DisplayMessage("Unit \\1 is not included in the program");
	    }
	    break;
	case 10078:
	    {
		TLSETL(2100235);
		Language_Compile_CompileError_DisplayMessage("Function \\1 is not declared with a result id");
	    }
	    break;
	case 10079:
	    {
		TLSETL(2100238);
		Language_Compile_CompileError_DisplayMessage("Extraneous text at end of file");
	    }
	    break;
	case 10080:
	    {
		TLSETL(2100241);
		Language_Compile_CompileError_DisplayMessage("\'fork\' address variable must be addressint");
	    }
	    break;
	case 10081:
	    {
		TLSETL(2100244);
		Language_Compile_CompileError_DisplayMessage("\'fork\' argument must be a process");
	    }
	    break;
	case 10082:
	    {
		TLSETL(2100247);
		Language_Compile_CompileError_DisplayMessage("\'fork\' status variable must be boolean");
	    }
	    break;
	case 10083:
	    {
		TLSETL(2100250);
		Language_Compile_CompileError_DisplayMessage("\'fork\' status or address argument is not a variable");
	    }
	    break;
	case 10084:
	    {
		TLSETL(2100253);
		Language_Compile_CompileError_DisplayMessage("Forward subprogram \\1 must be resolved in its original scope");
	    }
	    break;
	case 10085:
	    {
		TLSETL(2100256);
		Language_Compile_CompileError_DisplayMessage("Forward import \\1 must be resolved in its original scope");
	    }
	    break;
	case 10086:
	    {
		TLSETL(2100259);
		Language_Compile_CompileError_DisplayMessage("Forward type \\1 must be resolved in its original scope");
	    }
	    break;
	case 10087:
	    {
		TLSETL(2100262);
		Language_Compile_CompileError_DisplayMessage("Function \\1 was declared with \'()\'");
	    }
	    break;
	case 10088:
	    {
		TLSETL(2100265);
		Language_Compile_CompileError_DisplayMessage("Parameterless function types must be declared with \'()\'");
	    }
	    break;
	case 10089:
	    {
		TLSETL(2100268);
		Language_Compile_CompileError_DisplayMessage("Function \\1 was not declared with \'()\'");
	    }
	    break;
	case 10090:
	    {
		TLSETL(2100271);
		Language_Compile_CompileError_DisplayMessage("Size of global variables is too big");
	    }
	    break;
	case 10091:
	    {
		TLSETL(2100274);
		Language_Compile_CompileError_DisplayMessage("Identifier size is too large - only the first \\1 characters used");
	    }
	    break;
	case 10092:
	    {
		TLSETL(2100277);
		Language_Compile_CompileError_DisplayMessage("Input/Output status variable is not a variable");
	    }
	    break;
	case 10093:
	    {
		TLSETL(2100280);
		Language_Compile_CompileError_DisplayMessage("Input/Output status variable must be an integer");
	    }
	    break;
	case 10094:
	    {
		TLSETL(2100283);
		Language_Compile_CompileError_DisplayMessage("Illegal array reference");
	    }
	    break;
	case 10095:
	    {
		TLSETL(2100286);
		Language_Compile_CompileError_DisplayMessage("Target of \'\\1=\' must be boolean or integer");
	    }
	    break;
	case 10096:
	    {
		TLSETL(2100289);
		Language_Compile_CompileError_DisplayMessage("Target of \'\\1=\' must be boolean");
	    }
	    break;
	case 10097:
	    {
		TLSETL(2100292);
		Language_Compile_CompileError_DisplayMessage("Illegal character \'\\1\'");
	    }
	    break;
	case 10098:
	    {
		TLSETL(2100295);
		Language_Compile_CompileError_DisplayMessage("Illegal extended character in string literal");
	    }
	    break;
	case 10099:
	    {
		TLSETL(2100298);
		Language_Compile_CompileError_DisplayMessage("Illegal get item");
	    }
	    break;
	case 10100:
	    {
		TLSETL(2100301);
		Language_Compile_CompileError_DisplayMessage("\'get\' width applies only to strings and char(n)");
	    }
	    break;
	case 10101:
	    {
		TLSETL(2100304);
		Language_Compile_CompileError_DisplayMessage("Illegal include statement");
	    }
	    break;
	case 10102:
	    {
		TLSETL(2100307);
		Language_Compile_CompileError_DisplayMessage("Target of \'\\1=\' must be integer");
	    }
	    break;
	case 10103:
	    {
		TLSETL(2100310);
		Language_Compile_CompileError_DisplayMessage("Target of \'\\1=\' must be integer or set");
	    }
	    break;
	case 10104:
	    {
		TLSETL(2100313);
		Language_Compile_CompileError_DisplayMessage("Target of \'\\1=\' must be integer or real");
	    }
	    break;
	case 10105:
	    {
		TLSETL(2100316);
		Language_Compile_CompileError_DisplayMessage("Target of \'\\1=\' must be integer, real, or set");
	    }
	    break;
	case 10106:
	    {
		TLSETL(2100319);
		Language_Compile_CompileError_DisplayMessage("Target of \'\\1=\' must be integer, real, set, or string");
	    }
	    break;
	case 10107:
	    {
		TLSETL(2100322);
		Language_Compile_CompileError_DisplayMessage("Parameter of \'objectclass\' must be a pointer to a class");
	    }
	    break;
	case 10108:
	    {
		TLSETL(2100325);
		Language_Compile_CompileError_DisplayMessage("Object of pointer is not a collection, class or type");
	    }
	    break;
	case 10109:
	    {
		TLSETL(2100328);
		Language_Compile_CompileError_DisplayMessage("Illegal usage of nil pointer reference");
	    }
	    break;
	case 10110:
	    {
		TLSETL(2100331);
		Language_Compile_CompileError_DisplayMessage("Predefined routine \\1 can only be referenced by calling it");
	    }
	    break;
	case 10111:
	    {
		TLSETL(2100334);
		Language_Compile_CompileError_DisplayMessage("Illegal put item");
	    }
	    break;
	case 10112:
	    {
		TLSETL(2100337);
		Language_Compile_CompileError_DisplayMessage("\'put\' fraction width applies only to integer or real items");
	    }
	    break;
	case 10113:
	    {
		TLSETL(2100340);
		Language_Compile_CompileError_DisplayMessage("Target of \'\\1=\' must be real");
	    }
	    break;
	case 10114:
	    {
		TLSETL(2100343);
		Language_Compile_CompileError_DisplayMessage("\'self\' may only be used within classes");
	    }
	    break;
	case 10115:
	    {
		TLSETL(2100346);
		Language_Compile_CompileError_DisplayMessage("Illegal set contructor");
	    }
	    break;
	case 10116:
	    {
		TLSETL(2100349);
		Language_Compile_CompileError_DisplayMessage("Illegal string or char(n) subscript");
	    }
	    break;
	case 10117:
	    {
		TLSETL(2100352);
		Language_Compile_CompileError_DisplayMessage("Subrange bounds must be both integers, chars or elements of the same enumerated type");
	    }
	    break;
	case 10118:
	    {
		TLSETL(2100355);
		Language_Compile_CompileError_DisplayMessage("\\1 cannot have subscripts");
	    }
	    break;
	case 10119:
	    {
		TLSETL(2100358);
		Language_Compile_CompileError_DisplayMessage("Illegal type cheat");
	    }
	    break;
	case 10120:
	    {
		TLSETL(2100361);
		Language_Compile_CompileError_DisplayMessage("Type cheat size expression value is not valid for the expression type");
	    }
	    break;
	case 10121:
	    {
		TLSETL(2100364);
		Language_Compile_CompileError_DisplayMessage("Illegal type reference");
	    }
	    break;
	case 10122:
	    {
		TLSETL(2100367);
		Language_Compile_CompileError_DisplayMessage("\'\\1\' is not a legal unit type");
	    }
	    break;
	case 10123:
	    {
		TLSETL(2100370);
		Language_Compile_CompileError_DisplayMessage("Unqualified exports from class \\1 restricted to types, collections, and compile-time constants");
	    }
	    break;
	case 10124:
	    {
		TLSETL(2100373);
		Language_Compile_CompileError_DisplayMessage("Illegal variable reference");
	    }
	    break;
	case 10125:
	    {
		TLSETL(2100376);
		Language_Compile_CompileError_DisplayMessage("Import symbol \\1 conflicts with a previous import in \\2");
	    }
	    break;
	case 10126:
	    {
		TLSETL(2100379);
		Language_Compile_CompileError_DisplayMessage("Import symbol \\1 conflicts with a previous import");
	    }
	    break;
	case 10127:
	    {
		TLSETL(2100382);
		Language_Compile_CompileError_DisplayMessage("\\1 is imported more than once");
	    }
	    break;
	case 10128:
	    {
		TLSETL(2100385);
		Language_Compile_CompileError_DisplayMessage("Cannot have \'import\' statement in a deferred \\1");
	    }
	    break;
	case 10129:
	    {
		TLSETL(2100388);
		Language_Compile_CompileError_DisplayMessage("\'init\' value is the wrong type");
	    }
	    break;
	case 10130:
	    {
		TLSETL(2100391);
		Language_Compile_CompileError_DisplayMessage("Missing base for integer literal");
	    }
	    break;
	case 10131:
	    {
		TLSETL(2100394);
		Language_Compile_CompileError_DisplayMessage("Base of integer literal is too large");
	    }
	    break;
	case 10132:
	    {
		TLSETL(2100397);
		Language_Compile_CompileError_DisplayMessage("Integer literal value too large");
	    }
	    break;
	case 10316:
	    {
		TLSETL(2100400);
		Language_Compile_CompileError_DisplayMessage("Compile time integer overflow");
	    }
	    break;
	case 10133:
	    {
		TLSETL(2100403);
		Language_Compile_CompileError_DisplayMessage("Interrupt procedure device specification must be nat");
	    }
	    break;
	case 10134:
	    {
		TLSETL(2100406);
		Language_Compile_CompileError_DisplayMessage("Arguments to abs must be integer or real");
	    }
	    break;
	case 10135:
	    {
		TLSETL(2100409);
		Language_Compile_CompileError_DisplayMessage("Incorrect use of \'all\'");
	    }
	    break;
	case 10136:
	    {
		TLSETL(2100412);
		Language_Compile_CompileError_DisplayMessage("\'bind\'s must not be declared at the main program level, or at module or monitor level");
	    }
	    break;
	case 10137:
	    {
		TLSETL(2100415);
		Language_Compile_CompileError_DisplayMessage("Bad type for case expression");
	    }
	    break;
	case 10138:
	    {
		TLSETL(2100418);
		Language_Compile_CompileError_DisplayMessage("Argument to \'chr\' must be integer");
	    }
	    break;
	case 10139:
	    {
		TLSETL(2100421);
		Language_Compile_CompileError_DisplayMessage("Class export \\1 cannot be referenced using a pointer to the class");
	    }
	    break;
	case 10140:
	    {
		TLSETL(2100424);
		Language_Compile_CompileError_DisplayMessage("\'\\1\' is not an element of enum \\2");
	    }
	    break;
	case 10141:
	    {
		TLSETL(2100427);
		Language_Compile_CompileError_DisplayMessage("\'exit\' can be used only in a \'loop\' or \'for\' statement");
	    }
	    break;
	case 10142:
	    {
		TLSETL(2100430);
		Language_Compile_CompileError_DisplayMessage("Only \'type\'s, \'const\'s, \'var\'s, and subprograms may be exported from a module");
	    }
	    break;
	case 10143:
	    {
		TLSETL(2100433);
		Language_Compile_CompileError_DisplayMessage("\\1 cannot be followed by a \'.\'");
	    }
	    break;
	case 10144:
	    {
		TLSETL(2100436);
		Language_Compile_CompileError_DisplayMessage("\'for\' range bounds must be both integers, chars or elements of the same enumerated type");
	    }
	    break;
	case 10145:
	    {
		TLSETL(2100439);
		Language_Compile_CompileError_DisplayMessage("\'for\' step size must be integer");
	    }
	    break;
	case 10146:
	    {
		TLSETL(2100442);
		Language_Compile_CompileError_DisplayMessage("Index type must be subrange, boolean, char or enumerated type");
	    }
	    break;
	case 10147:
	    {
		TLSETL(2100445);
		Language_Compile_CompileError_DisplayMessage("\'init\' is used only to initialize arrays, records and unions");
	    }
	    break;
	case 10148:
	    {
		TLSETL(2100448);
		Language_Compile_CompileError_DisplayMessage("Initialization value is the wrong type");
	    }
	    break;
	case 10149:
	    {
		TLSETL(2100451);
		Language_Compile_CompileError_DisplayMessage("\'invariant\' may only appear in loops and \'module\'s");
	    }
	    break;
	case 10150:
	    {
		TLSETL(2100454);
		Language_Compile_CompileError_DisplayMessage("Arguments to min/max must be integer or real");
	    }
	    break;
	case 10151:
	    {
		TLSETL(2100457);
		Language_Compile_CompileError_DisplayMessage("Argument to \'nil\' must be a collection or class");
	    }
	    break;
	case 10152:
	    {
		TLSETL(2100460);
		Language_Compile_CompileError_DisplayMessage("Argument to \'ord\' must be string or enum");
	    }
	    break;
	case 10153:
	    {
		TLSETL(2100463);
		Language_Compile_CompileError_DisplayMessage("\'post\' may only appear in subprograms and \'module\'s");
	    }
	    break;
	case 10154:
	    {
		TLSETL(2100466);
		Language_Compile_CompileError_DisplayMessage("Argument to \'pred/succ\' must be char, int or enum");
	    }
	    break;
	case 10155:
	    {
		TLSETL(2100469);
		Language_Compile_CompileError_DisplayMessage("Invalid real literal value");
	    }
	    break;
	case 10156:
	    {
		TLSETL(2100472);
		Language_Compile_CompileError_DisplayMessage("\'result\' can be used only in a function");
	    }
	    break;
	case 10157:
	    {
		TLSETL(2100475);
		Language_Compile_CompileError_DisplayMessage("\'return\' is only valid in a procedure or main program");
	    }
	    break;
	case 10158:
	    {
		TLSETL(2100478);
		Language_Compile_CompileError_DisplayMessage("Invalid storage size specification ignored");
	    }
	    break;
	case 10159:
	    {
		TLSETL(2100481);
		Language_Compile_CompileError_DisplayMessage("Invalid string maximum length");
	    }
	    break;
	case 10160:
	    {
		TLSETL(2100484);
		Language_Compile_CompileError_DisplayMessage("Subrange lower bound is greater than upper bound");
	    }
	    break;
	case 10161:
	    {
		TLSETL(2100487);
		Language_Compile_CompileError_DisplayMessage("\'\\1\' is not a field of union \\2");
	    }
	    break;
	case 10162:
	    {
		TLSETL(2100490);
		Language_Compile_CompileError_DisplayMessage("\'<>\' found, \'not=\' assumed");
	    }
	    break;
	case 10163:
	    {
		TLSETL(2100493);
		Language_Compile_CompileError_DisplayMessage("Size of local variables is too big");
	    }
	    break;
	case 10164:
	    {
		TLSETL(2100496);
		Language_Compile_CompileError_DisplayMessage("Operands of \'\\1\' must be both boolean, integer, or compatible sets");
	    }
	    break;
	case 10165:
	    {
		TLSETL(2100499);
		Language_Compile_CompileError_DisplayMessage("Second argument to \'lower\' must be <= number of dimensions");
	    }
	    break;
	case 10166:
	    {
		TLSETL(2100502);
		Language_Compile_CompileError_DisplayMessage("Second argument to \'lower\' must be >= 1");
	    }
	    break;
	case 10167:
	    {
		TLSETL(2100505);
		Language_Compile_CompileError_DisplayMessage("Second argument to \'lower\' must be integer");
	    }
	    break;
	case 10168:
	    {
		TLSETL(2100508);
		Language_Compile_CompileError_DisplayMessage("Manifest table overflow");
	    }
	    break;
	case 10169:
	    {
		TLSETL(2100511);
		Language_Compile_CompileError_DisplayMessage("Forward subprogram \\1 was not declared as a \'\\2\'");
	    }
	    break;
	case 10170:
	    {
		TLSETL(2100514);
		Language_Compile_CompileError_DisplayMessage("Symbol \\2 is the wrong kind to \\1");
	    }
	    break;
	case 10171:
	    {
		TLSETL(2100517);
		Language_Compile_CompileError_DisplayMessage("Implement-by unit \"\\1\" implements \"\\2\"");
	    }
	    break;
	case 10172:
	    {
		TLSETL(2100520);
		Language_Compile_CompileError_DisplayMessage("Implement symbol \'\\1\' is implemented by \"\\2\"");
	    }
	    break;
	case 10173:
	    {
		TLSETL(2100523);
		Language_Compile_CompileError_DisplayMessage("End identifier \'\\1\' does not match \'\\2\'");
	    }
	    break;
	case 10174:
	    {
		TLSETL(2100526);
		Language_Compile_CompileError_DisplayMessage("\\1 must be \\2 type");
	    }
	    break;
	case 10175:
	    {
		TLSETL(2100529);
		Language_Compile_CompileError_DisplayMessage("Unit symbol is \'\\1\', not \'\\2\'");
	    }
	    break;
	case 10176:
	    {
		TLSETL(2100532);
		Language_Compile_CompileError_DisplayMessage("Missing parameters in call to subprogram \\1");
	    }
	    break;
	case 10177:
	    {
		TLSETL(2100535);
		Language_Compile_CompileError_DisplayMessage("Body of subprogram \\1 has not been declared");
	    }
	    break;
	case 10178:
	    {
		TLSETL(2100538);
		Language_Compile_CompileError_DisplayMessage("\'case\' statement has no alternatives");
	    }
	    break;
	case 10179:
	    {
		TLSETL(2100541);
		Language_Compile_CompileError_DisplayMessage("Missing parameters for function \\1");
	    }
	    break;
	case 10180:
	    {
		TLSETL(2100544);
		Language_Compile_CompileError_DisplayMessage("Missing result id \\1");
	    }
	    break;
	case 10181:
	    {
		TLSETL(2100547);
		Language_Compile_CompileError_DisplayMessage("Forward type \\1 has not been declared");
	    }
	    break;
	case 10182:
	    {
		TLSETL(2100550);
		Language_Compile_CompileError_DisplayMessage("Module invariant must appear before declaration of exported procedures/functions");
	    }
	    break;
	case 10183:
	    {
		TLSETL(2100553);
		Language_Compile_CompileError_DisplayMessage("\'\\1\'s may only be declared at the program or module level");
	    }
	    break;
	case 10184:
	    {
		TLSETL(2100556);
		Language_Compile_CompileError_DisplayMessage("\'\\1\'s may only be declared at the program, module, or monitor level");
	    }
	    break;
	case 10185:
	    {
		TLSETL(2100559);
		Language_Compile_CompileError_DisplayMessage("Must implement class \'\\1\', not just inherit it");
	    }
	    break;
	case 10186:
	    {
		TLSETL(2100562);
		Language_Compile_CompileError_DisplayMessage("Class/collection and pointer specified for \'\\1\' are incompatible");
	    }
	    break;
	case 10187:
	    {
		TLSETL(2100565);
		Language_Compile_CompileError_DisplayMessage("First argument to \'\\1\' must be a collection, class or flexible array");
	    }
	    break;
	case 10188:
	    {
		TLSETL(2100568);
		Language_Compile_CompileError_DisplayMessage("Argument to \'\\1\' must be a pointer variable");
	    }
	    break;
	case 10189:
	    {
		TLSETL(2100571);
		Language_Compile_CompileError_DisplayMessage("Argument to \'new\' or \'free\' must be a variable");
	    }
	    break;
	case 10190:
	    {
		TLSETL(2100574);
		Language_Compile_CompileError_DisplayMessage("\'\\1\' is constant or read-only in this scope and cannot be \'\\2\'ed");
	    }
	    break;
	case 10191:
	    {
		TLSETL(2100577);
		Language_Compile_CompileError_DisplayMessage("\'external\'s not supported");
	    }
	    break;
	case 10192:
	    {
		TLSETL(2100580);
		Language_Compile_CompileError_DisplayMessage("Unit \"\\1\" has no implement clause");
	    }
	    break;
	case 10193:
	    {
		TLSETL(2100583);
		Language_Compile_CompileError_DisplayMessage("Unit \'\\1\' has no implement-by clause");
	    }
	    break;
	case 10194:
	    {
		TLSETL(2100586);
		Language_Compile_CompileError_DisplayMessage("File \"\\1\" contains non-ascii characters (deleted)");
	    }
	    break;
	case 10195:
	    {
		TLSETL(2100589);
		Language_Compile_CompileError_DisplayMessage("Array \'\\1\' is not flexible, and hence cannot be \'\\2\'ed");
	    }
	    break;
	case 10196:
	    {
		TLSETL(2100592);
		Language_Compile_CompileError_DisplayMessage("String maximum length must be an integer value");
	    }
	    break;
	case 10197:
	    {
		TLSETL(2100595);
		Language_Compile_CompileError_DisplayMessage("First operand of \'tag\' statement must be a union");
	    }
	    break;
	case 10198:
	    {
		TLSETL(2100598);
		Language_Compile_CompileError_DisplayMessage("Non variable passed to \'var\' formal");
	    }
	    break;
	case 10199:
	    {
		TLSETL(2100601);
		Language_Compile_CompileError_DisplayMessage("\'\\1\' is not in the export list of \\2");
	    }
	    break;
	case 10200:
	    {
		TLSETL(2100604);
		Language_Compile_CompileError_DisplayMessage("\\1 is not a main program");
	    }
	    break;
	case 10201:
	    {
		TLSETL(2100607);
		Language_Compile_CompileError_DisplayMessage("\'not\' must be applied to boolean expression");
	    }
	    break;
	case 10202:
	    {
		TLSETL(2100610);
		Language_Compile_CompileError_DisplayMessage("Operand of \'\\1\' is not a pointer");
	    }
	    break;
	case 10203:
	    {
		TLSETL(2100613);
		Language_Compile_CompileError_DisplayMessage("\'\\1\' is not a field of record \\2");
	    }
	    break;
	case 10204:
	    {
		TLSETL(2100616);
		Language_Compile_CompileError_DisplayMessage("Operation is not supported by OOT->C Translator");
	    }
	    break;
	case 10205:
	    {
		TLSETL(2100619);
		Language_Compile_CompileError_DisplayMessage("\\1 is not a type");
	    }
	    break;
	case 10206:
	    {
		TLSETL(2100622);
		Language_Compile_CompileError_DisplayMessage("\'\\1\' is not a unit");
	    }
	    break;
	case 10207:
	    {
		TLSETL(2100625);
		Language_Compile_CompileError_DisplayMessage("\'opaque\' export from \\1 can be applied only to types");
	    }
	    break;
	case 10208:
	    {
		TLSETL(2100628);
		Language_Compile_CompileError_DisplayMessage("Second argument to \'open\' statement must be integer or string");
	    }
	    break;
	case 10209:
	    {
		TLSETL(2100631);
		Language_Compile_CompileError_DisplayMessage("First argument to \'open\' statement must be integer");
	    }
	    break;
	case 10210:
	    {
		TLSETL(2100634);
		Language_Compile_CompileError_DisplayMessage("First argument to \'open\' statement is not a variable");
	    }
	    break;
	case 10211:
	    {
		TLSETL(2100637);
		Language_Compile_CompileError_DisplayMessage("First argument to \'open\' statement is read-only in this scope");
	    }
	    break;
	case 10317:
	    {
		TLSETL(2100640);
		Language_Compile_CompileError_DisplayMessage("Insufficient memory to compile program");
	    }
	    break;
	case 10215:
	    {
		TLSETL(2100643);
		Language_Compile_CompileError_DisplayMessage("Parameter #\\1 should be named \\2");
	    }
	    break;
	case 10212:
	    {
		TLSETL(2100646);
		Language_Compile_CompileError_DisplayMessage("\\1 is a non-var parameter");
	    }
	    break;
	case 10213:
	    {
		TLSETL(2100649);
		Language_Compile_CompileError_DisplayMessage("\\1 is a register parameter");
	    }
	    break;
	case 10214:
	    {
		TLSETL(2100652);
		Language_Compile_CompileError_DisplayMessage("\\1 is a var parameter");
	    }
	    break;
	case 10216:
	    {
		TLSETL(2100655);
		Language_Compile_CompileError_DisplayMessage("\\1 is not a register parameter");
	    }
	    break;
	case 10217:
	    {
		TLSETL(2100658);
		Language_Compile_CompileError_DisplayMessage("Parameter type for \\1 is incorrect");
	    }
	    break;
	case 10218:
	    {
		TLSETL(2100661);
		Language_Compile_CompileError_DisplayMessage("Pervasive exports should also be unqualified");
	    }
	    break;
	case 10219:
	    {
		TLSETL(2100664);
		Language_Compile_CompileError_DisplayMessage("\\1 is not visible in this scope and may not be \'new\'ed or \'free\'ed");
	    }
	    break;
	case 10220:
	    {
		TLSETL(2100667);
		Language_Compile_CompileError_DisplayMessage("Statement will not be executed");
	    }
	    break;
	case 10221:
	    {
		TLSETL(2100670);
		Language_Compile_CompileError_DisplayMessage("Can only reference symbol \\1 in a \'post\' statement");
	    }
	    break;
	case 10222:
	    {
		TLSETL(2100673);
		Language_Compile_CompileError_DisplayMessage("\\1 is a predefined identifier, and cannot be redeclared");
	    }
	    break;
	case 10223:
	    {
		TLSETL(2100676);
		Language_Compile_CompileError_DisplayMessage("Process stack size expression must be integer");
	    }
	    break;
	case 10224:
	    {
		TLSETL(2100679);
		Language_Compile_CompileError_DisplayMessage("Subrange or enum too large to fit in storage size specified - sufficient storage allocated");
	    }
	    break;
	case 10225:
	    {
		TLSETL(2100682);
		Language_Compile_CompileError_DisplayMessage("\\1 is read-only in this scope and cannot be assigned to");
	    }
	    break;
	case 10226:
	    {
		TLSETL(2100685);
		Language_Compile_CompileError_DisplayMessage("Input/Output status variable is read-only in this scope");
	    }
	    break;
	case 10227:
	    {
		TLSETL(2100688);
		Language_Compile_CompileError_DisplayMessage("\\1 is read-only in this scope and cannot be modified by \'\\2\'");
	    }
	    break;
	case 10228:
	    {
		TLSETL(2100691);
		Language_Compile_CompileError_DisplayMessage("\\1 is read-only in this scope and cannot be \'\\2\'ed");
	    }
	    break;
	case 10229:
	    {
		TLSETL(2100694);
		Language_Compile_CompileError_DisplayMessage("Exported procedure \\1 cannot be called because the module is read-only in this scope");
	    }
	    break;
	case 10230:
	    {
		TLSETL(2100697);
		Language_Compile_CompileError_DisplayMessage("\'read\' or \'write\' size result is read-only in this scope");
	    }
	    break;
	case 10231:
	    {
		TLSETL(2100700);
		Language_Compile_CompileError_DisplayMessage("\'tell\' result variable is read-only in this scope");
	    }
	    break;
	case 10232:
	    {
		TLSETL(2100703);
		Language_Compile_CompileError_DisplayMessage("Union is constant or read-only");
	    }
	    break;
	case 10233:
	    {
		TLSETL(2100706);
		Language_Compile_CompileError_DisplayMessage("\\1 is read-only and cannot be exported \'var\' from \\2");
	    }
	    break;
	case 10234:
	    {
		TLSETL(2100709);
		Language_Compile_CompileError_DisplayMessage("Readonly variable passed to \'var\' formal");
	    }
	    break;
	case 10235:
	    {
		TLSETL(2100712);
		Language_Compile_CompileError_DisplayMessage("\\1 is read-only in this scope and cannot be imported \'var\'");
	    }
	    break;
	case 10236:
	    {
		TLSETL(2100715);
		Language_Compile_CompileError_DisplayMessage("Argument to \'read\' or \'write\' statement is not a variable");
	    }
	    break;
	case 10237:
	    {
		TLSETL(2100718);
		Language_Compile_CompileError_DisplayMessage("\'read\' or \'write\' of a register variable or \'for\' loop index");
	    }
	    break;
	case 10238:
	    {
		TLSETL(2100721);
		Language_Compile_CompileError_DisplayMessage("\'read\' or \'write\' size result must be an integer");
	    }
	    break;
	case 10239:
	    {
		TLSETL(2100724);
		Language_Compile_CompileError_DisplayMessage("\'read\' or \'write\' size result is not a variable");
	    }
	    break;
	case 10240:
	    {
		TLSETL(2100727);
		Language_Compile_CompileError_DisplayMessage("Recursive include of \"\\1\"");
	    }
	    break;
	case 10241:
	    {
		TLSETL(2100730);
		Language_Compile_CompileError_DisplayMessage("Bind to register variable");
	    }
	    break;
	case 10242:
	    {
		TLSETL(2100733);
		Language_Compile_CompileError_DisplayMessage("Register variable passed by reference");
	    }
	    break;
	case 10243:
	    {
		TLSETL(2100736);
		Language_Compile_CompileError_DisplayMessage("Result id should be \\1");
	    }
	    break;
	case 10244:
	    {
		TLSETL(2100739);
		Language_Compile_CompileError_DisplayMessage("Mismatch result types for function \\1");
	    }
	    break;
	case 10245:
	    {
		TLSETL(2100742);
		Language_Compile_CompileError_DisplayMessage("\'result\' value is the wrong type");
	    }
	    break;
	case 10318:
	    {
		TLSETL(2100745);
		Language_Compile_CompileError_DisplayMessage("Set element value is not in the range of the specified set type");
	    }
	    break;
	case 10246:
	    {
		TLSETL(2100748);
		Language_Compile_CompileError_DisplayMessage("Set element is the wrong type");
	    }
	    break;
	case 10247:
	    {
		TLSETL(2100751);
		Language_Compile_CompileError_DisplayMessage("Operands of set operators must be sets");
	    }
	    break;
	case 10248:
	    {
		TLSETL(2100754);
		Language_Compile_CompileError_DisplayMessage("Condition for \'signal\' or \'wait\' must be var");
	    }
	    break;
	case 10249:
	    {
		TLSETL(2100757);
		Language_Compile_CompileError_DisplayMessage("\'signal\' or \'wait\' on non-condition");
	    }
	    break;
	case 10250:
	    {
		TLSETL(2100760);
		Language_Compile_CompileError_DisplayMessage("\'\\1\' statements may only be used within monitors");
	    }
	    break;
	case 10251:
	    {
		TLSETL(2100763);
		Language_Compile_CompileError_DisplayMessage("String value in \'init\' list is too long");
	    }
	    break;
	case 10252:
	    {
		TLSETL(2100766);
		Language_Compile_CompileError_DisplayMessage("String literal ends at end of line");
	    }
	    break;
	case 10253:
	    {
		TLSETL(2100769);
		Language_Compile_CompileError_DisplayMessage("String literal is too large");
	    }
	    break;
	case 10254:
	    {
		TLSETL(2100772);
		Language_Compile_CompileError_DisplayMessage("Compile time string overflow");
	    }
	    break;
	case 10255:
	    {
		TLSETL(2100775);
		Language_Compile_CompileError_DisplayMessage("Implementation restriction -- Too many nested function calls");
	    }
	    break;
	case 10256:
	    {
		TLSETL(2100778);
		Language_Compile_CompileError_DisplayMessage("Initial value is out of range");
	    }
	    break;
	case 10257:
	    {
		TLSETL(2100781);
		Language_Compile_CompileError_DisplayMessage("Subscript of \\1 is not a pointer");
	    }
	    break;
	case 10258:
	    {
		TLSETL(2100784);
		Language_Compile_CompileError_DisplayMessage("Subscript of \\1 is not a compatible pointer type");
	    }
	    break;
	case 10259:
	    {
		TLSETL(2100787);
		Language_Compile_CompileError_DisplayMessage("Subscript of \\1 is the wrong type");
	    }
	    break;
	case 10260:
	    {
		TLSETL(2100790);
		Language_Compile_CompileError_DisplayMessage("Substring range bounds must be integer");
	    }
	    break;
	case 10261:
	    {
		TLSETL(2100793);
		Language_Compile_CompileError_DisplayMessage("\\1 has been previously declared");
	    }
	    break;
	case 10262:
	    {
		TLSETL(2100796);
		Language_Compile_CompileError_DisplayMessage("Syntax error at \'\\1\'");
	    }
	    break;
	case 10263:
	    {
		TLSETL(2100799);
		Language_Compile_CompileError_DisplayMessage("Syntax error at \'\\1\', expected \'\\2\'");
	    }
	    break;
	case 10264:
	    {
		TLSETL(2100802);
		Language_Compile_CompileError_DisplayMessage("Syntax error at \'\\1\', expected \'end \\2\'");
	    }
	    break;
	case 10265:
	    {
		TLSETL(2100805);
		Language_Compile_CompileError_DisplayMessage("Tag value is the wrong type");
	    }
	    break;
	case 10266:
	    {
		TLSETL(2100808);
		Language_Compile_CompileError_DisplayMessage("Second argument to \'tell\' statement must be an integer");
	    }
	    break;
	case 10267:
	    {
		TLSETL(2100811);
		Language_Compile_CompileError_DisplayMessage("Second argument to \'tell\' statement is not a variable");
	    }
	    break;
	case 10268:
	    {
		TLSETL(2100814);
		Language_Compile_CompileError_DisplayMessage("Temporary area overflow");
	    }
	    break;
	case 10269:
	    {
		TLSETL(2100817);
		Language_Compile_CompileError_DisplayMessage("Call to \\1 has too few parameters");
	    }
	    break;
	case 10270:
	    {
		TLSETL(2100820);
		Language_Compile_CompileError_DisplayMessage("Too few initial values");
	    }
	    break;
	case 10271:
	    {
		TLSETL(2100823);
		Language_Compile_CompileError_DisplayMessage("Too few parameters specified for \\1");
	    }
	    break;
	case 10272:
	    {
		TLSETL(2100826);
		Language_Compile_CompileError_DisplayMessage("Too few subscripts for \\1");
	    }
	    break;
	case 10273:
	    {
		TLSETL(2100829);
		Language_Compile_CompileError_DisplayMessage("Call to \\1 has too many parameters");
	    }
	    break;
	case 10274:
	    {
		TLSETL(2100832);
		Language_Compile_CompileError_DisplayMessage("\'case\' statement has too many alternatives");
	    }
	    break;
	case 10275:
	    {
		TLSETL(2100835);
		Language_Compile_CompileError_DisplayMessage("Implementation restriction -- Record/union nesting too deep");
	    }
	    break;
	case 10276:
	    {
		TLSETL(2100838);
		Language_Compile_CompileError_DisplayMessage("Implementation restriction -- Too many array indices");
	    }
	    break;
	case 10277:
	    {
		TLSETL(2100841);
		Language_Compile_CompileError_DisplayMessage("Too many initial values");
	    }
	    break;
	case 10278:
	    {
		TLSETL(2100844);
		Language_Compile_CompileError_DisplayMessage("Implementation restriction -- Too many nested symbols");
	    }
	    break;
	case 10279:
	    {
		TLSETL(2100847);
		Language_Compile_CompileError_DisplayMessage("Too many parameters specified for \\1");
	    }
	    break;
	case 10280:
	    {
		TLSETL(2100850);
		Language_Compile_CompileError_DisplayMessage("Too many subscripts for \\1");
	    }
	    break;
	case 10281:
	    {
		TLSETL(2100853);
		Language_Compile_CompileError_DisplayMessage("Implementation restriction -- Too many nested types");
	    }
	    break;
	case 10282:
	    {
		TLSETL(2100856);
		Language_Compile_CompileError_DisplayMessage("Implementation restriction -- Too many union alternatives");
	    }
	    break;
	case 10283:
	    {
		TLSETL(2100859);
		Language_Compile_CompileError_DisplayMessage("Implementation restriction -- Too many nested values");
	    }
	    break;
	case 10284:
	    {
		TLSETL(2100862);
		Language_Compile_CompileError_DisplayMessage("Type cheat size expression must be integer");
	    }
	    break;
	case 10285:
	    {
		TLSETL(2100865);
		Language_Compile_CompileError_DisplayMessage("Type cheat expression with type cheat size must be integer or real");
	    }
	    break;
	case 10286:
	    {
		TLSETL(2100868);
		Language_Compile_CompileError_DisplayMessage("\\1 is a type and hence has no fields");
	    }
	    break;
	case 10287:
	    {
		TLSETL(2100871);
		Language_Compile_CompileError_DisplayMessage("Exported symbol \'\\1\' has not been declared");
	    }
	    break;
	case 10288:
	    {
		TLSETL(2100874);
		Language_Compile_CompileError_DisplayMessage("\'\\1\' has not been declared");
	    }
	    break;
	case 10289:
	    {
		TLSETL(2100877);
		Language_Compile_CompileError_DisplayMessage("\'\\1\' is not a defined external name");
	    }
	    break;
	case 10290:
	    {
		TLSETL(2100880);
		Language_Compile_CompileError_DisplayMessage("\\1 was not imported");
	    }
	    break;
	case 10291:
	    {
		TLSETL(2100883);
		Language_Compile_CompileError_DisplayMessage("Union alternative label is the wrong type");
	    }
	    break;
	case 10292:
	    {
		TLSETL(2100886);
		Language_Compile_CompileError_DisplayMessage("Union alternative label is out of range");
	    }
	    break;
	case 10293:
	    {
		TLSETL(2100889);
		Language_Compile_CompileError_DisplayMessage("Implementation restriction -- Union tag range too large");
	    }
	    break;
	case 10294:
	    {
		TLSETL(2100892);
		Language_Compile_CompileError_DisplayMessage("Cannot have unit as main program");
	    }
	    break;
	case 10295:
	    {
		TLSETL(2100895);
		Language_Compile_CompileError_DisplayMessage("\'\\1\' without matching \'\\2\'");
	    }
	    break;
	case 10296:
	    {
		TLSETL(2100898);
		Language_Compile_CompileError_DisplayMessage("Unqualified symbol \'\\1\' conflicts with symbol in enclosing scope");
	    }
	    break;
	case 10297:
	    {
		TLSETL(2100901);
		Language_Compile_CompileError_DisplayMessage("Forward collection \\1 has not been resolved");
	    }
	    break;
	case 10298:
	    {
		TLSETL(2100904);
		Language_Compile_CompileError_DisplayMessage("Type \\1 has not been resolved");
	    }
	    break;
	case 10299:
	    {
		TLSETL(2100907);
		Language_Compile_CompileError_DisplayMessage("Second argument to \'upper\' must be >= 1");
	    }
	    break;
	case 10300:
	    {
		TLSETL(2100910);
		Language_Compile_CompileError_DisplayMessage("Second argument to \'upper\' must be integer");
	    }
	    break;
	case 10301:
	    {
		TLSETL(2100913);
		Language_Compile_CompileError_DisplayMessage("Second argument to \'upper\' must be <= number of dimensions");
	    }
	    break;
	case 10302:
	    {
		TLSETL(2100916);
		Language_Compile_CompileError_DisplayMessage("\'var\' bind variable \\1 is bound to a variable which is read-only in this scope");
	    }
	    break;
	case 10303:
	    {
		TLSETL(2100919);
		Language_Compile_CompileError_DisplayMessage("\'var\' export from \\1 must be a variable");
	    }
	    break;
	case 10304:
	    {
		TLSETL(2100922);
		Language_Compile_CompileError_DisplayMessage("\'var\' import must be a variable, module, or monitor");
	    }
	    break;
	case 10305:
	    {
		TLSETL(2100925);
		Language_Compile_CompileError_DisplayMessage("Processes cannot have \'var\' parameters");
	    }
	    break;
	case 10306:
	    {
		TLSETL(2100930);
		Language_Compile_CompileError_DisplayMessage("Register variables may not be declared at module level");
	    }
	    break;
	case 10307:
	    {
		TLSETL(2100933);
		Language_Compile_CompileError_DisplayMessage("Preprocessor expression too complex");
	    }
	    break;
	case 10308:
	    {
		TLSETL(2100936);
		Language_Compile_CompileError_DisplayMessage("\'#\\1\' statement without corresponding \'#if\' statement");
	    }
	    break;
	case 10309:
	    {
		TLSETL(2100939);
		Language_Compile_CompileError_DisplayMessage("Program text on preprocessor directive line");
	    }
	    break;
	case 10310:
	    {
		TLSETL(2100942);
		Language_Compile_CompileError_DisplayMessage("Illegal preprocessor statement");
	    }
	    break;
	case 10311:
	    {
		TLSETL(2100945);
		Language_Compile_CompileError_DisplayMessage("Missing \'\\1\' in preprocessor statement");
	    }
	    break;
	case 10312:
	    {
		TLSETL(2100948);
		Language_Compile_CompileError_DisplayMessage("Too few \'#end if\' statements in file");
	    }
	    break;
	case 10313:
	    {
		TLSETL(2100951);
		Language_Compile_CompileError_DisplayMessage("\'#if\' statements nested too deep");
	    }
	    break;
	case 10314:
	    {
		TLSETL(2100956);
		Language_Compile_CompileError_DisplayMessage("\'#\\1\' statement after \'#else\' statement");
	    }
	    break;
	default :
	    {
		TLSETL(2100957);
		{
		    TLstring	__x2061;
		    TL_TLS_TLSVIS((TLint4) msgIndex, (TLint4) 1, (TLint4) 10, __x2061);
		    TLSTRASS(255, Language_Compile_CompileError_errorString1, __x2061);
		};
		TLSETL(100125);
		Language_Compile_CompileError_DisplayMessage("Unknown error message \\1");
	    }
	    break;
    };
    TLSETL(100128);
    Language_ErrorModule_Message(&((*srcPos)), (Language_ErrorModule_Severity) status, (* (TLstring *) Language_Compile_CompileError_message));
    TLRESTORELF();
}

void Language_Compile_CompileError_Initialize () {
    TLSTKCHKSLF(100132);
    TLSETF();
    TLSETL(100132);
    Language_Compile_CompileError_errorCount = 0;
    TLINCL();
    Language_Compile_CompileError_lastSrcPos.lineNo = 0;
    TLINCL();
    Language_Compile_CompileError_lastSrcPos.fileNo = 0;
    TLINCL();
    Language_Compile_CompileError_lastStatus = 3;
    TLRESTORELF();
}

void Language_Compile_CompileError () {
    TLSAVELF();
    TLSETF();
    TLRESTORELF();
}
