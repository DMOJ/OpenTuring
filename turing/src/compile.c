#include "cinterface"
static struct {
    TLint4	dummy;
    char	dummy2[1977];
} TLFTAB =
    { 34,
    {'/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', '.', 'b', 'd', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', '.', '.', '/', 'f', 'i', 'l', 'e', 'm', 'a', 'n', '/', 'f', 'i', 'l', 'e', 'm', 'a', 'n', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'd', 'u', 'm', 'm', 'y', '.', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'e', 'n', 'v', 'i', 'r', 'o', 'n', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'm', 's', 'g', 's', '.', 'd', 'e', 'f', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'd', 'e', 'b', 'u', 'g', '.', 'd', 'e', 'f', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '.', 'b', 'd', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'u', 'n', 'i', 't', 'm', 'a', 'n', '/', 'u', 'n', 'i', 't', 'm', 'a', 'n', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'e', 'r', 'r', 'o', 'r', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'p', 's', 'e', 'u', 'd', 'o', '.', 'd', 'e', 'f', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'o', 'p', 'c', 'o', 'd', 'e', '.', 'i', 'n', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'd', 'e', 'b', 'u', 'g', '.', 's', 't', '\0',
    '/', 'l', 'o', 'c', 'a', 'l', '/', 'i', 'n', 'c', 'l', 'u', 'd', 'e', '/', 't', 'p', 'l', 'u', 's', '/', 'D', 'O', 'S', '3', '2', '/', 'm', 'e', 'm', 'o', 'r', 'y', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'g', 'l', 'o', 'b', 'a', 'l', '.', 'i', 'n', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'c', 'o', 'm', 'p', 'e', 'r', 'r', '.', 'd', 'e', 'f', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'c', 'o', 'm', 'p', 'e', 'r', 'r', '.', 'd', 'f', '2', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'c', 'o', 'm', 'p', 'e', 'r', 'r', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'm', 'e', 'm', 'o', 'r', 'y', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 's', 'c', 'a', 'n', 'n', 'e', 'r', '/', 's', 'c', 'a', 'n', 'n', 'e', 'r', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'p', 'r', 'e', 's', 'c', 'a', 'n', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 's', 'c', 'o', 'p', 'e', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'v', 'a', 'l', 'u', 'e', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 't', 'y', 'p', 'e', 's', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 's', 'y', 'm', 'b', 'o', 'l', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'c', 'o', 'd', 'e', 'r', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'p', 'r', 'e', 'd', 'e', 'f', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'l', 'i', 's', 't', 's', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'e', 'x', 'p', 'n', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 't', 'y', 'p', 'e', 'd', 'e', 'c', 'l', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'u', 't', 'i', 'l', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'p', 'a', 'r', 's', 'e', 'r', '/', 'p', 'a', 'r', 's', 'e', 'r', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'd', 'e', 'b', 'u', 'g', 'g', 'e', 'r', '.', 'i', 'n', '\0'
    }};
typedef	TLnat2	FileManager_FileNoType;
typedef	TLnat4	FileManager_FileTimeStamp;
typedef	TLint2	FileManager_ResultCode;

extern void FileManager_OpenNamedHandle ();

extern void FileManager_OpenUnnamedHandle ();

extern void FileManager_OpenFileHandle ();

extern void FileManager_SetModified ();

extern void FileManager_WriteFile ();

extern void FileManager_WriteBackup ();

extern void FileManager_WriteTemp ();

extern void FileManager_RmTemp ();

extern void FileManager_CloseFileHandle ();

extern void FileManager_OpenNamedText ();

extern void FileManager_OpenFileText ();

extern void FileManager_CloseFileText ();

extern void FileManager_CloseAllText ();

extern void FileManager_ChangeDirectory ();

extern void FileManager_GetDirectory ();

extern void FileManager_ChangeExecDirectory ();

extern void FileManager_GetExecDirectory ();

extern void FileManager_ShortName ();

extern void FileManager_RelativeName ();

extern void FileManager_PathName ();

extern void FileManager_ExecPathName ();

extern void FileManager_ExtendName ();

extern void FileManager_FileName ();

extern TLboolean FileManager_IsUnnamed ();

extern TLboolean FileManager_IsOnDisk ();

extern TLboolean FileManager_IsSameFile ();

extern TLboolean FileManager_IsReadOK ();

extern TLboolean FileManager_IsWriteOK ();

extern TLboolean FileManager_IsOlder ();

extern TLboolean FileManager_FileExists ();

extern void FileManager_AddReference ();

extern void FileManager_DeleteReference ();

extern void FileManager_ReadTimeStamp ();

extern void FileManager_FlushUnreferencedFiles ();

extern void FileManager_CheckReferencedFiles ();

extern void FileManager_RmFile ();

extern void FileManager_SetDefaultInclude ();

extern void FileManager_AssertTextClosed ();

extern void FileManager_Dump ();

extern TLboolean AbortCheck ();

extern void FeedBack ();
struct	SrcPosition {
    TLnat2	lineNo;
    FileManager_FileNoType	fileNo;
    TLnat2	linePos;
    TLnat2	tokLen;
};
typedef	TLchar	__x2780[256];
struct	ErrMsgDef {
    struct ErrMsgDef	*next;
    struct SrcPosition	srcPos;
    __x2780	text;
};
typedef	TLint4	CookieKind;
struct	Cookie {
    CookieKind	kind;
    TLaddressint	item;
    TLaddressint	fp;
    TLaddressint	data;
};
struct	CallDef {
    struct CallDef	*next;
    TLstring	routineName;
    struct SrcPosition	srcPos;
    struct Cookie	cookie;
};
struct	ThreadDef {
    struct ThreadDef	*next;
    TLaddressint	threadId;
    TLaddressint	threadName;
    struct CallDef	*traceback;
};
struct	ThreadQueueDef {
    struct ThreadQueueDef	*next;
    TLaddressint	queueId;
    TLstring	queueName;
    struct ThreadDef	*threadList;
};
struct	DumpIndexDef {
    struct DumpIndexDef	*next;
    TLint4	lowerBound;
    TLint4	upperBound;
};
struct	DumpSymbolDef {
    struct DumpSymbolDef	*next;
    TLaddressint	symbolName;
    TLaddressint	typeName;
    struct SrcPosition	srcPos;
    TLstring	value;
    struct Cookie	cookie;
    TLboolean	isPredef;
};
struct	DumpScopeDef {
    struct DumpSymbolDef	symbolInfo;
    struct Cookie	expandCookie;
    struct DumpSymbolDef	*parameters;
    struct DumpSymbolDef	*declarations;
};

extern void Language_Debugging ();

extern void Language_Paragraph ();

extern void Language_Reset ();

extern void Language_SetMaxErrorCount ();
typedef	TLstring	__x2781[20];

extern void Language_EnterPreprocSymbols ();

extern void Language_CompileUnit ();

extern void Language_CompileProgram ();

extern void Language_WriteObjectFile ();
typedef	TLstring	__x2784[21];
typedef	TLstring	__x2788[21];

extern void Language_SetupExecution ();
typedef	TLint1	Language_Step;

extern void Language_SetStep ();
typedef	TLint1	Language_ReturnState;
struct	Language_RunStatus {
    Language_ReturnState	state;
    struct SrcPosition	srcPos;
    TLaddressint	threadId;
};

extern void Language_ExecuteProgram ();

extern void Language_EndExecution ();

extern void Language_StopExecution ();

extern void Language_DumpThreadList ();

extern void Language_DumpUnitList ();

extern void Language_DumpScopeInfo ();

extern void Language_DumpSymbolInfo ();

extern void Language_DumpArrayBounds ();

extern void Language_DumpArrayValues ();
extern TLboolean	Language_debug;
extern struct SrcPosition	Language_nullSrcPosition;
extern struct Cookie	Language_nullCookie;
extern struct DumpSymbolDef	Language_nullSymbolDef;
extern struct DumpScopeDef	Language_nullScopeDef;
typedef	TLint1	Language_UnitManager_UnitKind;
typedef	TLint1	Language_UnitManager_UnitStatus;

extern void Language_UnitManager_AddDepend ();

extern void Language_UnitManager_AddIncludeFile ();

extern void Language_UnitManager_AllocateCompileChunk ();

extern void * Language_UnitManager_BodyUnit ();

extern void Language_UnitManager_ClearAllMarks ();

extern void Language_UnitManager_ClearConfiguration ();

extern TLaddressint Language_UnitManager_CodeTable ();

extern FileManager_FileNoType Language_UnitManager_FileNo ();

extern void Language_UnitManager_FlushOldUnits ();

extern void Language_UnitManager_GetNextDepend ();

extern void Language_UnitManager_GetNextUnit ();

extern void Language_UnitManager_GetUnitPtr ();

extern TLaddressint Language_UnitManager_GlobalArea ();

extern TLint4 Language_UnitManager_GlobalSize ();

extern TLboolean Language_UnitManager_IsCompiled ();

extern TLboolean Language_UnitManager_IsMarked ();

extern TLboolean Language_UnitManager_IsPredef ();

extern Language_UnitManager_UnitKind Language_UnitManager_Kind ();

extern TLaddressint Language_UnitManager_ManifestTable ();

extern void * Language_UnitManager_OverrideBody ();

extern void Language_UnitManager_PrepareForCompile ();

extern void Language_UnitManager_PrepareForDepends ();

extern void Language_UnitManager_PrepareForScan ();

extern void Language_UnitManager_Reset ();

extern void Language_UnitManager_RewindDependList ();

extern void Language_UnitManager_RewindUnitList ();

extern void Language_UnitManager_SetCodeTable ();

extern void Language_UnitManager_SetDefaultBody ();

extern void Language_UnitManager_SetGlobalArea ();

extern void Language_UnitManager_SetKind ();

extern void Language_UnitManager_SetManifestTable ();

extern void Language_UnitManager_SetMark ();

extern void Language_UnitManager_SetOverrideBody ();

extern void Language_UnitManager_SetPredef ();

extern void Language_UnitManager_SetStub ();

extern void Language_UnitManager_SetSymbolTable ();

extern void Language_UnitManager_StartNewProgram ();

extern void * Language_UnitManager_StubUnit ();

extern void Language_UnitManager_SuccessfulCompile ();

extern TLaddressint Language_UnitManager_SymbolTable ();
typedef	TLint1	Language_ErrorModule_Severity;

extern void Language_ErrorModule_Initialize ();

extern void Language_ErrorModule_SetMaxErrors ();

extern void Language_ErrorModule_Message ();

extern void Language_ErrorModule_AbortIfErrors ();

extern void Language_ErrorModule_ReturnErrors ();
typedef	Language_ErrorModule_Severity	Language_ErrorSeverity;
typedef	TLstring	Language_StringDef;
typedef	TLnat4	Language_Offset;
extern TLint4	Language_codeOprSize;
extern TLint4	Language_codeInt1Size;
extern TLint4	Language_codeInt2Size;
extern TLint4	Language_codeIntSize;
extern TLint4	Language_codeRealSize;
extern TLint4	Language_codeAddrSize;
extern TLint4	Language_codeOffsetSize;
typedef	TLchar	Language_string1[2];
typedef	TLnat1	Language_set8;
typedef	TLnat2	Language_set16;
typedef	TLnat4	Language_set32;
typedef	TLint2	Language_Opcode;
typedef	TLchar	Language___x2792[22];
typedef	Language___x2792	Language___x2791[255];
extern Language___x2791	Language_OpcodeName;
struct	Language_CodeHeader {
    TLaddressint	bodyCode;
};
struct	Language___x2794 {
    TLint4	lower, range;
};
typedef	struct Language___x2794	Language___x2793[255];
struct	Language_ArrayDescriptor {
    TLnat4	sizeArray;
    TLnat4	sizeElement;
    TLnat4	elementCount;
    TLnat4	numDimensions;
    Language___x2793	dim;
};
struct	Language_ForDescriptor {
    TLint4	counter;
    TLint4	right;
    TLint4	step;
    TLaddressint	savedSP;
};
typedef	Language_Offset	Language___x2795[1001];
struct	Language_CaseDescriptor {
    TLint4	lower, upper;
    Language_Offset	otherwise;
    Language___x2795	caseVector;
};
struct	Language_PointerDescriptor {
    TLaddressint	dataPtr;
    TLint4	timestamp;
};
typedef	TLnat2	Language___x2796[301];
struct	Language_UnionMapDescriptor {
    TLint4	lower, upper;
    Language___x2796	map;
};
typedef	TLnat4	Language_ClassAttr;
struct	Language_ClassDescriptor {
    TLaddressint	baseClass;
    TLaddressint	expandClass;
    Language_ClassAttr	attributes;
    TLnat4	objSize;
    TLaddressint	classId;
    TLaddressint	initRoutine;
    TLnat4	numOperations;
};
typedef	TLint1	Language_OpenKind;
typedef	TLint1	Language_PutKind;
typedef	TLint1	Language_GetKind;
typedef	TLint1	Language_SetStreamKind;
typedef	TLnat1	Language_StreamModeSet;
typedef	TLint1	Language_SubstringKind;
typedef	TLint1	Language_RangeCheckKind;
typedef	TLint1	Language_ConditionKind;

extern void Language_DebugModule_Initialize ();

extern void Language_DebugModule_NewQueue ();

extern void Language_DebugModule_NewThread ();

extern void Language_DebugModule_NewCall ();

extern void Language_DebugModule_ReturnThreadDump ();

extern void Language_DebugModule_NewSymbolList ();

extern void Language_DebugModule_NewSymbol ();

extern void Language_DebugModule_ReturnSymbolDump ();

extern void Language_DebugModule_NewIndexList ();

extern void Language_DebugModule_NewIndex ();

extern void Language_DebugModule_ReturnIndexDump ();

void Language_Compile_Reset ();

void Language_Compile_Initialize ();
typedef	TLstring	__x2799[20];

void Language_Compile_EnterPreprocSymbols ();

extern void Language_Compile_ScanUnit ();

void Language_Compile_CompileUnit ();

void Language_Compile_InstallUnit ();

void Language_Compile_CallInfo ();

void Language_Compile_DumpUnitList ();

void Language_Compile_DumpScopeInfo ();

void Language_Compile_DumpSymbolInfo ();

void Language_Compile_DumpArrayBounds ();

void Language_Compile_DumpArrayValues ();

void Language_Compile_SetObjectFileStream ();

extern TLaddressint malloc ();

extern TLaddressint realloc ();

extern void free ();
typedef	TLnat1	Language_Compile_Tok;
typedef	TLchar	Language_Compile___x2804[16];
struct	Language_Compile___x2803 {
    Language_Compile___x2804	Name;
    TLnat2	Precedence;
};
typedef	struct Language_Compile___x2803	Language_Compile___x2802[159];
Language_Compile___x2802	Language_Compile_TokData = 
    {
	{"identifier", 0},
    
	{"char lit", 0},
    
	{"integer literal", 0},
    
	{"real literal", 0},
    
	{"string lit", 0},
    
	{"&", 6},
    
	{"->", 0},
    
	{"@", 0},
    
	{"^", 0},
    
	{":", 0},
    
	{":=", 0},
    
	{",", 0},
    
	{".", 0},
    
	{"..", 0},
    
	{"=", 10},
    
	{">=", 10},
    
	{">", 10},
    
	{"#", 0},
    
	{"=>", 2},
    
	{"<=", 10},
    
	{"(", 0},
    
	{"<", 10},
    
	{"-", 12},
    
	{"|", 4},
    
	{"+", 12},
    
	{")", 0},
    
	{";", 0},
    
	{"/", 14},
    
	{"*", 14},
    
	{"**", 18},
    
	{"~", 8},
    
	{"addressint", 0},
    
	{"all", 0},
    
	{"and", 6},
    
	{"array", 0},
    
	{"asm", 0},
    
	{"assert", 0},
    
	{"begin", 0},
    
	{"bind", 0},
    
	{"bits", 0},
    
	{"body", 0},
    
	{"boolean", 0},
    
	{"by", 0},
    
	{"case", 0},
    
	{"char", 0},
    
	{"cheat", 0},
    
	{"checked", 0},
    
	{"class", 0},
    
	{"close", 0},
    
	{"collection", 0},
    
	{"condition", 0},
    
	{"const", 0},
    
	{"decreasing", 0},
    
	{"def", 0},
    
	{"deferred", 0},
    
	{"div", 14},
    
	{"else", 0},
    
	{"elsif", 0},
    
	{"end", 0},
    
	{"enum", 0},
    
	{"exit", 0},
    
	{"export", 0},
    
	{"external", 0},
    
	{"false", 0},
    
	{"fcn", 0},
    
	{"flexible", 0},
    
	{"for", 0},
    
	{"fork", 0},
    
	{"forward", 0},
    
	{"free", 0},
    
	{"function", 0},
    
	{"get", 0},
    
	{"handler", 0},
    
	{"if", 0},
    
	{"implement", 0},
    
	{"import", 0},
    
	{"in", 10},
    
	{"include", 0},
    
	{"inherit", 0},
    
	{"init", 0},
    
	{"int", 0},
    
	{"int1", 0},
    
	{"int2", 0},
    
	{"int4", 0},
    
	{"invariant", 0},
    
	{"label", 0},
    
	{"loop", 0},
    
	{"mod", 14},
    
	{"module", 0},
    
	{"monitor", 0},
    
	{"nat", 0},
    
	{"nat1", 0},
    
	{"nat2", 0},
    
	{"nat4", 0},
    
	{"new", 0},
    
	{"not", 8},
    
	{"objectclass", 0},
    
	{"of", 0},
    
	{"opaque", 0},
    
	{"open", 0},
    
	{"or", 4},
    
	{"packed", 0},
    
	{"pause", 0},
    
	{"pervasive", 0},
    
	{"pointer", 0},
    
	{"post", 0},
    
	{"pre", 0},
    
	{"priority", 0},
    
	{"proc", 0},
    
	{"procedure", 0},
    
	{"process", 0},
    
	{"put", 0},
    
	{"quit", 0},
    
	{"read", 0},
    
	{"real", 0},
    
	{"real4", 0},
    
	{"real8", 0},
    
	{"record", 0},
    
	{"register", 0},
    
	{"rem", 14},
    
	{"result", 0},
    
	{"return", 0},
    
	{"seek", 0},
    
	{"self", 0},
    
	{"set", 0},
    
	{"shl", 14},
    
	{"shr", 14},
    
	{"signal", 0},
    
	{"skip", 0},
    
	{"string", 0},
    
	{"tag", 0},
    
	{"tell", 0},
    
	{"then", 0},
    
	{"timeout", 0},
    
	{"to", 0},
    
	{"true", 0},
    
	{"type", 0},
    
	{"unchecked", 0},
    
	{"union", 0},
    
	{"unqualified", 0},
    
	{"var", 0},
    
	{"wait", 0},
    
	{"when", 0},
    
	{"write", 0},
    
	{"xor", 12},
    
	{"elseif", 0},
    
	{"endfor", 0},
    
	{"endif", 0},
    
	{"endloop", 0},
    
	{"End of File", 0},
    
	{"ILLEGAL", 0},
    
	{"not =", 10},
    
	{"not in", 10},
    
	{"prefix #", 20},
    
	{"prefix -", 16},
    
	{"prefix +", 16},
    
	{"EOL", 0},
    
	{"PERCENT", 0},
    
	{"WHITESPACE", 0}};
typedef	TLint1	Language_Compile_PPTok;
typedef	TLchar	Language_Compile___x2806[8];
typedef	Language_Compile___x2806	Language_Compile___x2805[16];
Language_Compile___x2805	Language_Compile_PPTokName = 
    {"ident", "if", "then", "elsif", "elseif", "else", "end", "endif", "define", "undef",
    "macro", "unmacro", "and", "or", "not", "defined"};
typedef	TLint1	Language_Compile_TypeKind;
typedef	TLchar	Language_Compile___x2808[16];
typedef	Language_Compile___x2808	Language_Compile___x2807[33];
Language_Compile___x2807	Language_Compile_TypeKindName = 
    {"Error", "Addressint", "Array", "Boolean", "Char", "CharN", "CharStar", "Class", "Collection", "Condition",
    "CondDeferred", "CondPriority", "CondTimeout", "Enum", "Forward", "Function", "Int", "IntNat", "Module", "Nat",
    "Opaque", "Pointer", "Procedure", "Process", "Real", "Record", "Set", "String", "StringN", "StringStar",
    "Subrange", "Union", "VaryingParam"};
typedef	TLchar	Language_Compile___x2810[16];
typedef	Language_Compile___x2810	Language_Compile___x2809[33];
Language_Compile___x2809	Language_Compile_TypeKindKeyword = 
    {"???", "addressint", "array", "boolean", "char", "char", "char", "class", "collection", "condition",
    "condition", "condition", "condition", "enum", "forward", "function", "int", "int", "module", "nat",
    "opaque", "pointer", "procedure", "process", "real", "record", "set", "string", "string", "string",
    "subrange", "union", ".."};
typedef	TLint1	Language_Compile_TyModes;
typedef	TLchar	Language_Compile___x2812[12];
typedef	Language_Compile___x2812	Language_Compile___x2811[10];
Language_Compile___x2811	Language_Compile_TyModeName = 
    {"AutoSized", "Dummy", "Dynamic", "Flexible", "ForwardRef", "Packed", "StringStar", "TypeCheat", "Unchecked", "UninitCheck"};
typedef	TLnat2	Language_Compile_TyModesSet;
typedef	TLint2	Language_Compile_PredType;
typedef	Language_Compile_TypeKind	Language_Compile___x2813[27];
Language_Compile___x2813	Language_Compile_PredTypeKind = 
    {4, 3, 16, 18, 21, 22, 24, 27, 28, 1,
    5, 9, 10, 11, 12, 16, 16, 16, 17, 19,
    19, 19, 19, 24, 24, 32, 0};
typedef	Language_Compile_TyModesSet	Language_Compile___x2814[27];
Language_Compile___x2814	Language_Compile_PredTypeMode = 
    {0x0, 0x200, 0x200, 0x0, 0x200, 0x200, 0x200, 0x200, 0x200, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x200,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};
typedef	TLint2	Language_Compile_FormalType;
typedef	TLint2	Language_Compile_Predef;
typedef	TLchar	Language_Compile___x2817[20];
struct	Language_Compile___x2816 {
    Language_Compile___x2817	Name;
    Language_Compile_FormalType	FormalList;
    Language_Compile_PredType	ResultType;
};
typedef	struct Language_Compile___x2816	Language_Compile___x2815[25];
Language_Compile___x2815	Language_Compile_PredefData = 
    {
	{"not predefined", 0, 26},
    
	{"abs", 1, 2},
    
	{"addr", 1, 19},
    
	{"chr", 1, 0},
    
	{"empty", 1, 1},
    
	{"eof", 0, 1},
    
	{"getpriority", 0, 19},
    
	{"intstr", 1, 7},
    
	{"lower", 1, 2},
    
	{"max", 1, 2},
    
	{"min", 1, 2},
    
	{"natstr", 2, 7},
    
	{"nil", 0, 4},
    
	{"ord", 1, 2},
    
	{"pred", 1, 2},
    
	{"setpriority", 2, 5},
    
	{"sizeof", 2, 19},
    
	{"strint", 3, 2},
    
	{"strintok", 3, 1},
    
	{"strnat", 3, 19},
    
	{"strnatok", 3, 1},
    
	{"succ", 1, 2},
    
	{"upper", 1, 2},
    
	{"break", 0, 5},
    
	{"sysexit", 1, 5}};
typedef	TLchar	Language_Compile___x2818[256];
struct	Language_Compile_CharDef {
    TLint4	len;
    Language_Compile___x2818	val;
};
struct	Language_Compile_IdentDef {
    struct Language_Compile_IdentDef	*nextIdent;
    Language_Compile_Tok	tok;
    Language_Compile_PPTok	ppTok;
    Language_StringDef	str;
};
typedef	TLint1	Language_Compile_SymbolKind;
typedef	TLchar	Language_Compile___x2820[14];
typedef	Language_Compile___x2820	Language_Compile___x2819[10];
Language_Compile___x2819	Language_Compile_SymbolKindName = 
    {"Error", "Class", "Collection", "Constant", "Function", "Module", "Procedure", "ProcedureCall", "Type", "Variable"};
typedef	TLint1	Language_Compile_Access;
typedef	TLchar	Language_Compile___x2822[6];
typedef	Language_Compile___x2822	Language_Compile___x2821[3];
Language_Compile___x2821	Language_Compile_AccessName = 
    {"None", "Const", "Var"};
typedef	TLint1	Language_Compile_SyAttributes;
typedef	TLchar	Language_Compile___x2824[16];
typedef	Language_Compile___x2824	Language_Compile___x2823[20];
Language_Compile___x2823	Language_Compile_SyAttribName = 
    {"AutoImports", "Bind", "ClassSubprog", "Deferred", "Defined", "Dummy", "ExportAll", "Exported", "Forward", "HandlerRecord",
    "HasUnquals", "Implements", "Initialized", "Monitor", "MonitorEntry", "MonitorSubprog", "NeedParams", "Pervasive", "Register", "TypeCheat"};
typedef	TLnat4	Language_Compile_SyAttributeSet;
typedef	TLnat1	Language_Compile_ImportDepthType;
struct	Language_Compile_IndexDef {
    struct Language_Compile_IndexDef	*next;
    struct Language_Compile_TypeDef	*ty;
};
typedef	TLint1	Language_Compile_ExportKind;
typedef	TLchar	Language_Compile___x2826[16];
typedef	Language_Compile___x2826	Language_Compile___x2825[4];
Language_Compile___x2825	Language_Compile_ExportKindName = 
    {"opaque", "pervasive", "unqualified", "var"};
typedef	TLnat1	Language_Compile_ExportKindSet;
struct	Language_Compile_ExportDef {
    struct Language_Compile_ExportDef	*next;
    struct Language_Compile_IdentDef	*identPtr;
    struct Language_Compile_SymbolDef	*symbolPtr;
    struct Language_Compile_TypeDef	*opaqueTypePtr;
    Language_Compile_ExportKindSet	kind;
};
struct	Language_Compile_ImportDef {
    struct Language_Compile_ImportDef	*next;
    struct Language_Compile_SymbolDef	*sy;
    Language_Compile_Access	newAccess;
    Language_Compile_Access	oldAccess;
    Language_Compile_ImportDepthType	oldImportDepth;
    TLboolean	overridesExpand;
};
struct	Language_Compile_DynamicDef {
    struct Language_Compile_DynamicDef	*next;
    struct Language_Compile_SymbolDef	*sy;
};
typedef	TLint1	Language_Compile_BlockKind;
typedef	TLchar	Language_Compile___x2828[10];
typedef	Language_Compile___x2828	Language_Compile___x2827[16];
Language_Compile___x2827	Language_Compile_BlockKindName = 
    {"begin", "case", "label :", "label x:", "else", "for", "function", "handler", "if", "loop",
    "*MAIN*", "module", "monitor", "monitor:x", "procedure", "*ROOT*"};
struct	Language_Compile_BlockDef {
    struct Language_Compile_BlockDef	*parentBlock;
    struct Language_Compile_BlockDef	*siblingBlock;
    struct Language_Compile_BlockDef	*childBlock;
    struct Language_Compile_BlockDef	*expandBlock;
    struct Language_Compile_SymbolDef	*internalSymbols;
    struct Language_Compile_SymbolDef	*parentSymbols;
    struct Language_Compile_SymbolDef	*definingSymbol;
    Language_Offset	codeStartOffset;
    Language_Offset	codeEndOffset;
    struct Language_Compile_DynamicDef	*dynamics;
    Language_Compile_BlockKind	kind;
    TLboolean	reachable;
    TLboolean	resolvingNeeded;
};
typedef	TLint1	Language_Compile_Base;
typedef	TLchar	Language_Compile___x2830[12];
typedef	Language_Compile___x2830	Language_Compile___x2829[10];
Language_Compile___x2829	Language_Compile_BaseName = 
    {"none", "class", "code", "deferred", "external", "global", "initialized", "local", "parameter", "temporary"};
typedef	TLint1	Language_Compile_Indirection;
typedef	TLchar	Language_Compile___x2832[10];
typedef	Language_Compile___x2832	Language_Compile___x2831[3];
Language_Compile___x2831	Language_Compile_IndirName = 
    {"direct", "indirect", "double"};
struct	Language_Compile_Location {
    void	*unitPtr;
    Language_Compile_Base	base;
    Language_Compile_Indirection	indir;
    Language_Offset	offset;
};
static struct Language_Compile_Location	Language_Compile_dummyLocation;
struct Language_Compile_Location	Language_Compile_nullLocation;
struct	Language_Compile_DeferredLocDef {
    struct Language_Compile_DeferredLocDef	*next;
    struct Language_Compile_SymbolDef	*sy;
    struct Language_Compile_Location	loc;
};
struct	Language_Compile___x2833 {
    Language_Compile_SymbolKind	syTag;
    union {
	struct {
	    struct Language_Compile_SymbolDef	*mExpandSy;
	    struct Language_Compile_ImportDef	*mImportsOf;
	    struct Language_Compile_ExportDef	*mExportsOf;
	    Language_Compile_ExportKindSet	mExportAllKind;
	    struct Language_Compile_SymbolDef	*mMonitorVar;
	    struct Language_Compile_SymbolDef	*mClassTagSy;
	    TLint4	mDeferredNum;
	    struct Language_Compile_DeferredLocDef	*mDeferredLocs;
	} __u2;
	struct {
	    struct Language_Compile_ValueDef	*cValue;
	} __u3;
	struct {
	    struct Language_Compile_SymbolDef	*fFormalsOf;
	    struct Language_Compile_ImportDef	*fImportsOf;
	    struct Language_Compile_SymbolDef	*ResultsId;
	    struct Language_Compile_TypeDef	*ResultType;
	} __u4;
	struct {
	    struct Language_Compile_SymbolDef	*pFormalsOf;
	    struct Language_Compile_ImportDef	*pImportsOf;
	    struct Language_Compile_ValueDef	*pValue;
	} __u5;
	struct {
	    TLint4	unionNumber;
	} __u6;
    } __u1;
} ;
struct	Language_Compile_SymbolDef {
    struct Language_Compile_SymbolDef	*next;
    struct Language_Compile_IdentDef	*identPtr;
    struct Language_Compile_TypeDef	*tyPtr;
    Language_Compile_Access	access;
    Language_Compile_ImportDepthType	importDepth;
    Language_Compile_Predef	predefined;
    Language_Compile_SyAttributeSet	attributes;
    struct Language_Compile_SymbolDef	*definingSy;
    struct Language_Compile_BlockDef	*blockScope;
    struct Language_Compile_Location	loc;
    struct SrcPosition	srcPos;
    Language_Offset	definingOffset;
    struct Language_Compile___x2833	u;
};
struct	Language_Compile_IntListDef {
    struct Language_Compile_IntListDef	*next;
    TLint4	value;
};
struct	Language_Compile_UnionDef {
    struct Language_Compile_UnionDef	*next;
    struct Language_Compile_SymbolDef	*firstSym;
    TLint4	numSyms;
    struct Language_Compile_IntListDef	*values;
    TLint4	uloc;
};
struct	Language_Compile___x2834 {
    Language_Compile_TypeKind	tyTag;
    union {
	struct {
	    struct Language_Compile_IndexDef	*IndexOf;
	    struct Language_Compile_TypeDef	*aElementOf;
	    struct Language_Compile_Location	aDescriptor;
	} __u8;
	struct {
	    struct Language_Compile_SymbolDef	*cNameOf;
	    struct Language_Compile_TypeDef	*cPointerTy;
	    struct Language_Compile_TypeDef	*cUPointerTy;
	} __u9;
	struct {
	    struct Language_Compile_SymbolDef	*EnumIds;
	    struct Language_Compile_Location	eDescriptor;
	} __u10;
	struct {
	    struct Language_Compile_BlockDef	*blockLevel;
	} __u11;
	struct {
	    struct Language_Compile_SymbolDef	*sNameOf;
	} __u12;
	struct {
	    struct Language_Compile_SymbolDef	*oNameOf;
	    struct Language_Compile_TypeDef	*tyOf;
	} __u13;
	struct {
	    struct Language_Compile_SymbolDef	*pNameOf;
	    struct Language_Compile_TypeDef	*pElementOf;
	} __u14;
	struct {
	    struct Language_Compile_SymbolDef	*rFieldsOf;
	} __u15;
	struct {
	    struct Language_Compile_TypeDef	*BaseOf;
	    TLboolean	sIsScalar;
	} __u16;
	struct {
	    TLint4	stringSize;
	} __u17;
	struct {
	    struct Language_Compile_Location	sDescriptor;
	} __u18;
	struct {
	    TLint4	low;
	    TLint4	high;
	    struct Language_Compile_TypeDef	*Root;
	} __u19;
	struct {
	    struct Language_Compile_SymbolDef	*TagOf;
	    struct Language_Compile_SymbolDef	*uFieldsOf;
	    struct Language_Compile_UnionDef	*map;
	    struct Language_Compile_Location	mapLocation;
	    struct Language_Compile_Location	uninitMap;
	} __u20;
	struct {
	    struct Language_Compile_TypeDef	*tyPtr;
	} __u21;
    } __u7;
} ;
struct	Language_Compile_TypeDef {
    struct Language_Compile_SymbolDef	*typeName;
    Language_Compile_TyModesSet	mode;
    TLint1	alignment;
    struct Language_Compile_Location	uninitTableLoc;
    TLint4	tSize;
    struct Language_Compile___x2834	u;
};
typedef	TLint1	Language_Compile_ValueKind;
typedef	TLchar	Language_Compile___x2836[16];
typedef	Language_Compile___x2836	Language_Compile___x2835[9];
Language_Compile___x2835	Language_Compile_ValueKindName = 
    {"freeValue", "nonCompileTime", "boolean", "char", "charString", "int", "real", "set", "string"};
typedef	TLnat4	Language_Compile_ValueSetType;
struct	Language_Compile___x2837 {
    Language_Compile_ValueKind	valTag;
    union {
	struct {
	    struct Language_Compile_ValueDef	*next;
	} __u23;
	struct {
	    TLboolean	boolVal;
	} __u24;
	struct {
	    TLchar	charVal;
	} __u25;
	struct {
	    struct Language_Compile_CharDef	*cstrVal;
	} __u26;
	struct {
	    TLboolean	negative;
	    TLnat4	natVal;
	} __u27;
	struct {
	    TLreal8	realVal;
	} __u28;
	struct {
	    Language_Compile_ValueSetType	setVal;
	} __u29;
	struct {
	    Language_StringDef	*stringVal;
	} __u30;
    } __u22;
} ;
struct	Language_Compile_ValueDef {
    TLboolean	saved;
    struct Language_Compile___x2837	u;
};
struct	Language_Compile___x2838 {
    Language_Compile_Tok	tok;
    union {
	struct {
	    struct Language_Compile_CharDef	*cstrPtr;
	} __u32;
	struct {
	    TLnat4	natVal;
	} __u33;
	struct {
	    TLreal8	realVal;
	} __u34;
	struct {
	    Language_StringDef	*strPtr;
	} __u35;
    } __u31;
} ;
struct	Language_Compile_TokRecord {
    struct SrcPosition	srcPos;
    struct Language_Compile_IdentDef	*identPtr;
    struct Language_Compile___x2838	u;
};
struct Language_Compile_TokRecord	Language_Compile_newTok;
struct Language_Compile_TokRecord	Language_Compile_oldTok;

extern char *strcpy ();

void Language_Compile_CleanChar (c, __x1607)
TLchar	c;
TLstring	__x1607;
{
    TLSTKCHKSLF(100157);
    TLSETF();
    TLSETL(100157);
    switch (c) {
	case '\0':
	    {
		TLSETL(100159);
		{
		    TLSTRASS(255, __x1607, "\\0");
		    TLRESTORELF();
		    return;
		};
	    }
	    break;
	case '\t':
	    {
		TLSETL(100162);
		{
		    TLSTRASS(255, __x1607, "\\t");
		    TLRESTORELF();
		    return;
		};
	    }
	    break;
	case '\n':
	    {
		TLSETL(100165);
		{
		    TLSTRASS(255, __x1607, "\\n");
		    TLRESTORELF();
		    return;
		};
	    }
	    break;
	case '\f':
	    {
		TLSETL(100168);
		{
		    TLSTRASS(255, __x1607, "\\f");
		    TLRESTORELF();
		    return;
		};
	    }
	    break;
	case '\033':
	    {
		TLSETL(100171);
		{
		    TLSTRASS(255, __x1607, "\\e");
		    TLRESTORELF();
		    return;
		};
	    }
	    break;
	case '\b':
	    {
		TLSETL(100174);
		{
		    TLSTRASS(255, __x1607, "\\b");
		    TLRESTORELF();
		    return;
		};
	    }
	    break;
	case '\177':
	    {
		TLSETL(100177);
		{
		    TLSTRASS(255, __x1607, "\\d");
		    TLRESTORELF();
		    return;
		};
	    }
	    break;
	case '\r':
	    {
		TLSETL(100180);
		{
		    TLSTRASS(255, __x1607, "\\r");
		    TLRESTORELF();
		    return;
		};
	    }
	    break;
	case '\\':
	    {
		TLSETL(100183);
		{
		    TLSTRASS(255, __x1607, "\\\\");
		    TLRESTORELF();
		    return;
		};
	    }
	    break;
	case '\'':
	    {
		TLSETL(100186);
		{
		    TLSTRASS(255, __x1607, "\\\'");
		    TLRESTORELF();
		    return;
		};
	    }
	    break;
	default :
	    {
		TLSETL(100189);
		if (((TLnat4) c) < 32) {
		    TLSETL(100190);
		    {
			{
			    TLstring	__x2840;
			    {
				TLchar	__x2841[2];
				TLCHRTOSTR(((TLchar) (((TLnat4) c) + 64)), __x2841);
				TL_TLS_TLSCAT("^", __x2841, __x2840);
			    };
			    TLSTRASS(255, __x1607, __x2840);
			};
			TLRESTORELF();
			return;
		    };
		} else {
		    TLSETL(100191);
		    if (((TLnat4) c) > 127) {
			TLSETL(100192);
			{
			    {
				TLstring	__x2843;
				Language_Compile_CleanChar((TLchar) ((TLchar) (((TLnat4) c) - 128)), __x2843);
				{
				    TLstring	__x2842;
				    TL_TLS_TLSCAT("M-", __x2843, __x2842);
				    TLSTRASS(255, __x1607, __x2842);
				};
			    };
			    TLRESTORELF();
			    return;
			};
		    } else {
			TLSETL(100194);
			{
			    {
				TLchar	__x2844[2];
				TLCHRTOSTR(c, __x2844);
				TLSTRASS(255, __x1607, __x2844);
			    };
			    TLRESTORELF();
			    return;
			};
		    };
		};
	    }
	    break;
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

void Language_Compile_CleanCString (c, __x1609)
struct Language_Compile_CharDef	*c;
TLstring	__x1609;
{
    TLBINDREG((*cstr), struct Language_Compile_CharDef);
    TLstring	res;
    TLSTKCHKSLF(100201);
    TLSETF();
    TLSETL(100201);
    cstr = &((*(c)));
    TLSETL(100203);
    TLSTRASS(255, res, "");
    TLINCL();
    {
	register TLint4	i;
	TLint4	__x2846;
	__x2846 = (*cstr).len;
	i = 1;
	if (i <= __x2846) {
	    for(;;) {
		TLSETL(100205);
		{
		    TLstring	__x2847;
		    Language_Compile_CleanChar((TLchar) ((*cstr).val[(i - 1)]), __x2847);
		    TLSTRCATASS(res, __x2847, 255);
		};
		TLINCL();
		if (TL_TLS_TLSLEN(res) > 50) {
		    TLSETL(100207);
		    TLSTRCATASS(res, "...", 255);
		    TLSETL(100209);
		    break;
		};
		if (i == __x2846) break;
		i++;
	    }
	};
    };
    TLSETL(100211);
    {
	TLSTRASS(255, __x1609, res);
	TLRESTORELF();
	return;
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

void Language_Compile_IdentToName (id, __x1614)
struct Language_Compile_IdentDef	*id;
TLstring	__x1614;
{
    TLSTKCHKSLF(100216);
    TLSETF();
    TLSETL(100216);
    if (id == ((struct Language_Compile_IdentDef *) 0)) {
	TLSETL(100217);
	{
	    TLSTRASS(255, __x1614, "<ident>");
	    TLRESTORELF();
	    return;
	};
    };
    TLSETL(100219);
    {
	TLSTRASS(255, __x1614, id->str);
	TLRESTORELF();
	return;
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

void Language_Compile_TokenToName (tok, __x1616)
struct Language_Compile_TokRecord	*tok;
TLstring	__x1616;
{
    TLSTKCHKSLF(100224);
    TLSETF();
    TLSETL(100224);
    switch ((*tok).u.tok) {
	case 0:
	    {
		TLSETL(100226);
		{
		    {
			TLstring	__x2850;
			Language_Compile_IdentToName((*tok).identPtr, __x2850);
			TLSTRASS(255, __x1616, __x2850);
		    };
		    TLRESTORELF();
		    return;
		};
	    }
	    break;
	case 1:
	    {
		TLSETL(100229);
		{
		    {
			TLstring	__x2853;
			Language_Compile_CleanCString((*tok).u.__u31.__u32.cstrPtr, __x2853);
			{
			    TLstring	__x2852;
			    TL_TLS_TLSCAT("\'", __x2853, __x2852);
			    {
				TLstring	__x2851;
				TL_TLS_TLSCAT(__x2852, "\'", __x2851);
				TLSTRASS(255, __x1616, __x2851);
			    };
			};
		    };
		    TLRESTORELF();
		    return;
		};
	    }
	    break;
	case 4:
	    {
		TLSETL(100232);
		{
		    {
			TLstring	__x2855;
			TL_TLS_TLSCAT("\"", (*((*tok).u.__u31.__u35.strPtr)), __x2855);
			{
			    TLstring	__x2854;
			    TL_TLS_TLSCAT(__x2855, "\"", __x2854);
			    TLSTRASS(255, __x1616, __x2854);
			};
		    };
		    TLRESTORELF();
		    return;
		};
	    }
	    break;
	default :
	    {
		TLSETL(100235);
		{
		    TLSTRASS(255, __x1616, Language_Compile_TokData[TLINRANGELOW((*tok).u.tok, 0, 158, 1)].Name);
		    TLRESTORELF();
		    return;
		};
	    }
	    break;
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

void Language_Compile_SymbolToName (sy, __x1618)
struct Language_Compile_SymbolDef	*sy;
TLstring	__x1618;
{
    TLSTKCHKSLF(100240);
    TLSETF();
    TLSETL(100240);
    if ((sy == ((struct Language_Compile_SymbolDef *) 0)) || ((sy->identPtr) == ((struct Language_Compile_IdentDef *) 0))) {
	TLSETL(100241);
	{
	    TLSTRASS(255, __x1618, "expression");
	    TLRESTORELF();
	    return;
	};
    };
    TLSETL(100243);
    {
	{
	    TLstring	__x2858;
	    TL_TLS_TLSCAT("\'", sy->identPtr->str, __x2858);
	    {
		TLstring	__x2857;
		TL_TLS_TLSCAT(__x2858, "\'", __x2857);
		TLSTRASS(255, __x1618, __x2857);
	    };
	};
	TLRESTORELF();
	return;
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}
void	*Language_Compile_compilingUnit;
void	*Language_Compile_predefUnit;

extern void Language_Compile_CompileError_Add ();

extern void Language_Compile_CompileError_Initialize ();

extern TLnat4 Language_Compile_CompileError_Count ();

extern void Language_Compile_Memory_Initialize ();

extern void Language_Compile_Memory_Allocate ();

extern void Language_Compile_Memory_Trim ();
typedef	struct Language_Compile_IdentDef	*Language_Compile___x2859[118];
Language_Compile___x2859	Language_Compile_keywordIdent;
struct	Language_Compile___x2860 {
    struct Language_Compile_IdentDef	*anyclass;
    struct Language_Compile_IdentDef	*main;
    struct Language_Compile_IdentDef	*unit;
};
struct Language_Compile___x2860	Language_Compile_specialIdent;

extern void Language_Compile_Scanner_Reset ();

extern void Language_Compile_Scanner_EnterTok ();

extern void Language_Compile_Scanner_Initialize ();

extern void Language_Compile_Scanner_Scan ();

extern void Language_Compile_Scanner_GetFileUnit ();
typedef	TLstring	__x2861[20];

extern void Language_Compile_Scanner_EnterPreprocSymbols ();

void Language_Compile_EnterPreprocSymbols (defs, numDefs)
__x2799	defs;
TLint4	numDefs;
{
    TLSTKCHKSLF(100272);
    TLSETF();
    TLSETL(100272);
    Language_Compile_Scanner_EnterPreprocSymbols(defs, (TLint4) numDefs);
    TLRESTORELF();
}

void Language_Compile_DemandToken (tok)
Language_Compile_Tok	tok;
{
    TLSTKCHKSLF(100278);
    TLSETF();
    TLSETL(100278);
    if ((Language_Compile_newTok.u.tok) == tok) {
	TLSETL(100280);
	Language_Compile_Scanner_Scan();
    } else {
	TLSETL(100284);
	{
	    TLstring	__x2864;
	    Language_Compile_TokenToName(&(Language_Compile_newTok), __x2864);
	    Language_Compile_CompileError_Add((TLint2) 10263, &(Language_Compile_newTok.srcPos), __x2864, Language_Compile_TokData[TLINRANGELOW(tok, 0, 158, 1)].Name, (Language_ErrorSeverity) 3);
	};
    };
    TLRESTORELF();
}

void Language_Compile_ExpectToken (tok)
Language_Compile_Tok	tok;
{
    TLSTKCHKSLF(100289);
    TLSETF();
    TLSETL(100289);
    if ((Language_Compile_newTok.u.tok) == tok) {
	TLSETL(100291);
	Language_Compile_Scanner_Scan();
    } else {
	TLSETL(100295);
	{
	    TLstring	__x2865;
	    Language_Compile_TokenToName(&(Language_Compile_newTok), __x2865);
	    Language_Compile_CompileError_Add((TLint2) 10263, &(Language_Compile_newTok.srcPos), __x2865, Language_Compile_TokData[TLINRANGELOW(tok, 0, 158, 1)].Name, (Language_ErrorSeverity) 2);
	};
	Language_Compile_oldTok.u.tok = tok;
	TLINCL();
	Language_Compile_oldTok.identPtr = (struct Language_Compile_IdentDef *) 0;
    };
    TLRESTORELF();
}

void Language_Compile_ExpectEnd (tok, id)
Language_Compile_Tok	tok;
struct Language_Compile_IdentDef	*id;
{
    TLSTKCHKSLF(100302);
    TLSETF();
    TLSETL(100302);
    if ((Language_Compile_newTok.u.tok) == tok) {
	TLSETL(100304);
	Language_Compile_Scanner_Scan();
	if (((tok == 0) && ((Language_Compile_oldTok.identPtr) != id)) && (id != ((struct Language_Compile_IdentDef *) 0))) {
	    TLSETL(100309);
	    {
		TLstring	__x2867;
		Language_Compile_IdentToName(id, __x2867);
		{
		    TLstring	__x2866;
		    Language_Compile_TokenToName(&(Language_Compile_oldTok), __x2866);
		    Language_Compile_CompileError_Add((TLint2) 10173, &(Language_Compile_oldTok.srcPos), __x2866, __x2867, (Language_ErrorSeverity) 1);
		};
	    };
	};
    } else {
	TLSETL(100311);
	if (tok == 0) {
	    TLSETL(100312);
	    if (id != ((struct Language_Compile_IdentDef *) 0)) {
		TLSETL(100316);
		{
		    TLstring	__x2868;
		    Language_Compile_TokenToName(&(Language_Compile_newTok), __x2868);
		    Language_Compile_CompileError_Add((TLint2) 10264, &(Language_Compile_newTok.srcPos), __x2868, id->str, (Language_ErrorSeverity) 2);
		};
	    };
	} else {
	    TLSETL(100321);
	    {
		TLstring	__x2869;
		Language_Compile_TokenToName(&(Language_Compile_newTok), __x2869);
		Language_Compile_CompileError_Add((TLint2) 10264, &(Language_Compile_newTok.srcPos), __x2869, Language_Compile_TokData[TLINRANGELOW(tok, 0, 158, 1)].Name, (Language_ErrorSeverity) 2);
	    };
	};
	TLSETL(100322);
	if (((Language_Compile_newTok.srcPos.lineNo) == (Language_Compile_oldTok.srcPos.lineNo)) && ((Language_Compile_newTok.srcPos.fileNo) == (Language_Compile_oldTok.srcPos.fileNo))) {
	    TLSETL(100325);
	    Language_Compile_Scanner_Scan();
	};
    };
    TLRESTORELF();
}

void Language_Compile_EqWantColonEq () {
    TLSTKCHKSLF(100331);
    TLSETF();
    TLSETL(100331);
    TLASSERT ((Language_Compile_newTok.u.tok) == 14);
    TLSETL(100334);
    Language_Compile_CompileError_Add((TLint2) 10013, &(Language_Compile_newTok.srcPos), Language_Compile_TokData[14].Name, Language_Compile_TokData[10].Name, (Language_ErrorSeverity) 1);
    Language_Compile_newTok.u.tok = 10;
    TLRESTORELF();
}

void Language_Compile_GetUnitFile (unitPtr)
void	**unitPtr;
{
    TLstring	fileName;
    TLSTKCHKSLF(100340);
    TLSETF();
    TLSETL(100340);
    if ((Language_Compile_newTok.u.tok) == 4) {
	TLSETL(100342);
	Language_Compile_Scanner_Scan();
	TLSTRASS(255, fileName, (*(Language_Compile_oldTok.u.__u31.__u35.strPtr)));
    } else {
	TLSETL(100345);
	Language_Compile_DemandToken((Language_Compile_Tok) 0);
	if ((Language_Compile_newTok.u.tok) == 76) {
	    TLSETL(100347);
	    Language_Compile_Scanner_Scan();
	    TLINCL();
	    Language_Compile_DemandToken((Language_Compile_Tok) 4);
	    TLSTRASS(255, fileName, (*(Language_Compile_oldTok.u.__u31.__u35.strPtr)));
	} else {
	    TLSETL(100350);
	    TLSTRASS(255, fileName, Language_Compile_oldTok.identPtr->str);
	};
	TLSETL(100354);
	if (((strcmp(fileName, "%oot/lib/GUI") == 0) || (strcmp(fileName, "%oot\\lib\\GUI") == 0)) || (strcmp(fileName, "GUI") == 0)) {
	    TLSETL(100356);
	    TLSTRASS(255, fileName, "%oot/support/lib/GUI");
	};
    };
    TLSETL(100360);
    Language_Compile_Scanner_GetFileUnit(fileName, &((*unitPtr)));
    TLRESTORELF();
}

void Language_Compile_InitializeScan (suppressScanWarnings)
TLboolean	suppressScanWarnings;
{
    TLSTKCHKSLF(100365);
    TLSETF();
    TLSETL(100365);
    Language_Compile_CompileError_Initialize();
    TLINCL();
    Language_Compile_Memory_Initialize();
    TLSETL(100369);
    Language_Compile_Scanner_Initialize((TLboolean) suppressScanWarnings);
    if ((Language_Compile_newTok.u.tok) != 149) {
	TLSETL(100371);
	Language_Compile_Scanner_Scan();
    };
    TLRESTORELF();
}

extern void Language_Compile_ScanUnit ();

extern void Language_Compile_PreScan_VerifyConfiguration ();

extern void Language_Compile_PreScan_VerifyPredefList ();
struct Language_Compile_BlockDef	*Language_Compile_rootBlock;
struct Language_Compile_BlockDef	*Language_Compile_blockStack;
struct Language_Compile_SymbolDef	*Language_Compile_compilingSymbol;
struct Language_Compile_SymbolDef	*Language_Compile_monitorSymbol;
struct Language_Compile_SymbolDef	*Language_Compile_classSymbol;
struct Language_Compile_SymbolDef	*Language_Compile_subprogramSymbol;
Language_Compile_ImportDepthType	Language_Compile_currentImportDepth;
struct Language_Compile_ValueDef	*Language_Compile_nonCompileTimeValue;
struct Language_Compile_ValueDef	*Language_Compile_intValueOne;
typedef	struct Language_Compile_TypeDef	*Language_Compile___x2870[27];
Language_Compile___x2870	Language_Compile_predType;
TLint4	Language_Compile_debugFile;
void 	(*Language_Compile_DumpAll)();
void 	(*Language_Compile_procDumpSym)();
void 	(*Language_Compile_procDumpSymList)();
void 	(*Language_Compile_procTargetType)();

void Language_Compile_OutputIndent (file, indent)
TLint4	file;
TLnat4	indent;
{
    TLSTKCHKSLF(100450);
    TLSETF();
    TLSETL(100450);
    if (indent != 0) {
	TLSETL(100451);
	{
	    TLstring	__x2872;
	    TL_TLS_TLSRPT(" ", (TLint4) (indent % 8), __x2872);
	    {
		TLstring	__x2871;
		TL_TLS_TLSRPT("\t", (TLint4) (indent / 8), __x2871);
		TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
		TL_TLI_TLIPS ((TLint4) 0, __x2871, (TLint2) file);
		TL_TLI_TLIPS ((TLint4) 0, __x2872, (TLint2) file);
	    };
	};
    };
    TLRESTORELF();
}

extern TLboolean Language_Compile_Scope_AncestorOf ();

extern TLboolean Language_Compile_Scope_AtTopLevel ();

extern TLboolean Language_Compile_Scope_ExpandScopeOk ();

extern struct Language_Compile_ExportDef * Language_Compile_Scope_IdentInExportList ();

extern struct Language_Compile_SymbolDef * Language_Compile_Scope_IdentInImmediateScope ();

extern struct Language_Compile_SymbolDef * Language_Compile_Scope_IdentInImportList ();

extern struct Language_Compile_SymbolDef * Language_Compile_Scope_IdentInList ();

extern struct Language_Compile_SymbolDef * Language_Compile_Scope_IdentInScope ();

extern TLboolean Language_Compile_Scope_InBlock ();

extern void Language_Compile_Scope_DumpBlocks ();

extern struct Language_Compile_CharDef * Language_Compile_Value_CharValue ();

extern void Language_Compile_Value_Chr ();

extern void Language_Compile_Value_ConvertToChar ();

extern void Language_Compile_Value_ConvertToCharString ();

extern void Language_Compile_Value_ConvertToReal ();

extern void Language_Compile_Value_ConvertToString ();

extern void Language_Compile_Value_EnterSetValue ();

extern void Language_Compile_Value_Initialize ();

extern TLint4 Language_Compile_Value_IntValue ();

extern Language_Compile_ValueKind Language_Compile_Value_Kind ();

extern void Language_Compile_Value_NonCompileTimeOperation ();

extern void Language_Compile_Value_Ord ();

extern void Language_Compile_Value_PerformOperation ();

extern void Language_Compile_Value_PerformUnaryOperation ();

extern void Language_Compile_Value_Pop ();

extern void Language_Compile_Value_Push ();

extern void Language_Compile_Value_PushCopy ();

extern void Language_Compile_Value_PushInt ();

extern void Language_Compile_Value_PushSet ();

extern void Language_Compile_Value_PushToken ();

extern TLreal8 Language_Compile_Value_RealValue ();

extern void Language_Compile_Value_ReplaceLowHighWithEmptySet ();

extern void Language_Compile_Value_ReplaceLowHighWithSetAll ();

extern void Language_Compile_Value_ReplaceNonCompileTime ();

extern void Language_Compile_Value_Save ();

extern struct Language_Compile_ValueDef * Language_Compile_Value_Second ();

extern Language_StringDef * Language_Compile_Value_StringValue ();

extern void Language_Compile_Value_Swap ();

extern struct Language_Compile_ValueDef * Language_Compile_Value_Top ();

extern Language_Compile_ValueKind Language_Compile_Value_ValKind ();

extern struct Language_Compile_TypeDef * Language_Compile_Value_ValueType ();

extern void Language_Compile_Value_AssertStackEmpty ();

extern void Language_Compile_Value_DumpValue ();

extern void Language_Compile_Value_DumpValueStack ();

extern TLint4 Language_Compile_Types_Alignment ();

extern TLboolean Language_Compile_Types_Assignable ();

extern void Language_Compile_Types_ClearMode ();

extern void Language_Compile_Types_EnterAlignment ();

extern void Language_Compile_Types_EnterDescriptorLocation ();

extern void Language_Compile_Types_EnterElementType ();

extern void Language_Compile_Types_EnterIndices ();

extern void Language_Compile_Types_EnterMode ();

extern void Language_Compile_Types_EnterPointerType ();

extern void Language_Compile_Types_EnterPointerUncheckedType ();

extern void Language_Compile_Types_EnterSetBase ();

extern void Language_Compile_Types_EnterSize ();

extern void Language_Compile_Types_EnterStorageSize ();

extern void Language_Compile_Types_EnterTypeName ();

extern void Language_Compile_Types_EnterUnionInfo ();

extern void Language_Compile_Types_EnterUnionTag ();

extern struct Language_Compile_SymbolDef * Language_Compile_Types_EnumIds ();

extern TLboolean Language_Compile_Types_EquivVarType ();

extern struct Language_Compile_SymbolDef * Language_Compile_Types_FieldsOf ();

extern TLboolean Language_Compile_Types_HasMode ();

extern TLint4 Language_Compile_Types_High ();

extern struct Language_Compile_IndexDef * Language_Compile_Types_IndexOf ();

extern void Language_Compile_Types_Initialize ();

extern TLboolean Language_Compile_Types_IsCondition ();

extern TLboolean Language_Compile_Types_IsDynamicType ();

extern TLboolean Language_Compile_Types_IsIntType ();

extern TLboolean Language_Compile_Types_IsNumeric ();

extern TLboolean Language_Compile_Types_IsScalar ();

extern Language_Compile_TypeKind Language_Compile_Types_Kind ();

extern void Language_Compile_Types_LinkIdentListToType ();

extern TLint4 Language_Compile_Types_Low ();

extern void Language_Compile_Types_MakeTypeOpaque ();

extern struct Language_Compile_SymbolDef * Language_Compile_Types_NameOf ();

extern Language_Compile_TypeKind Language_Compile_Types_NumericKind ();

extern void Language_Compile_Types_NumericType ();

extern void Language_Compile_Types_Pack ();

extern void Language_Compile_Types_Pop ();

extern void Language_Compile_Types_PushBaseOf ();

extern void Language_Compile_Types_PushElementType ();

extern void Language_Compile_Types_PushNew ();

extern void Language_Compile_Types_PushTagType ();

extern void Language_Compile_Types_PushType ();

extern void Language_Compile_Types_ReplaceCopy ();

extern void Language_Compile_Types_ReplaceElementType ();

extern void Language_Compile_Types_ReplacePointerType ();

extern void Language_Compile_Types_ReplaceRootType ();

extern void Language_Compile_Types_ReplaceSecondRootType ();

extern void Language_Compile_Types_ReplaceType ();

extern void Language_Compile_Types_ResetPredefines ();

extern void Language_Compile_Types_ResolveForward ();

extern struct Language_Compile_TypeDef * Language_Compile_Types_RootType ();

extern Language_Compile_TypeKind Language_Compile_Types_RootTypeKind ();

extern TLboolean Language_Compile_Types_Same ();

extern TLboolean Language_Compile_Types_SameType ();

extern struct Language_Compile_TypeDef * Language_Compile_Types_Second ();

extern Language_Compile_TypeKind Language_Compile_Types_SecondKind ();

extern TLint4 Language_Compile_Types_StrSize ();

extern TLboolean Language_Compile_Types_StringComparisonTypes ();

extern TLboolean Language_Compile_Types_StringTypes ();

extern void Language_Compile_Types_Swap ();

extern struct Language_Compile_SymbolDef * Language_Compile_Types_Tag ();

extern struct Language_Compile_TypeDef * Language_Compile_Types_Third ();

extern struct Language_Compile_TypeDef * Language_Compile_Types_Top ();

extern TLint4 Language_Compile_Types_TypeSize ();

extern struct Language_Compile_UnionDef * Language_Compile_Types_UnionMap ();

extern void Language_Compile_Types_UnmakeTypeOpaque ();

extern struct Language_Compile_TypeDef * Language_Compile_Types_UnOpaqueType ();

extern TLboolean Language_Compile_Types_UnresolvedCollection ();

extern void Language_Compile_Types_AssertStackEmpty ();

extern void Language_Compile_Types_DumpType ();

extern void Language_Compile_Types_DumpTypeStack ();
typedef	TLint2	Language_Compile_Symbol_NewSymKinds;

extern void Language_Compile_Symbol_AddDeferredLocation ();

extern void Language_Compile_Symbol_AddExport ();

extern void Language_Compile_Symbol_AddImport ();

extern struct Language_Compile_BlockDef * Language_Compile_Symbol_BlockScope ();

extern struct Language_Compile_SymbolDef * Language_Compile_Symbol_ClassTagSy ();

extern void Language_Compile_Symbol_ClearAttribute ();

extern void Language_Compile_Symbol_ClearSubprogramImports ();

extern void Language_Compile_Symbol_EnterAttribute ();

extern void Language_Compile_Symbol_EnterBlockScope ();

extern void Language_Compile_Symbol_EnterClassTag ();

extern void Language_Compile_Symbol_EnterExpand ();

extern void Language_Compile_Symbol_EnterFormals ();

extern void Language_Compile_Symbol_EnterInterruptProcedureValue ();

extern void Language_Compile_Symbol_EnterKind ();

extern void Language_Compile_Symbol_EnterLocation ();

extern void Language_Compile_Symbol_EnterMonitorVar ();

extern void Language_Compile_Symbol_EnterResultType ();

extern void Language_Compile_Symbol_EnterResultsId ();

extern void Language_Compile_Symbol_EnterType ();

extern void Language_Compile_Symbol_EnterValue ();

extern struct Language_Compile_SymbolDef * Language_Compile_Symbol_ExpandSy ();

extern struct Language_Compile_ExportDef * Language_Compile_Symbol_ExportedIdent ();

extern struct Language_Compile_ExportDef * Language_Compile_Symbol_ExportsOf ();

extern void Language_Compile_Symbol_FixImportedSymbols ();

extern struct Language_Compile_SymbolDef * Language_Compile_Symbol_FormalsOf ();

extern TLboolean Language_Compile_Symbol_HasAttribute ();

extern struct Language_Compile_ImportDef * Language_Compile_Symbol_ImportsOf ();

extern void Language_Compile_Symbol_Initialize ();

extern TLboolean Language_Compile_Symbol_IsDoubleIndirect ();

extern Language_Compile_SymbolKind Language_Compile_Symbol_Kind ();

extern struct Language_Compile_SymbolDef * Language_Compile_Symbol_MonitorVar ();

extern struct Language_Compile_SymbolDef * Language_Compile_Symbol_Nth ();

extern Language_Compile_Predef Language_Compile_Symbol_Predefined ();

extern void Language_Compile_Symbol_Pop ();

extern void Language_Compile_Symbol_PushDummy ();

extern void Language_Compile_Symbol_PushIdent ();

extern void Language_Compile_Symbol_PushLimitedNew ();

extern void Language_Compile_Symbol_PushNamedNew ();

extern void Language_Compile_Symbol_PushNew ();

extern void Language_Compile_Symbol_PushPointerTarget ();

extern void Language_Compile_Symbol_PushSymbol ();

extern void Language_Compile_Symbol_ReplaceDummy ();

extern void Language_Compile_Symbol_ResetSymbolList ();

extern void Language_Compile_Symbol_ResolveExport ();

extern struct Language_Compile_TypeDef * Language_Compile_Symbol_ResultType ();

extern struct Language_Compile_SymbolDef * Language_Compile_Symbol_ResultsId ();

extern struct Language_Compile_SymbolDef * Language_Compile_Symbol_Second ();

extern Language_Compile_SymbolKind Language_Compile_Symbol_SecondKind ();

extern struct Language_Compile_TypeDef * Language_Compile_Symbol_SecondType ();

extern void Language_Compile_Symbol_SetExportAll ();

extern void Language_Compile_Symbol_SetPervasive ();

extern TLboolean Language_Compile_Symbol_SubprogramVariable ();

extern Language_Compile_Access Language_Compile_Symbol_SyAccess ();

extern struct Language_Compile_ValueDef * Language_Compile_Symbol_SyValue ();

extern struct Language_Compile_SymbolDef * Language_Compile_Symbol_Top ();

extern struct Language_Compile_TypeDef * Language_Compile_Symbol_Type ();

extern void Language_Compile_Symbol_AssertStackEmpty ();

extern void Language_Compile_Symbol_DumpSymbol ();

extern void Language_Compile_Symbol_DumpSymbolList ();

extern void Language_Compile_Symbol_DumpSymbolStack ();

extern void Language_Compile_Coder_AddSetElement ();

extern void Language_Compile_Coder_All ();

extern void Language_Compile_Coder_AllocateConstant ();

extern void Language_Compile_Coder_AllocateDeferredSubprogram ();

extern void Language_Compile_Coder_AllocateParameters ();

extern void Language_Compile_Coder_AllocateType ();

extern void Language_Compile_Coder_AllocateVariable ();

extern void Language_Compile_Coder_ArraySubscript ();

extern void Language_Compile_Coder_Assertion ();

extern void Language_Compile_Coder_Assign ();

extern void Language_Compile_Coder_AssignInverted ();

extern void Language_Compile_Coder_AssignOp ();

extern void Language_Compile_Coder_BeforeElse ();

extern void Language_Compile_Coder_BeginBlock ();

extern void Language_Compile_Coder_BeginFor ();

extern void Language_Compile_Coder_BeginHandler ();

extern void Language_Compile_Coder_BeginInitList ();

extern void Language_Compile_Coder_BeginLoop ();

extern void Language_Compile_Coder_BeginModule ();

extern void Language_Compile_Coder_BeginModuleInvariant ();

extern void Language_Compile_Coder_BeginPostInvariant ();

extern void Language_Compile_Coder_BeginUnion ();

extern void Language_Compile_Coder_BeginUnit ();

extern void Language_Compile_Coder_Bind ();

extern void Language_Compile_Coder_BitsExtract ();

extern void Language_Compile_Coder_Case ();

extern void Language_Compile_Coder_CaseValue ();

extern void Language_Compile_Coder_CheckSubrange ();

extern void Language_Compile_Coder_ClassSubprogramField ();

extern void Language_Compile_Coder_Close ();

extern void Language_Compile_Coder_CoerceForNumericOperator ();

extern void Language_Compile_Coder_CoerceToType ();

extern void Language_Compile_Coder_CopyArrayDescriptor ();

extern void Language_Compile_Coder_CreateArrayDescriptor ();

extern void Language_Compile_Coder_CreateEnumDescriptor ();

extern void Language_Compile_Coder_CreateUnionMap ();

extern void Language_Compile_Coder_DeallocateFlexibleArray ();

extern void Language_Compile_Coder_Else ();

extern void Language_Compile_Coder_Elsif ();

extern void Language_Compile_Coder_EmptySet ();

extern void Language_Compile_Coder_EndBlock ();

extern void Language_Compile_Coder_EndCase ();

extern void Language_Compile_Coder_EndCaseAlternative ();

extern void Language_Compile_Coder_EndCaseValue ();

extern void Language_Compile_Coder_EndFor ();

extern void Language_Compile_Coder_EndHandler ();

extern void Language_Compile_Coder_EndIf ();

extern void Language_Compile_Coder_EndInitList ();

extern void Language_Compile_Coder_EndIo ();

extern void Language_Compile_Coder_EndLoop ();

extern void Language_Compile_Coder_EndModule ();

extern void Language_Compile_Coder_EndStatement ();

extern void Language_Compile_Coder_EndSubprogram ();

extern void Language_Compile_Coder_EndUnion ();

extern void Language_Compile_Coder_EndUnit ();

extern void Language_Compile_Coder_EnterExternalAddress ();

extern void Language_Compile_Coder_EnterExternalName ();

extern void Language_Compile_Coder_EnterInitValue ();

extern void Language_Compile_Coder_Exit ();

extern void Language_Compile_Coder_ExitMainProgram ();

extern void Language_Compile_Coder_ExplicitClassSubprogramField ();

extern void Language_Compile_Coder_ExplicitFriendSubprogram ();

extern void Language_Compile_Coder_ExpnHash ();

extern void Language_Compile_Coder_Fetch ();

extern void Language_Compile_Coder_Field ();

extern void Language_Compile_Coder_FillInCharStarDescriptor ();

extern void Language_Compile_Coder_ForceToTemporaryPushAddress ();

extern void Language_Compile_Coder_Fork ();

extern void Language_Compile_Coder_Free ();

extern void Language_Compile_Coder_FunctionCall ();

extern void Language_Compile_Coder_Get ();

extern void Language_Compile_Coder_If ();

extern TLboolean Language_Compile_Coder_IllegalPredefined ();

extern void Language_Compile_Coder_Indirect ();

extern void Language_Compile_Coder_InfixOperator ();

extern void Language_Compile_Coder_Initialize ();

extern void Language_Compile_Coder_InitializeBuiltins ();

extern void Language_Compile_Coder_Invariant ();

extern void Language_Compile_Coder_LoadSymbol ();

extern void Language_Compile_Coder_LocateClassDescriptor ();

extern void Language_Compile_Coder_LocateSymbol ();

extern void Language_Compile_Coder_New ();

extern void Language_Compile_Coder_Objectclass ();

extern void Language_Compile_Coder_OpAssign ();

extern void Language_Compile_Coder_Open ();

extern void Language_Compile_Coder_Operator ();

extern void Language_Compile_Coder_Ord ();

extern void Language_Compile_Coder_Otherwise ();

extern void Language_Compile_Coder_Pause ();

extern void Language_Compile_Coder_PointerDereference ();

extern void Language_Compile_Coder_PopState ();

extern void Language_Compile_Coder_ProcedureCall ();

extern void Language_Compile_Coder_PushArrayUpperBound ();

extern void Language_Compile_Coder_PushClassSelf ();

extern void Language_Compile_Coder_PushInitAddress ();

extern void Language_Compile_Coder_PushInt ();

extern void Language_Compile_Coder_PushNewParameter ();

extern void Language_Compile_Coder_PushReferenceParameter ();

extern void Language_Compile_Coder_PushSelfParameter ();

extern void Language_Compile_Coder_PushSize ();

extern void Language_Compile_Coder_PushState ();

extern void Language_Compile_Coder_PushStringSize ();

extern void Language_Compile_Coder_PushValue ();

extern void Language_Compile_Coder_Put ();

extern void Language_Compile_Coder_Quit ();

extern void Language_Compile_Coder_Read ();

extern void Language_Compile_Coder_RestoreState ();

extern void Language_Compile_Coder_Result ();

extern void Language_Compile_Coder_Return ();

extern void Language_Compile_Coder_Seek ();

extern void Language_Compile_Coder_SetInputStream ();

extern void Language_Compile_Coder_SetOutputStream ();

extern void Language_Compile_Coder_SetStream ();

extern void Language_Compile_Coder_SetUninitTable ();

extern void Language_Compile_Coder_Signal ();

extern void Language_Compile_Coder_StartParameters ();

extern void Language_Compile_Coder_StartSubprogram ();

extern void Language_Compile_Coder_Substring ();

extern void Language_Compile_Coder_Tag ();

extern void Language_Compile_Coder_Tell ();

extern void Language_Compile_Coder_UnionField ();

extern void Language_Compile_Coder_Wait ();

extern void Language_Compile_Coder_Write ();

extern void Language_Compile_Coder_SetObjectFileStream ();

extern void Language_Compile_Coder_EnterDefiningOffset ();

extern TLaddressint Language_Compile_Coder_FetchAddress ();

extern TLaddressint Language_Compile_Coder_FetchArrayElementAddr ();

extern TLint4 Language_Compile_Coder_FetchArrayUpper ();

extern TLaddressint Language_Compile_Coder_FetchClassSelf ();

extern TLaddressint Language_Compile_Coder_FetchClassSelfParamAddr ();

extern TLaddressint Language_Compile_Coder_FetchPointerValue ();

extern TLint4 Language_Compile_Coder_FetchUnionNumber ();

extern void Language_Compile_Coder_FetchValue ();
typedef	TLint4	Language_Compile_Coder_InitState;

extern Language_Compile_Coder_InitState Language_Compile_Coder_UnitInitState ();

extern void Language_Compile_PredefRoutines_Reset ();

extern void Language_Compile_PredefRoutines_Initialize ();

extern void Language_Compile_Lists_Initialize ();

extern void Language_Compile_Lists_PushIdentList ();

extern void Language_Compile_Lists_InputIdentList ();

extern void Language_Compile_Lists_InputEnumList ();

extern void Language_Compile_Lists_InputRecordList ();

extern void Language_Compile_Lists_InputUnionList ();

extern void Language_Compile_Lists_InputParameterList ();

extern void Language_Compile_Lists_AddSymbolToIdentList ();

extern void Language_Compile_Lists_MergeTopIdentLists ();

extern void Language_Compile_Lists_PopIdentList ();

extern void Language_Compile_Lists_AddIdentListToBlock ();

extern void Language_Compile_Lists_TypeIdentList ();

extern void Language_Compile_Lists_TypeCollectionList ();

extern void Language_Compile_Lists_EnterCollectionType ();

extern void Language_Compile_Lists_EnterRecordOffsets ();

extern void Language_Compile_Lists_AllocateIdentList ();

extern void Language_Compile_Lists_EnterExternalVarAddress ();

extern void Language_Compile_Lists_EnterExternalVarName ();

extern void Language_Compile_Lists_AssignValuesToEnumIds ();

extern struct Language_Compile_SymbolDef * Language_Compile_Lists_IdentListTop ();

extern void Language_Compile_Lists_AssignIdentList ();

extern void Language_Compile_Lists_SetPervasive ();

extern void Language_Compile_Lists_EnterSymbolAttribute ();

extern void Language_Compile_Lists_LabelUnionBody ();

extern TLint4 Language_Compile_Lists_SymbolCount ();

extern void Language_Compile_Lists_PushIndexList ();

extern void Language_Compile_Lists_AddTypeToIndexList ();

extern void Language_Compile_Lists_PopIndexList ();

extern struct Language_Compile_IndexDef * Language_Compile_Lists_IndexListTop ();

extern void Language_Compile_Expn_BitsSubrange ();

extern void Language_Compile_Expn_BooleanExpression ();

extern void Language_Compile_Expn_CompileTimeExpression ();

extern void Language_Compile_Expn_Expression ();

extern void Language_Compile_Expn_ExpressionOrType ();

extern void Language_Compile_Expn_Initialize ();

extern void Language_Compile_Expn_IntExpression ();

extern void Language_Compile_Expn_Reference ();

extern void Language_Compile_Expn_StringExpression ();

extern void Language_Compile_TypeDecl_BodyParameters ();

extern void Language_Compile_TypeDecl_CheckIndexTypeAndPop ();

extern void Language_Compile_TypeDecl_ConstantType ();

extern void Language_Compile_TypeDecl_Initialize ();

extern void Language_Compile_TypeDecl_InitList ();

extern TLboolean Language_Compile_TypeDecl_IsIndex ();

extern void Language_Compile_TypeDecl_NamedType ();

extern void Language_Compile_TypeDecl_Parameters ();

extern void Language_Compile_TypeDecl_TargetType ();

extern void Language_Compile_TypeDecl_Type ();

extern void Language_Compile_TypeDecl_VariableType ();

extern void Language_Compile_Util_AddSymbolToBlock ();

extern void Language_Compile_Util_CheckInvariant ();

extern void Language_Compile_Util_EndBlock ();

extern void Language_Compile_Util_ExpectEndBlock ();

extern void Language_Compile_Util_ExportList ();

extern void Language_Compile_Util_FlushImportList ();

extern void Language_Compile_Util_ImportList ();

extern void Language_Compile_Util_IOStatusVariable ();

extern void Language_Compile_Util_NewBlock ();

extern void Language_Compile_Util_ParseAssignOrCall ();

extern void Language_Compile_Util_PossibleDeadCodeFollowing ();

extern void Language_Compile_Util_ResetImports ();

extern void Language_Compile_Util_ResolveBlock ();

extern void Language_Compile_Util_SetExports ();

static void Language_Compile_DoTheDump (msg)
TLstring	msg;
{
    TLSTKCHKSLF(100480);
    TLSETF();
    TLSETL(100480);
    if (Language_Compile_debugFile == 0) {
	TLSETL(100481);
	TL_TLI_TLIOF ((TLnat2) 4, "debug", &Language_Compile_debugFile);
    };
    TLSETL(100483);
    TL_TLI_TLISS ((TLint4) Language_Compile_debugFile, (TLint2) 2);
    TL_TLI_TLIPS ((TLint4) 0, msg, (TLint2) Language_Compile_debugFile);
    TL_TLI_TLIPK ((TLint2) Language_Compile_debugFile);
    TLSETL(100485);
    Language_Compile_Symbol_DumpSymbolStack((TLint4) Language_Compile_debugFile);
    TLINCL();
    Language_Compile_Types_DumpTypeStack((TLint4) Language_Compile_debugFile);
    TLINCL();
    Language_Compile_Value_DumpValueStack((TLint4) Language_Compile_debugFile);
    TLINCL();
    Language_Compile_Scope_DumpBlocks((TLint4) Language_Compile_debugFile);
    TLRESTORELF();
}

void Language_Compile_InitializeCompile () {
    TLSTKCHKSLF(100497);
    TLSETF();
    TLSETL(100497);
    Language_Compile_InitializeScan((TLboolean) 0);
    Language_Compile_currentImportDepth = 0;
    TLINCL();
    Language_Compile_blockStack = Language_Compile_rootBlock;
    TLINCL();
    Language_Compile_compilingSymbol = (struct Language_Compile_SymbolDef *) 0;
    TLINCL();
    Language_Compile_monitorSymbol = (struct Language_Compile_SymbolDef *) 0;
    TLINCL();
    Language_Compile_classSymbol = (struct Language_Compile_SymbolDef *) 0;
    TLINCL();
    Language_Compile_subprogramSymbol = (struct Language_Compile_SymbolDef *) 0;
    TLSETL(100505);
    Language_Compile_Value_Initialize();
    TLINCL();
    Language_Compile_Types_Initialize();
    TLINCL();
    Language_Compile_Symbol_Initialize();
    TLINCL();
    Language_Compile_Lists_Initialize();
    TLINCL();
    Language_Compile_Expn_Initialize();
    TLINCL();
    Language_Compile_TypeDecl_Initialize();
    TLRESTORELF();
}

extern void Language_Compile_Parser_ParseUnit ();

void Language_Compile_CompileUnit (unitPtr)
void	*unitPtr;
{
    TLSTKCHKSLF(100517);
    TLSETF();
    TLSETL(100517);
    TLPRE (unitPtr != ((void *) 0));
    TLSETL(100519);
    Language_Compile_compilingUnit = unitPtr;
    TLINCL();
    switch (Language_UnitManager_Kind(Language_Compile_compilingUnit)) {
	case 1:
	    {
		TLSETL(100523);
		Language_Compile_InitializeCompile();
		TLINCL();
		Language_Compile_Coder_InitializeBuiltins();
	    }
	    break;
	case 2:
	    {
		TLSETL(100526);
		Language_Compile_InitializeScan((TLboolean) 0);
		TLINCL();
		Language_Compile_PreScan_VerifyPredefList();
	    }
	    break;
	case 3:
	    {
		TLSETL(100529);
		Language_Compile_InitializeScan((TLboolean) 0);
		TLINCL();
		Language_Compile_PreScan_VerifyConfiguration();
	    }
	    break;
	case 4:
	case 5:
	    {
		TLSETL(100532);
		Language_Compile_InitializeCompile();
		TLINCL();
		Language_Compile_Parser_ParseUnit();
	    }
	    break;
	default:
	    TLCASEABORT;
    };
    TLRESTORELF();
}

void Language_Compile_Reset () {
    TLSTKCHKSLF(100539);
    TLSETF();
    TLSETL(100539);
    Language_Compile_Scanner_Reset();
    TLINCL();
    Language_Compile_PredefRoutines_Reset();
    Language_Compile_predefUnit = (void *) 0;
    TLRESTORELF();
}

void Language_Compile_Initialize () {
    TLSTKCHKSLF(100545);
    TLSETF();
    TLSETL(100545);
    {
	TLBINDREG((*b), struct Language_Compile_BlockDef);
	b = &((*(Language_Compile_rootBlock)));
	TLINCL();
	(*b).childBlock = (struct Language_Compile_BlockDef *) 0;
	TLINCL();
	(*b).internalSymbols = (struct Language_Compile_SymbolDef *) 0;
    };
    TLSETL(100550);
    Language_Compile_PredefRoutines_Initialize();
    TLINCL();
    Language_Compile_Coder_Initialize();
    TLRESTORELF();
}

void Language_Compile_InstallUnit (unitPtr)
void	*unitPtr;
{
    struct Language_Compile_SymbolDef	*unitSy;
    struct Language_Compile_BlockDef	*unitBlock;
    struct Language_Compile_SymbolDef	*expandSy;
    TLSTKCHKSLF(100566);
    TLSETF();
    TLSETL(100566);
    TLPRE (unitPtr != ((void *) 0));
    TLSETL(100568);
    switch (Language_UnitManager_Kind(unitPtr)) {
	case 4:
	case 5:
	    break;
	default :
	    {
		TLSETL(100572);
		TLRESTORELF();
		return;
	    }
	    break;
    };
    TLSETL(100575);
    * (TLnat4 *) &unitSy = Language_UnitManager_SymbolTable(unitPtr);
    TLINCL();
    TLASSERT (unitSy != ((struct Language_Compile_SymbolDef *) 0));
    TLINCL();
    unitBlock = unitSy->blockScope;
    TLINCL();
    TLASSERT (unitBlock != ((struct Language_Compile_BlockDef *) 0));
    TLSETL(100583);
    unitBlock->parentBlock = Language_Compile_rootBlock;
    TLINCL();
    unitBlock->siblingBlock = Language_Compile_rootBlock->childBlock;
    TLINCL();
    Language_Compile_rootBlock->childBlock = unitBlock;
    TLSETL(100590);
    expandSy = unitSy->u.__u1.__u2.mExpandSy;
    TLINCL();
    if (expandSy == ((struct Language_Compile_SymbolDef *) 0)) {
	TLSETL(100592);
	unitBlock->expandBlock = (struct Language_Compile_BlockDef *) 0;
    } else {
	TLSETL(100594);
	unitBlock->expandBlock = expandSy->blockScope;
    };
    TLSETL(100602);
    unitSy->next = (struct Language_Compile_SymbolDef *) 0;
    TLSETL(100608);
    Language_Compile_Symbol_ResetSymbolList(unitSy);
    if (Language_UnitManager_IsPredef(unitPtr)) {
	TLSETL(100609);
	unitSy->next = Language_Compile_rootBlock->internalSymbols;
	TLINCL();
	Language_Compile_rootBlock->internalSymbols = unitSy;
    };
    TLRESTORELF();
}

void Language_Compile_SetObjectFileStream (objectFileStream)
TLint4	objectFileStream;
{
    TLSTKCHKSLF(100617);
    TLSETF();
    TLSETL(100617);
    Language_Compile_Coder_SetObjectFileStream((TLint4) objectFileStream);
    TLRESTORELF();
}

void Language_Compile_CallInfo (pc, fp, routineName, cookie)
TLaddressint	pc;
TLaddressint	fp;
TLstring	routineName;
struct Cookie	*cookie;
{
    register struct Language_Compile_BlockDef	*b;
    Language_Offset	offset;
    struct Language_Compile_BlockDef	*classBlock;
    register struct Language_Compile_SymbolDef	*sy;
    register struct Language_Compile_IdentDef	*id;
    TLstring	subRoutineName;
    TLSTKCHKSLF(3400003);
    TLSETF();
    TLSETL(3400003);
    b = Language_Compile_rootBlock->childBlock;
    TLSETL(3400005);
    for(;;) {
	TLSETL(3400005);
	if (b == ((struct Language_Compile_BlockDef *) 0)) {
	    TLSETL(3400006);
	    TLSTRASS(255, routineName, "?");
	    TLINCL();
	    TLSTRCTASS((*cookie), Language_nullCookie, struct Cookie);
	    TLSETL(3400009);
	    TLRESTORELF();
	    return;
	};
	TLSETL(3400010);
	if (((unsigned long) pc >= (b->codeStartOffset)) && ((unsigned long) pc < (b->codeEndOffset))) {
	    break;
	};
	TLSETL(3400012);
	b = b->siblingBlock;
    };
    TLSETL(3400014);
    offset = (unsigned long) pc - (b->codeStartOffset);
    TLSETL(3400017);
    sy = b->definingSymbol;
    TLINCL();
    if (((sy->u.syTag) != 1) || (Language_Compile_Coder_UnitInitState(sy->loc.unitPtr) != 2)) {
	TLSETL(3400021);
	classBlock = (struct Language_Compile_BlockDef *) 0;
    } else {
	TLSETL(3400023);
	classBlock = b;
    };
    TLSETL(3400026);
    id = sy->identPtr;
    TLINCL();
    if (id == ((struct Language_Compile_IdentDef *) 0)) {
	TLSETL(3400028);
	TLSTRASS(255, routineName, "");
    } else {
	TLSETL(3400030);
	TLSTRASS(255, routineName, id->str);
    };
    TLSETL(3400032);
    TLSTRASS(255, subRoutineName, routineName);
    TLSETL(3400034);
    b = b->childBlock;
    TLSETL(3400036);
    for(;;) {
	TLSETL(3400036);
	if (b == ((struct Language_Compile_BlockDef *) 0)) {
	    break;
	};
	TLSETL(3400038);
	if ((offset >= (b->codeStartOffset)) && (offset < (b->codeEndOffset))) {
	    TLSETL(3400040);
	    switch (b->kind) {
		case 6:
		case 14:
		    {
			TLSETL(3400042);
			id = b->definingSymbol->identPtr;
			TLINCL();
			if (strcmp(subRoutineName, "") == 0) {
			    TLSETL(3400044);
			    TLSTRASS(255, routineName, id->str);
			} else {
			    TLSETL(3400046);
			    {
				TLstring	__x2876;
				TL_TLS_TLSCAT(subRoutineName, ".", __x2876);
				{
				    TLstring	__x2875;
				    TL_TLS_TLSCAT(__x2876, id->str, __x2875);
				    TLSTRASS(255, routineName, __x2875);
				};
			    };
			};
			TLSETL(3400048);
			if ((unsigned long) fp == 0) {
			    TLSETL(3400049);
			    TLSTRCTASS((*cookie), Language_nullCookie, struct Cookie);
			    TLSETL(3400051);
			    TLRESTORELF();
			    return;
			};
			TLSETL(3400052);
			(*cookie).kind = 4;
			TLINCL();
			(*cookie).item = (TLaddressint) ((TLnat4) b);
			TLINCL();
			(*cookie).fp = (TLaddressint) fp;
			TLINCL();
			(*cookie).data = (TLaddressint) offset;
			TLSETL(3400057);
			TLRESTORELF();
			return;
		    }
		    break;
		case 11:
		case 12:
		case 13:
		    {
			TLSETL(3400059);
			sy = b->definingSymbol;
			TLINCL();
			id = sy->identPtr;
			TLINCL();
			if (strcmp(subRoutineName, "") == 0) {
			    TLSETL(3400062);
			    TLSTRASS(255, subRoutineName, id->str);
			} else {
			    TLSETL(3400064);
			    {
				TLstring	__x2877;
				TL_TLS_TLSCAT(".", id->str, __x2877);
				TLSTRCATASS(subRoutineName, __x2877, 255);
			    };
			};
			TLSETL(3400066);
			if ((sy->u.syTag) == 1) {
			    TLSETL(3400067);
			    classBlock = b;
			    TLINCL();
			    TLSTRASS(255, routineName, subRoutineName);
			};
		    }
		    break;
		default :
		    {
			TLSETL(3400072);
			goto __x2897;
		    }
		    break;
	    };
	    TLINCL();
	    b = b->childBlock;
	} else {
	    TLSETL(3400075);
	    b = b->siblingBlock;
	};
    }
    __x2897:;
    TLSETL(3400079);
    if (strcmp(routineName, "") == 0) {
	TLSETL(3400080);
	TLSTRASS(255, routineName, "Main Program");
    };
    TLSETL(3400083);
    if ((classBlock == ((struct Language_Compile_BlockDef *) 0)) || ((unsigned long) fp == 0)) {
	TLSETL(3400084);
	TLSTRCTASS((*cookie), Language_nullCookie, struct Cookie);
    } else {
	TLSETL(3400086);
	(*cookie).kind = 4;
	TLINCL();
	(*cookie).item = (TLaddressint) (* (TLnat4 *) &classBlock);
	TLINCL();
	(*cookie).fp = (TLaddressint) fp;
	TLINCL();
	(*cookie).data = (TLaddressint) offset;
    };
    TLRESTORELF();
}

static struct Language_Compile_SymbolDef * Language_Compile_FindSymbol (codeAddr)
TLaddressint	codeAddr;
{
    register struct Language_Compile_BlockDef	*b;
    struct Language_Compile_SymbolDef	*sy;
    Language_Offset	offset;
    TLSTKCHKSLF(3400097);
    TLSETF();
    TLSETL(3400097);
    if ((unsigned long) codeAddr == 0) {
	TLSETL(3400098);
	TLRESTORELF();
	return ((struct Language_Compile_SymbolDef *) 0);
    };
    TLSETL(3400101);
    b = Language_Compile_rootBlock->childBlock;
    TLSETL(3400103);
    for(;;) {
	TLSETL(3400103);
	if (b == ((struct Language_Compile_BlockDef *) 0)) {
	    TLSETL(3400104);
	    TLRESTORELF();
	    return ((struct Language_Compile_SymbolDef *) 0);
	};
	TLSETL(3400106);
	if (((unsigned long) codeAddr >= (b->codeStartOffset)) && ((unsigned long) codeAddr < (b->codeEndOffset))) {
	    break;
	};
	TLSETL(3400108);
	b = b->siblingBlock;
    };
    TLSETL(3400111);
    sy = b->definingSymbol;
    TLINCL();
    offset = (unsigned long) codeAddr - (b->codeStartOffset);
    TLINCL();
    b = b->childBlock;
    TLSETL(3400115);
    for(;;) {
	TLSETL(3400115);
	if (b == ((struct Language_Compile_BlockDef *) 0)) {
	    TLSETL(3400116);
	    TLRESTORELF();
	    return (sy);
	};
	TLSETL(3400118);
	if ((offset >= (b->codeStartOffset)) && (offset < (b->codeEndOffset))) {
	    TLSETL(3400120);
	    switch (b->kind) {
		case 6:
		case 14:
		    {
			TLSETL(3400122);
			sy = b->definingSymbol;
			TLINCL();
			if ((unsigned long) Language_Compile_Coder_FetchAddress(&(sy->loc), (TLaddressint) 0, (TLaddressint) 0) == (unsigned long) codeAddr) {
			    TLSETL(3400125);
			    TLRESTORELF();
			    return (sy);
			} else {
			    TLSETL(3400127);
			    TLRESTORELF();
			    return ((struct Language_Compile_SymbolDef *) 0);
			};
		    }
		    break;
		case 11:
		case 12:
		case 13:
		    {
			TLSETL(3400131);
			sy = b->definingSymbol;
		    }
		    break;
		default :
		    {
			TLSETL(3400133);
			TLRESTORELF();
			return (sy);
		    }
		    break;
	    };
	    TLSETL(3400135);
	    b = b->childBlock;
	} else {
	    TLSETL(3400137);
	    b = b->siblingBlock;
	};
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

static void Language_Compile_CreateSymbolDef (sy, baseAddr, fp, offset, symbolInfo)
struct Language_Compile_SymbolDef	*sy;
TLaddressint	baseAddr;
TLaddressint	fp;
Language_Offset	offset;
struct DumpSymbolDef	*symbolInfo;
{
    TLSTKCHKSLF(3400145);
    TLSETF();
    TLSETL(3400145);
    if (sy == ((struct Language_Compile_SymbolDef *) 0)) {
	TLSETL(3400146);
	TLSTRCTASS((*symbolInfo), Language_nullSymbolDef, struct DumpSymbolDef);
	TLSETL(3400148);
	TLRESTORELF();
	return;
    };
    TLSETL(3400150);
    TLSTRCTASS((*symbolInfo).srcPos, sy->srcPos, struct SrcPosition);
    TLINCL();
    (*symbolInfo).isPredef = Language_UnitManager_IsPredef(sy->loc.unitPtr);
    TLSETL(3400153);
    if ((sy->identPtr) == ((struct Language_Compile_IdentDef *) 0)) {
	TLSETL(3400154);
	(*symbolInfo).symbolName = (TLaddressint) 0;
	TLINCL();
	(*symbolInfo).typeName = (TLaddressint) 0;
    } else {
	register struct Language_Compile_TypeDef	*ty;
	TLSETL(3400157);
	(*symbolInfo).symbolName = (TLaddressint) ((unsigned long)sy->identPtr->str);
	TLSETL(3400159);
	ty = sy->tyPtr;
	TLINCL();
	if ((((ty->typeName) != ((struct Language_Compile_SymbolDef *) 0)) && ((ty->typeName) != sy)) && ((ty->typeName->u.syTag) == 8)) {
	    TLSETL(3400163);
	    (*symbolInfo).typeName = (TLaddressint) ((unsigned long)ty->typeName->identPtr->str);
	} else {
	    TLSETL(3400165);
	    if ((ty->u.tyTag) == 18) {
		TLSETL(3400166);
		if ((TLSMLSETCONST(13) & (sy->attributes)) != 0) {
		    TLSETL(3400167);
		    (*symbolInfo).typeName = (TLaddressint) ((unsigned long)Language_Compile_TokData[89].Name);
		} else {
		    TLSETL(3400169);
		    (*symbolInfo).typeName = (TLaddressint) ((unsigned long)Language_Compile_TokData[88].Name);
		};
	    } else {
		TLSETL(3400172);
		(*symbolInfo).typeName = (TLaddressint) ((unsigned long)Language_Compile_TypeKindKeyword[TLINRANGELOW(ty->u.tyTag, 0, 32, 1)]);
	    };
	};
    };
    TLSETL(3400176);
    switch (sy->u.syTag) {
	case 1:
	case 5:
	    {
		TLSETL(3400178);
		if ((unsigned long) baseAddr != 0) {
		    TLSETL(3400179);
		    (*symbolInfo).cookie.kind = 3;
		    TLINCL();
		    (*symbolInfo).cookie.data = (TLaddressint) baseAddr;
		} else {
		    TLSETL(3400182);
		    (*symbolInfo).cookie.kind = 4;
		    TLINCL();
		    (*symbolInfo).cookie.data = (TLaddressint) offset;
		};
		TLSETL(3400185);
		(*symbolInfo).cookie.item = (TLaddressint) (* (TLnat4 *) &sy->blockScope);
		TLINCL();
		if ((sy->u.syTag) == 1) {
		    TLSETL(3400187);
		    (*symbolInfo).cookie.fp = (TLaddressint) 0;
		    TLINCL();
		    TLSTRASS(255, (*symbolInfo).value, "class");
		} else {
		    TLSETL(3400190);
		    (*symbolInfo).cookie.fp = (TLaddressint) fp;
		    TLINCL();
		    TLSTRASS(255, (*symbolInfo).value, "");
		};
	    }
	    break;
	case 3:
	    {
		struct Language_Compile_ValueDef	*val;
		TLSETL(3400195);
		val = sy->u.__u1.__u3.cValue;
		TLINCL();
		switch (Language_Compile_Value_ValKind(val)) {
		    case 1:
			{
			    TLSETL(3400198);
			    (*symbolInfo).cookie.kind = 2;
			    TLINCL();
			    (*symbolInfo).cookie.item = (TLaddressint) (* (TLnat4 *) &sy);
			    TLINCL();
			    if ((sy->loc.base) == 1) {
				TLSETL(3400201);
				(*symbolInfo).cookie.fp = (TLaddressint) Language_Compile_Coder_FetchClassSelf((TLaddressint) baseAddr, (TLaddressint) fp);
			    } else {
				TLSETL(3400204);
				(*symbolInfo).cookie.fp = (TLaddressint) fp;
			    };
			    TLSETL(3400206);
			    (*symbolInfo).cookie.data = (TLaddressint) Language_Compile_Coder_FetchAddress(&(sy->loc), (TLaddressint) baseAddr, (TLaddressint) fp);
			    TLSETL(3400210);
			    Language_Compile_Coder_FetchValue(sy->tyPtr, (TLaddressint) ((*symbolInfo).cookie.data), (*symbolInfo).value);
			}
			break;
		    case 2:
			{
			    TLSETL(3400211);
			    TLSTRCTASS((*symbolInfo).cookie, Language_nullCookie, struct Cookie);
			    TLINCL();
			    if (Language_Compile_Value_IntValue(val) == 0) {
				TLSETL(3400213);
				TLSTRASS(255, (*symbolInfo).value, "false");
			    } else {
				TLSETL(3400215);
				TLSTRASS(255, (*symbolInfo).value, "true");
			    };
			}
			break;
		    case 3:
			{
			    TLSETL(3400218);
			    TLSTRCTASS((*symbolInfo).cookie, Language_nullCookie, struct Cookie);
			    TLINCL();
			    {
				TLstring	__x2880;
				Language_Compile_CleanChar((TLchar) ((TLchar) Language_Compile_Value_IntValue(val)), __x2880);
				{
				    TLstring	__x2879;
				    TL_TLS_TLSCAT("\'", __x2880, __x2879);
				    {
					TLstring	__x2878;
					TL_TLS_TLSCAT(__x2879, "\'", __x2878);
					TLSTRASS(255, (*symbolInfo).value, __x2878);
				    };
				};
			    };
			}
			break;
		    case 4:
			{
			    TLSETL(3400222);
			    TLSTRCTASS((*symbolInfo).cookie, Language_nullCookie, struct Cookie);
			    TLINCL();
			    {
				TLstring	__x2883;
				Language_Compile_CleanCString(Language_Compile_Value_CharValue(val), __x2883);
				{
				    TLstring	__x2882;
				    TL_TLS_TLSCAT("\'", __x2883, __x2882);
				    {
					TLstring	__x2881;
					TL_TLS_TLSCAT(__x2882, "\'", __x2881);
					TLSTRASS(255, (*symbolInfo).value, __x2881);
				    };
				};
			    };
			}
			break;
		    case 5:
			{
			    TLSETL(3400226);
			    TLSTRCTASS((*symbolInfo).cookie, Language_nullCookie, struct Cookie);
			    TLINCL();
			    {
				TLstring	__x2884;
				TL_TLS_TLSVIS((TLint4) Language_Compile_Value_IntValue(val), (TLint4) 1, (TLint4) 10, __x2884);
				TLSTRASS(255, (*symbolInfo).value, __x2884);
			    };
			}
			break;
		    case 6:
			{
			    TLSETL(3400229);
			    TLSTRCTASS((*symbolInfo).cookie, Language_nullCookie, struct Cookie);
			    TLINCL();
			    {
				TLstring	__x2885;
				TL_TLS_TLSVRS((TLreal8) Language_Compile_Value_RealValue(val), (TLint4) 1, __x2885);
				TLSTRASS(255, (*symbolInfo).value, __x2885);
			    };
			}
			break;
		    case 7:
			{
			    TLSETL(3400232);
			    TLSTRCTASS((*symbolInfo).cookie, Language_nullCookie, struct Cookie);
			    TLINCL();
			    {
				TLstring	__x2886;
				TL_TLS_TLSVNS((TLnat4) Language_Compile_Value_IntValue(val), (TLint4) 1, (TLint4) 2, __x2886);
				TLSTRASS(255, (*symbolInfo).value, __x2886);
			    };
			}
			break;
		    case 8:
			{
			    register Language_StringDef	*str;
			    TLSETL(3400235);
			    TLSTRCTASS((*symbolInfo).cookie, Language_nullCookie, struct Cookie);
			    TLINCL();
			    str = Language_Compile_Value_StringValue(val);
			    TLINCL();
			    if (TL_TLS_TLSLEN(((*(str)))) > 50) {
				TLSETL(3400238);
				{
				    TLchar	__x2889[52];
				    TL_TLS_TLSBXX(__x2889, (TLint4) 50, (TLint4) 1, ((*(Language_Compile_Value_StringValue(val)))));
				    {
					TLstring	__x2888;
					TL_TLS_TLSCAT("\"", __x2889, __x2888);
					{
					    TLstring	__x2887;
					    TL_TLS_TLSCAT(__x2888, "...\"", __x2887);
					    TLSTRASS(255, (*symbolInfo).value, __x2887);
					};
				    };
				};
			    } else {
				TLSETL(3400242);
				{
				    TLstring	__x2891;
				    TL_TLS_TLSCAT("\"", (*(Language_Compile_Value_StringValue(val))), __x2891);
				    {
					TLstring	__x2890;
					TL_TLS_TLSCAT(__x2891, "\"", __x2890);
					TLSTRASS(255, (*symbolInfo).value, __x2890);
				    };
				};
			    };
			}
			break;
		    default:
			TLCASEABORT;
		};
	    }
	    break;
	case 8:
	    {
		TLSETL(3400248);
		(*symbolInfo).cookie.kind = 2;
		TLINCL();
		(*symbolInfo).cookie.item = (TLaddressint) (* (TLnat4 *) &sy);
		TLINCL();
		(*symbolInfo).cookie.fp = (TLaddressint) fp;
		TLINCL();
		(*symbolInfo).cookie.data = (TLaddressint) 0;
		TLINCL();
		TLSTRASS(255, (*symbolInfo).value, "type");
	    }
	    break;
	case 9:
	    {
		TLSETL(3400255);
		(*symbolInfo).cookie.kind = 2;
		TLINCL();
		(*symbolInfo).cookie.item = (TLaddressint) (* (TLnat4 *) &sy);
		TLINCL();
		if ((sy->loc.base) == 1) {
		    TLSETL(3400258);
		    (*symbolInfo).cookie.fp = (TLaddressint) Language_Compile_Coder_FetchClassSelf((TLaddressint) baseAddr, (TLaddressint) fp);
		} else {
		    TLSETL(3400260);
		    (*symbolInfo).cookie.fp = (TLaddressint) fp;
		};
		TLSETL(3400262);
		(*symbolInfo).cookie.data = (TLaddressint) Language_Compile_Coder_FetchAddress(&(sy->loc), (TLaddressint) baseAddr, (TLaddressint) fp);
		TLSETL(3400267);
		Language_Compile_Coder_FetchValue(sy->tyPtr, (TLaddressint) ((*symbolInfo).cookie.data), (*symbolInfo).value);
	    }
	    break;
	default :
	    {
		TLSETL(3400268);
		TLSTRCTASS((*symbolInfo).cookie, Language_nullCookie, struct Cookie);
		TLINCL();
		TLSTRASS(255, (*symbolInfo).value, "");
	    }
	    break;
    };
    TLRESTORELF();
}

static void Language_Compile_AddSymbolListToDump (reverse, firstSy, baseAddr, fp)
TLboolean	reverse;
struct Language_Compile_SymbolDef	*firstSy;
TLaddressint	baseAddr;
TLaddressint	fp;
{
    register struct Language_Compile_SymbolDef	*sy;
    TLSTKCHKSLF(3400276);
    TLSETF();
    TLSETL(3400276);
    sy = firstSy;
    TLSETL(3400278);
    for(;;) {
	struct DumpSymbolDef	symbolInfo;
	TLSETL(3400278);
	if (sy == ((struct Language_Compile_SymbolDef *) 0)) {
	    break;
	};
	TLSETL(3400282);
	Language_Compile_CreateSymbolDef(sy, (TLaddressint) baseAddr, (TLaddressint) fp, (Language_Offset) 0, &(symbolInfo));
	TLSETL(3400284);
	Language_DebugModule_NewSymbol((TLboolean) reverse, &(symbolInfo));
	sy = sy->next;
    };
    TLRESTORELF();
}

static void Language_Compile_AddClassSelfParameterToDump (subrSy, baseAddr, fp)
struct Language_Compile_SymbolDef	*subrSy;
TLaddressint	baseAddr;
TLaddressint	fp;
{
    register struct Language_Compile_SymbolDef	*classSy;
    struct Language_Compile_TypeDef	*classTy;
    struct Language_Compile_TypeDef	*ty;
    struct DumpSymbolDef	symbolInfo;
    TLSTKCHKSLF(3400291);
    TLSETF();
    TLSETL(3400291);
    classSy = subrSy;
    TLSETL(3400293);
    for(;;) {
	TLSETL(3400293);
	classSy = classSy->definingSy;
	TLINCL();
	TLASSERT (classSy != ((struct Language_Compile_SymbolDef *) 0));
	TLINCL();
	if ((classSy->u.syTag) == 1) {
	    break;
	};
    };
    TLSETL(3400298);
    classTy = classSy->tyPtr;
    TLINCL();
    TLASSERT ((classTy->u.tyTag) == 7);
    TLINCL();
    ty = classTy->u.__u7.__u9.cUPointerTy;
    TLINCL();
    TLASSERT ((ty->u.tyTag) == 21);
    TLSETL(3400304);
    symbolInfo.symbolName = (TLaddressint) ((unsigned long)Language_Compile_TokData[123].Name);
    TLINCL();
    symbolInfo.typeName = (TLaddressint) ((unsigned long)&(Language_Compile_TokData[104]));
    TLINCL();
    TLSTRCTASS(symbolInfo.srcPos, Language_nullSrcPosition, struct SrcPosition);
    TLINCL();
    symbolInfo.isPredef = 0;
    TLINCL();
    symbolInfo.cookie.kind = 1;
    TLINCL();
    symbolInfo.cookie.item = (TLaddressint) (* (TLnat4 *) &ty);
    TLINCL();
    symbolInfo.cookie.fp = (TLaddressint) Language_Compile_Coder_FetchClassSelf((TLaddressint) baseAddr, (TLaddressint) fp);
    TLINCL();
    symbolInfo.cookie.data = (TLaddressint) Language_Compile_Coder_FetchClassSelfParamAddr((TLaddressint) fp);
    TLSETL(3400313);
    Language_Compile_Coder_FetchValue(ty, (TLaddressint) (symbolInfo.cookie.data), symbolInfo.value);
    TLINCL();
    Language_DebugModule_NewSymbol((TLboolean) 0, &(symbolInfo));
    TLRESTORELF();
}

static void Language_Compile_AddTypeToDump (atFront, ty, valueAddress)
TLboolean	atFront;
struct Language_Compile_TypeDef	*ty;
TLaddressint	valueAddress;
{
    struct DumpSymbolDef	symbolInfo;
    register struct Language_Compile_SymbolDef	*sy;
    TLSTKCHKSLF(3400319);
    TLSETF();
    TLSETL(3400319);
    if (ty == ((struct Language_Compile_TypeDef *) 0)) {
	TLSETL(3400321);
	TLRESTORELF();
	return;
    };
    TLSETL(3400325);
    symbolInfo.typeName = (TLaddressint) ((unsigned long)Language_Compile_TypeKindKeyword[TLINRANGELOW(ty->u.tyTag, 0, 32, 1)]);
    TLSETL(3400327);
    sy = ty->typeName;
    TLINCL();
    if ((sy != ((struct Language_Compile_SymbolDef *) 0)) && ((sy->u.syTag) == 8)) {
	TLSETL(3400329);
	symbolInfo.symbolName = (TLaddressint) ((unsigned long)sy->identPtr->str);
	TLINCL();
	TLSTRCTASS(symbolInfo.srcPos, sy->srcPos, struct SrcPosition);
	TLINCL();
	symbolInfo.isPredef = Language_UnitManager_IsPredef(sy->loc.unitPtr);
    } else {
	TLSETL(3400333);
	symbolInfo.symbolName = (TLaddressint) (symbolInfo.typeName);
	TLINCL();
	TLSTRCTASS(symbolInfo.srcPos, Language_nullSrcPosition, struct SrcPosition);
	TLINCL();
	symbolInfo.isPredef = 0;
    };
    TLSETL(3400338);
    if ((unsigned long) valueAddress != 0) {
	TLSETL(3400339);
	symbolInfo.cookie.kind = 1;
	TLINCL();
	symbolInfo.cookie.item = (TLaddressint) (* (TLnat4 *) &ty);
	TLINCL();
	symbolInfo.cookie.fp = (TLaddressint) 0;
	TLINCL();
	symbolInfo.cookie.data = (TLaddressint) valueAddress;
	TLSETL(3400344);
	Language_Compile_Coder_FetchValue(ty, (TLaddressint) valueAddress, symbolInfo.value);
    } else {
	TLSETL(3400345);
	TLSTRCTASS(symbolInfo.cookie, Language_nullCookie, struct Cookie);
	TLINCL();
	TLSTRASS(255, symbolInfo.value, "");
    };
    TLSETL(3400350);
    Language_DebugModule_NewSymbol((TLboolean) atFront, &(symbolInfo));
    TLRESTORELF();
}

void Language_Compile_DumpUnitList (firstSymbol)
struct DumpSymbolDef	**firstSymbol;
{
    TLSTKCHKSLF(3400355);
    TLSETF();
    TLSETL(3400355);
    Language_DebugModule_NewSymbolList();
    TLINCL();
    Language_UnitManager_RewindUnitList();
    TLINCL();
    for(;;) {
	void	*unitPtr;
	struct Language_Compile_SymbolDef	*unitSy;
	struct DumpSymbolDef	symbolInfo;
	TLSETL(3400360);
	for(;;) {
	    TLSETL(3400361);
	    Language_UnitManager_GetNextUnit(&(unitPtr));
	    if (unitPtr == ((void *) 0)) {
		break;
	    };
	    TLSETL(3400362);
	    if (Language_UnitManager_IsCompiled(unitPtr)) {
		TLSETL(3400363);
		switch (Language_UnitManager_Kind(unitPtr)) {
		    case 4:
		    case 5:
			{
			    TLSETL(3400366);
			    if (!Language_UnitManager_IsPredef(unitPtr)) {
				goto __x2898;
			    };
			}
			break;
		    default :
			break;
		};
	    };
	}
	__x2898:;
	TLSETL(3400371);
	if (unitPtr == ((void *) 0)) {
	    break;
	};
	TLSETL(3400374);
	* (TLnat4 *) &unitSy = Language_UnitManager_SymbolTable(unitPtr);
	TLINCL();
	TLASSERT (unitSy != ((struct Language_Compile_SymbolDef *) 0));
	TLSETL(3400379);
	Language_Compile_CreateSymbolDef(unitSy, (TLaddressint) 0, (TLaddressint) 0, (Language_Offset) 0, &(symbolInfo));
	TLINCL();
	Language_DebugModule_NewSymbol((TLboolean) 0, &(symbolInfo));
    };
    TLSETL(3400382);
    Language_DebugModule_ReturnSymbolDump(&((*firstSymbol)));
    TLRESTORELF();
}

static void Language_Compile_DumpTypeInfo (cookie, firstSymbol)
struct Cookie	*cookie;
struct DumpSymbolDef	**firstSymbol;
{
    register struct Language_Compile_TypeDef	*ty;
    TLSTKCHKSLF(3400386);
    TLSETF();
    TLSETL(3400386);
    TLPRE (((*cookie).kind) == 1);
    TLSETL(3400389);
    ty = (void *) (*cookie).item;
    TLSETL(3400391);
    for(;;) {
	TLSETL(3400391);
	if ((ty->u.tyTag) != 20) {
	    break;
	};
	TLSETL(3400392);
	ty = ty->u.__u7.__u13.tyOf;
    };
    TLSETL(3400397);
    Language_DebugModule_NewSymbolList();
    switch (ty->u.tyTag) {
	case 2:
	    break;
	case 13:
	    {
		TLSETL(3400401);
		Language_Compile_AddSymbolListToDump((TLboolean) 0, ty->u.__u7.__u10.EnumIds, (TLaddressint) 0, (TLaddressint) 0);
	    }
	    break;
	case 15:
	case 22:
	case 23:
	    {
		TLSETL(3400403);
		if ((unsigned long) ((*cookie).data) != 0) {
		    struct Language_Compile_SymbolDef	*sy;
		    TLSETL(3400404);
		    sy = Language_Compile_FindSymbol((TLaddressint) Language_Compile_Coder_FetchPointerValue(ty, (TLaddressint) ((*cookie).data)));
		    TLSETL(3400406);
		    if ((sy != ((struct Language_Compile_SymbolDef *) 0)) && ((sy->tyPtr->u.tyTag) == (ty->u.tyTag))) {
			struct DumpSymbolDef	symbolInfo;
			TLSETL(3400410);
			Language_Compile_CreateSymbolDef(sy, (TLaddressint) 0, (TLaddressint) 0, (Language_Offset) 0, &(symbolInfo));
			TLINCL();
			Language_DebugModule_NewSymbol((TLboolean) 0, &(symbolInfo));
		    };
		};
	    }
	    break;
	case 21:
	    {
		TLSETL(3400414);
		if ((unsigned long) ((*cookie).data) != 0) {
		    TLaddressint	ptrValue;
		    TLSETL(3400415);
		    ptrValue = (TLaddressint) Language_Compile_Coder_FetchPointerValue(ty, (TLaddressint) ((*cookie).data));
		    TLSETL(3400417);
		    ty = ty->u.__u7.__u14.pElementOf;
		    TLINCL();
		    if ((ty->u.tyTag) == 7) {
			struct Language_Compile_SymbolDef	*sy;
			TLSETL(3400420);
			sy = Language_Compile_FindSymbol((TLaddressint) Language_Compile_Coder_FetchPointerValue(ty, (TLaddressint) ptrValue));
			TLSETL(3400423);
			if ((sy != ((struct Language_Compile_SymbolDef *) 0)) && ((sy->u.syTag) == 1)) {
			    struct DumpSymbolDef	symbolInfo;
			    TLSETL(3400427);
			    Language_Compile_CreateSymbolDef(sy, (TLaddressint) ptrValue, (TLaddressint) 0, (Language_Offset) 0, &(symbolInfo));
			    TLINCL();
			    Language_DebugModule_NewSymbol((TLboolean) 0, &(symbolInfo));
			};
		    } else {
			TLSETL(3400431);
			Language_Compile_AddTypeToDump((TLboolean) 0, ty, (TLaddressint) ptrValue);
		    };
		};
	    }
	    break;
	case 25:
	    {
		TLSETL(3400436);
		Language_Compile_AddSymbolListToDump((TLboolean) 0, ty->u.__u7.__u15.rFieldsOf, (TLaddressint) ((*cookie).data), (TLaddressint) 0);
	    }
	    break;
	case 31:
	    {
		struct DumpSymbolDef	symbolInfo;
		TLSETL(3400440);
		Language_Compile_CreateSymbolDef(ty->u.__u7.__u20.TagOf, (TLaddressint) ((*cookie).data), (TLaddressint) 0, (Language_Offset) 0, &(symbolInfo));
		TLINCL();
		Language_DebugModule_NewSymbol((TLboolean) 0, &(symbolInfo));
		TLSETL(3400443);
		Language_Compile_AddSymbolListToDump((TLboolean) 0, ty->u.__u7.__u20.uFieldsOf, (TLaddressint) ((*cookie).data), (TLaddressint) 0);
	    }
	    break;
	default :
	    break;
    };
    TLSETL(3400447);
    Language_DebugModule_ReturnSymbolDump(&((*firstSymbol)));
    TLRESTORELF();
}

void Language_Compile_DumpSymbolInfo (cookie, firstSymbol)
struct Cookie	*cookie;
struct DumpSymbolDef	**firstSymbol;
{
    register struct Language_Compile_SymbolDef	*sy;
    TLaddressint	baseAddr;
    register struct Language_Compile_TypeDef	*ty;
    TLSTKCHKSLF(3400452);
    TLSETF();
    TLSETL(3400452);
    if (((*cookie).kind) == 1) {
	TLSETL(3400454);
	Language_Compile_DumpTypeInfo(&((*cookie)), &((*firstSymbol)));
	TLINCL();
	TLRESTORELF();
	return;
    } else {
	TLSETL(3400455);
	if (((*cookie).kind) != 2) {
	    TLSETL(3400456);
	    (*firstSymbol) = (struct DumpSymbolDef *) 0;
	    TLSETL(3400458);
	    TLRESTORELF();
	    return;
	};
    };
    TLSETL(3400461);
    sy = (void *) (*cookie).item;
    TLSETL(3400463);
    baseAddr = (TLaddressint) ((*cookie).data);
    TLSETL(3400467);
    Language_DebugModule_NewSymbolList();
    ty = sy->tyPtr;
    TLSETL(3400469);
    for(;;) {
	TLSETL(3400469);
	if ((ty->u.tyTag) != 20) {
	    break;
	};
	TLSETL(3400470);
	ty = ty->u.__u7.__u13.tyOf;
    };
    TLSETL(3400472);
    switch (ty->u.tyTag) {
	case 2:
	    break;
	case 13:
	    {
		TLSETL(3400477);
		if ((sy->u.syTag) == 8) {
		    TLSETL(3400479);
		    Language_Compile_AddSymbolListToDump((TLboolean) 0, ty->u.__u7.__u10.EnumIds, (TLaddressint) 0, (TLaddressint) 0);
		};
	    }
	    break;
	case 15:
	case 22:
	case 23:
	    {
		TLSETL(3400482);
		if ((sy->u.syTag) == 8) {
		    TLSETL(3400483);
		    sy = ty->u.__u7.__u12.sNameOf;
		    TLINCL();
		    if ((sy->u.syTag) == 4) {
			TLSETL(3400497);
			Language_Compile_AddSymbolListToDump((TLboolean) 0, sy->u.__u1.__u4.fFormalsOf, (TLaddressint) 0, (TLaddressint) 0);
		    } else {
			TLSETL(3400500);
			Language_Compile_AddSymbolListToDump((TLboolean) 0, sy->u.__u1.__u5.pFormalsOf, (TLaddressint) 0, (TLaddressint) 0);
		    };
		} else {
		    TLSETL(3400501);
		    if ((unsigned long) baseAddr != 0) {
			TLSETL(3400502);
			sy = Language_Compile_FindSymbol((TLaddressint) Language_Compile_Coder_FetchPointerValue(ty, (TLaddressint) baseAddr));
			TLINCL();
			if ((sy != ((struct Language_Compile_SymbolDef *) 0)) && ((sy->tyPtr->u.tyTag) == (ty->u.tyTag))) {
			    struct DumpSymbolDef	symbolInfo;
			    TLSETL(3400508);
			    Language_Compile_CreateSymbolDef(sy, (TLaddressint) 0, (TLaddressint) 0, (Language_Offset) 0, &(symbolInfo));
			    TLINCL();
			    Language_DebugModule_NewSymbol((TLboolean) 0, &(symbolInfo));
			};
		    };
		};
	    }
	    break;
	case 21:
	    {
		TLSETL(3400513);
		if ((unsigned long) baseAddr != 0) {
		    TLaddressint	ptrValue;
		    TLSETL(3400514);
		    ptrValue = (TLaddressint) Language_Compile_Coder_FetchPointerValue(ty, (TLaddressint) baseAddr);
		    TLSETL(3400516);
		    ty = ty->u.__u7.__u14.pElementOf;
		    TLINCL();
		    if ((ty->u.tyTag) == 7) {
			TLSETL(3400519);
			sy = Language_Compile_FindSymbol((TLaddressint) Language_Compile_Coder_FetchPointerValue(ty, (TLaddressint) ptrValue));
			TLINCL();
			if ((sy != ((struct Language_Compile_SymbolDef *) 0)) && ((sy->u.syTag) == 1)) {
			    struct DumpSymbolDef	symbolInfo;
			    TLSETL(3400524);
			    Language_Compile_CreateSymbolDef(sy, (TLaddressint) ptrValue, (TLaddressint) 0, (Language_Offset) 0, &(symbolInfo));
			    TLINCL();
			    Language_DebugModule_NewSymbol((TLboolean) 0, &(symbolInfo));
			};
		    } else {
			TLSETL(3400528);
			Language_Compile_AddTypeToDump((TLboolean) 0, ty, (TLaddressint) ptrValue);
		    };
		} else {
		    TLSETL(3400529);
		    if ((sy->u.syTag) == 8) {
			TLSETL(3400531);
			Language_Compile_AddTypeToDump((TLboolean) 0, ty->u.__u7.__u14.pElementOf, (TLaddressint) 0);
		    };
		};
	    }
	    break;
	case 25:
	    {
		TLSETL(3400536);
		Language_Compile_AddSymbolListToDump((TLboolean) 0, ty->u.__u7.__u15.rFieldsOf, (TLaddressint) baseAddr, (TLaddressint) 0);
	    }
	    break;
	case 31:
	    {
		struct DumpSymbolDef	symbolInfo;
		TLint4	unionNumber;
		TLSETL(3400540);
		Language_Compile_CreateSymbolDef(ty->u.__u7.__u20.TagOf, (TLaddressint) baseAddr, (TLaddressint) 0, (Language_Offset) 0, &(symbolInfo));
		TLSETL(3400542);
		Language_DebugModule_NewSymbol((TLboolean) 0, &(symbolInfo));
		unionNumber = Language_Compile_Coder_FetchUnionNumber(ty, (TLaddressint) baseAddr);
		TLINCL();
		sy = ty->u.__u7.__u20.uFieldsOf;
		TLSETL(3400545);
		for(;;) {
		    TLSETL(3400545);
		    if (sy == ((struct Language_Compile_SymbolDef *) 0)) {
			break;
		    };
		    TLSETL(3400546);
		    if ((sy->u.__u1.__u6.unionNumber) == unionNumber) {
			TLSETL(3400548);
			Language_Compile_CreateSymbolDef(sy, (TLaddressint) baseAddr, (TLaddressint) 0, (Language_Offset) 0, &(symbolInfo));
			TLINCL();
			Language_DebugModule_NewSymbol((TLboolean) 0, &(symbolInfo));
		    };
		    TLSETL(3400550);
		    sy = sy->next;
		};
	    }
	    break;
	default :
	    break;
    };
    TLSETL(3400557);
    Language_DebugModule_ReturnSymbolDump(&((*firstSymbol)));
    TLRESTORELF();
}

static void Language_Compile_DumpArrayIndexRange (baseAddr, descAddr, ty, arrayIndex, __x2892, indexNum, idx, dumpIdx)
TLaddressint	baseAddr;
TLaddressint	descAddr;
struct Language_Compile_TypeDef	*ty;
TLint4	arrayIndex[];
TLint4	__x2892;
TLint4	indexNum;
struct Language_Compile_IndexDef	*idx;
struct DumpIndexDef	*dumpIdx;
{
    TLSTKCHKSLF(3400563);
    TLSETF();
    TLSETL(3400563);
    if (idx == ((struct Language_Compile_IndexDef *) 0)) {
	TLaddressint	elementAddr;
	TLSETL(3400564);
	TLASSERT (dumpIdx == ((struct DumpIndexDef *) 0));
	TLINCL();
	elementAddr = (TLaddressint) Language_Compile_Coder_FetchArrayElementAddr((TLaddressint) baseAddr, (TLaddressint) descAddr, arrayIndex, (TLint4) __x2892);
	TLSETL(3400568);
	Language_Compile_AddTypeToDump((TLboolean) 0, ty->u.__u7.__u8.aElementOf, (TLaddressint) elementAddr);
	TLINCL();
	TLRESTORELF();
	return;
    };
    TLSETL(3400570);
    TLASSERT (dumpIdx != ((struct DumpIndexDef *) 0));
    TLSETL(3400572);
    {
	register TLint4	i;
	TLint4	__x2894;
	__x2894 = dumpIdx->upperBound;
	i = dumpIdx->lowerBound;
	if (i <= __x2894) {
	    for(;;) {
		TLSETL(3400574);
		arrayIndex[TLINRANGELOW(indexNum, 1, __x2892, 1)] = i - Language_Compile_Types_Low(idx->ty);
		TLSETL(3400577);
		Language_Compile_DumpArrayIndexRange((TLaddressint) baseAddr, (TLaddressint) descAddr, ty, arrayIndex, (TLint4) __x2892, (TLint4) (indexNum + 1), idx->next, dumpIdx->next);
		if (i == __x2894) break;
		i++;
	    }
	};
    };
    TLRESTORELF();
}

void Language_Compile_DumpArrayValues (cookie, dumpIndices, firstValue)
struct Cookie	*cookie;
struct DumpIndexDef	*dumpIndices;
struct DumpSymbolDef	**firstValue;
{
    register struct Language_Compile_TypeDef	*ty;
    TLaddressint	descAddr;
    TLint4	indexCount;
    struct Language_Compile_IndexDef	*idx;
    TLint4	*arrayIndex;
    TLint4	__x2895;
    TLSTKCHKSLF(3400584);
    TLSETF();
    TLSETL(3400584);
    if (((*cookie).kind) == 1) {
	TLSETL(3400585);
	ty = (void *) (*cookie).item;
    } else {
	TLSETL(3400586);
	if (((*cookie).kind) == 2) {
	    struct Language_Compile_SymbolDef	*sy;
	    TLSETL(3400588);
	    * (TLnat4 *) &sy = (void *) (*cookie).item;
	    TLINCL();
	    ty = sy->tyPtr;
	} else {
	    TLSETL(3400591);
	    (*firstValue) = (struct DumpSymbolDef *) 0;
	    TLSETL(3400593);
	    TLRESTORELF();
	    return;
	};
    };
    TLSETL(3400594);
    if ((ty->u.tyTag) != 2) {
	TLSETL(3400595);
	(*firstValue) = (struct DumpSymbolDef *) 0;
	TLSETL(3400597);
	TLRESTORELF();
	return;
    };
    TLSETL(3400599);
    descAddr = (TLaddressint) Language_Compile_Coder_FetchAddress(&(ty->u.__u7.__u8.aDescriptor), (TLaddressint) ((*cookie).fp), (TLaddressint) ((*cookie).fp));
    TLSETL(3400602);
    indexCount = 0;
    TLINCL();
    idx = ty->u.__u7.__u8.IndexOf;
    TLSETL(3400605);
    for(;;) {
	TLSETL(3400605);
	if (idx == ((struct Language_Compile_IndexDef *) 0)) {
	    break;
	};
	TLSETL(3400606);
	indexCount += 1;
	TLINCL();
	idx = idx->next;
    };
    __x2895 = TLDYN(indexCount);
    TL_TLB_TLBALL((TLint4) __x2895 * 4, &arrayIndex);
    TLSETL(3400613);
    Language_DebugModule_NewSymbolList();
    TLSETL(3400615);
    Language_Compile_DumpArrayIndexRange((TLaddressint) ((*cookie).data), (TLaddressint) descAddr, ty, arrayIndex, (TLint4) __x2895, (TLint4) 1, ty->u.__u7.__u8.IndexOf, dumpIndices);
    TLINCL();
    Language_DebugModule_ReturnSymbolDump(&((*firstValue)));
    TL_TLB_TLBDAL(&arrayIndex);
    TLRESTORELF();
}

void Language_Compile_DumpArrayBounds (cookie, firstIndex)
struct Cookie	*cookie;
struct DumpIndexDef	**firstIndex;
{
    register struct Language_Compile_TypeDef	*ty;
    register struct Language_Compile_IndexDef	*inx;
    TLSTKCHKSLF(3400622);
    TLSETF();
    TLSETL(3400622);
    if (((*cookie).kind) == 1) {
	TLSETL(3400623);
	ty = (void *) (*cookie).item;
    } else {
	TLSETL(3400624);
	if (((*cookie).kind) == 2) {
	    struct Language_Compile_SymbolDef	*sy;
	    TLSETL(3400626);
	    * (TLnat4 *) &sy = (void *) (*cookie).item;
	    TLINCL();
	    ty = sy->tyPtr;
	} else {
	    TLSETL(3400629);
	    (*firstIndex) = (struct DumpIndexDef *) 0;
	    TLSETL(3400631);
	    TLRESTORELF();
	    return;
	};
    };
    TLSETL(3400632);
    if ((ty->u.tyTag) != 2) {
	TLSETL(3400633);
	(*firstIndex) = (struct DumpIndexDef *) 0;
	TLSETL(3400635);
	TLRESTORELF();
	return;
    };
    TLSETL(3400639);
    Language_DebugModule_NewIndexList();
    inx = ty->u.__u7.__u8.IndexOf;
    TLINCL();
    if ((TLSMLSMLSETCONST(2) & (ty->mode)) != 0) {
	TLaddressint	descAddr;
	TLint4	indexNum;
	TLSETL(3400641);
	descAddr = (TLaddressint) Language_Compile_Coder_FetchAddress(&(ty->u.__u7.__u8.aDescriptor), (TLaddressint) ((*cookie).fp), (TLaddressint) ((*cookie).fp));
	TLSETL(3400643);
	indexNum = 1;
	TLINCL();
	if ((unsigned long) descAddr != 0) {
	    TLSETL(3400646);
	    for(;;) {
		TLSETL(3400646);
		if (inx == ((struct Language_Compile_IndexDef *) 0)) {
		    break;
		};
		TLSETL(3400649);
		Language_DebugModule_NewIndex((TLint4) Language_Compile_Types_Low(inx->ty), (TLint4) Language_Compile_Coder_FetchArrayUpper((TLaddressint) descAddr, (TLint4) indexNum));
		inx = inx->next;
		TLINCL();
		indexNum += 1;
	    };
	};
    } else {
	TLSETL(3400655);
	for(;;) {
	    struct Language_Compile_TypeDef	*iTy;
	    TLSETL(3400655);
	    if (inx == ((struct Language_Compile_IndexDef *) 0)) {
		break;
	    };
	    TLSETL(3400656);
	    iTy = inx->ty;
	    TLSETL(3400658);
	    Language_DebugModule_NewIndex((TLint4) Language_Compile_Types_Low(iTy), (TLint4) Language_Compile_Types_High(iTy));
	    inx = inx->next;
	};
    };
    TLSETL(3400663);
    Language_DebugModule_ReturnIndexDump(&((*firstIndex)));
    TLRESTORELF();
}

void Language_Compile_DumpScopeInfo (cookie, unitInitPC, unitInitFP, scopeInfo)
struct Cookie	*cookie;
TLaddressint	unitInitPC;
TLaddressint	unitInitFP;
struct DumpScopeDef	*scopeInfo;
{
    TLaddressint	baseAddr;
    TLaddressint	fp;
    Language_Offset	offset;
    register struct Language_Compile_BlockDef	*b;
    register struct Language_Compile_SymbolDef	*sy;
    struct Language_Compile_BlockDef	*dumpScope;
    TLSTKCHKSLF(3400671);
    TLSETF();
    TLSETL(3400671);
    switch ((*cookie).kind) {
	case 4:
	    {
		TLSETL(3400673);
		baseAddr = (TLaddressint) 0;
		TLINCL();
		offset = (*cookie).data;
	    }
	    break;
	case 3:
	    {
		TLSETL(3400676);
		baseAddr = (TLaddressint) ((*cookie).data);
		TLINCL();
		offset = 0;
	    }
	    break;
	default :
	    {
		TLSETL(3400679);
		TLSTRCTASS((*scopeInfo), Language_nullScopeDef, struct DumpScopeDef);
		TLSETL(3400681);
		TLRESTORELF();
		return;
	    }
	    break;
    };
    TLINCL();
    fp = (TLaddressint) ((*cookie).fp);
    TLSETL(3400685);
    b = (void *) (*cookie).item;
    TLSETL(3400687);
    sy = b->definingSymbol;
    TLSETL(3400690);
    Language_Compile_CreateSymbolDef(sy, (TLaddressint) 0, (TLaddressint) 0, (Language_Offset) 0, &((*scopeInfo).symbolInfo));
    if (((*cookie).kind) == 3) {
	TLSETL(3400691);
	sy = b->internalSymbols;
    } else {
	TLSETL(3400692);
	if (offset == 0) {
	    TLSETL(3400693);
	    switch (Language_Compile_Coder_UnitInitState(sy->loc.unitPtr)) {
		case 0:
		    {
			TLSETL(3400695);
			sy = (struct Language_Compile_SymbolDef *) 0;
		    }
		    break;
		case 1:
		    {
			register struct Language_Compile_BlockDef	*unitBlock;
			TLSETL(3400697);
			unitBlock = b;
			TLSETL(3400699);
			for(;;) {
			    TLSETL(3400699);
			    if ((unitBlock->parentBlock->kind) == 15) {
				break;
			    };
			    TLSETL(3400701);
			    unitBlock = unitBlock->parentBlock;
			};
			TLSETL(3400703);
			if (((unsigned long) unitInitPC >= (b->codeStartOffset)) && ((unsigned long) unitInitPC < (b->codeEndOffset))) {
			    TLSETL(3400705);
			    offset = (unsigned long) unitInitPC - (b->codeStartOffset);
			    TLINCL();
			    fp = (TLaddressint) unitInitFP;
			} else {
			    TLSETL(3400708);
			    sy = (struct Language_Compile_SymbolDef *) 0;
			};
		    }
		    break;
		case 2:
		    {
			TLSETL(3400711);
			sy = b->internalSymbols;
		    }
		    break;
		default:
		    TLCASEABORT;
	    };
	};
    };
    TLSETL(3400715);
    dumpScope = b;
    TLSETL(3400717);
    if (offset != 0) {
	struct Language_Compile_BlockDef	*subScope;
	TLSETL(3400718);
	subScope = b;
	TLINCL();
	b = b->childBlock;
	TLSETL(3400721);
	for(;;) {
	    TLSETL(3400721);
	    if (b == ((struct Language_Compile_BlockDef *) 0)) {
		break;
	    };
	    TLSETL(3400723);
	    if ((offset >= (b->codeStartOffset)) && (offset < (b->codeEndOffset))) {
		TLSETL(3400725);
		switch (b->kind) {
		    case 6:
		    case 14:
		    case 11:
		    case 12:
		    case 13:
			{
			    TLSETL(3400730);
			    goto __x2899;
			}
			break;
		    default :
			break;
		};
		TLSETL(3400732);
		subScope = b;
		TLINCL();
		b = b->childBlock;
	    } else {
		TLSETL(3400735);
		b = b->siblingBlock;
	    };
	}
	__x2899:;
	TLSETL(3400738);
	b = subScope;
	TLINCL();
	sy = b->internalSymbols;
	TLSETL(3400741);
	for(;;) {
	    TLSETL(3400741);
	    if (((sy == ((struct Language_Compile_SymbolDef *) 0)) || ((sy->loc.base) == 8)) || ((sy->definingOffset) <= offset)) {
		break;
	    };
	    TLSETL(3400744);
	    sy = sy->next;
	};
    };
    TLSETL(3400749);
    Language_DebugModule_NewSymbolList();
    TLINCL();
    for(;;) {
	TLSETL(3400751);
	for(;;) {
	    struct DumpSymbolDef	symbolInfo;
	    TLSETL(3400751);
	    if ((sy == ((struct Language_Compile_SymbolDef *) 0)) || ((sy->loc.base) == 8)) {
		break;
	    };
	    TLSETL(3400756);
	    Language_Compile_CreateSymbolDef(sy, (TLaddressint) baseAddr, (TLaddressint) fp, (Language_Offset) offset, &(symbolInfo));
	    TLSETL(3400758);
	    Language_DebugModule_NewSymbol((TLboolean) 1, &(symbolInfo));
	    sy = sy->next;
	};
	TLSETL(3400761);
	if (b == dumpScope) {
	    break;
	};
	TLSETL(3400762);
	sy = b->parentSymbols;
	TLINCL();
	b = b->parentBlock;
    };
    TLSETL(3400767);
    Language_DebugModule_ReturnSymbolDump(&((*scopeInfo).declarations));
    switch (b->kind) {
	case 6:
	    {
		TLSETL(3400769);
		sy = b->definingSymbol;
		TLINCL();
		TLASSERT ((sy->u.syTag) == 4);
		TLSETL(3400773);
		Language_DebugModule_NewSymbolList();
		if ((TLSMLSETCONST(2) & (sy->attributes)) != 0) {
		    TLSETL(3400775);
		    Language_Compile_AddClassSelfParameterToDump(sy, (TLaddressint) baseAddr, (TLaddressint) fp);
		};
		TLSETL(3400788);
		Language_Compile_AddSymbolListToDump((TLboolean) 0, sy->u.__u1.__u4.fFormalsOf, (TLaddressint) baseAddr, (TLaddressint) fp);
		TLSETL(3400790);
		Language_DebugModule_ReturnSymbolDump(&((*scopeInfo).parameters));
		TLSTRCTASS((*scopeInfo).expandCookie, Language_nullCookie, struct Cookie);
	    }
	    break;
	case 14:
	    {
		TLSETL(3400793);
		sy = b->definingSymbol;
		TLINCL();
		TLASSERT ((sy->u.syTag) == 6);
		TLSETL(3400797);
		Language_DebugModule_NewSymbolList();
		if ((TLSMLSETCONST(2) & (sy->attributes)) != 0) {
		    TLSETL(3400799);
		    Language_Compile_AddClassSelfParameterToDump(sy, (TLaddressint) baseAddr, (TLaddressint) fp);
		};
		TLSETL(3400802);
		Language_Compile_AddSymbolListToDump((TLboolean) 0, sy->u.__u1.__u5.pFormalsOf, (TLaddressint) baseAddr, (TLaddressint) fp);
		TLSETL(3400804);
		Language_DebugModule_ReturnSymbolDump(&((*scopeInfo).parameters));
		TLSTRCTASS((*scopeInfo).expandCookie, Language_nullCookie, struct Cookie);
	    }
	    break;
	default :
	    {
		TLSETL(3400807);
		(*scopeInfo).parameters = (struct DumpSymbolDef *) 0;
		TLSETL(3400809);
		b = b->expandBlock;
		TLINCL();
		if (b != ((struct Language_Compile_BlockDef *) 0)) {
		    TLSETL(3400811);
		    TLSTRCTASS((*scopeInfo).expandCookie, (*cookie), struct Cookie);
		    TLINCL();
		    (*scopeInfo).expandCookie.item = (TLaddressint) ((TLnat4) b);
		} else {
		    TLSETL(3400814);
		    TLSTRCTASS((*scopeInfo).expandCookie, Language_nullCookie, struct Cookie);
		};
	    }
	    break;
    };
    TLRESTORELF();
}

void Language_Compile () {
    TLSAVELF();
    TLSETF();
    TLSETL(1600608);
    Language_Compile_dummyLocation.unitPtr = (void *) 0;
    TLINCL();
    Language_Compile_dummyLocation.base = 0;
    TLINCL();
    Language_Compile_dummyLocation.indir = 0;
    TLINCL();
    Language_Compile_dummyLocation.offset = 0;
    TLINCL();
    TLSTRCTASS(Language_Compile_nullLocation, Language_Compile_dummyLocation, struct Language_Compile_Location);
    TLSETL(100248);
    Language_Compile_predefUnit = (void *) 0;
    Language_Compile_CompileError();
    Language_Compile_Memory();
    Language_Compile_Scanner();
    Language_Compile_PreScan();
    TLSETL(100384);
    TL_TLB_TLBNWU(& Language_Compile_rootBlock, (TLint4)  sizeof (    struct Language_Compile_BlockDef));
    TLSETL(100386);
    {
	TLBINDREG((*b), struct Language_Compile_BlockDef);
	b = &((*(Language_Compile_rootBlock)));
	TLINCL();
	(*b).kind = 15;
	TLINCL();
	(*b).parentBlock = (struct Language_Compile_BlockDef *) 0;
	TLINCL();
	(*b).siblingBlock = (struct Language_Compile_BlockDef *) 0;
	TLINCL();
	(*b).expandBlock = (struct Language_Compile_BlockDef *) 0;
	TLSETL(100392);
	(*b).parentSymbols = (struct Language_Compile_SymbolDef *) 0;
	TLSETL(100395);
	(*b).definingSymbol = (struct Language_Compile_SymbolDef *) 0;
	TLINCL();
	(*b).codeStartOffset = 0;
	TLINCL();
	(*b).codeEndOffset = 0;
	TLSETL(100399);
	(*b).dynamics = (struct Language_Compile_DynamicDef *) 0;
	TLINCL();
	(*b).reachable = 1;
	TLINCL();
	(*b).resolvingNeeded = 0;
    };
    TLSETL(100420);
    Language_Compile_monitorSymbol = (struct Language_Compile_SymbolDef *) 0;
    TLINCL();
    Language_Compile_classSymbol = (struct Language_Compile_SymbolDef *) 0;
    TLINCL();
    Language_Compile_subprogramSymbol = (struct Language_Compile_SymbolDef *) 0;
    TLSETL(100433);
    Language_Compile_debugFile = 0;
    Language_Compile_Scope();
    Language_Compile_Value();
    Language_Compile_Types();
    Language_Compile_Symbol();
    Language_Compile_Coder();
    Language_Compile_PredefRoutines();
    Language_Compile_Lists();
    Language_Compile_Expn();
    Language_Compile_TypeDecl();
    Language_Compile_Util();
    TLSETL(100472);
    Language_Compile_procTargetType = Language_Compile_TypeDecl_TargetType;
    TLSETL(100476);
    Language_Compile_procDumpSym = Language_Compile_Symbol_DumpSymbol;
    TLINCL();
    Language_Compile_procDumpSymList = Language_Compile_Symbol_DumpSymbolList;
    TLSETL(100490);
    Language_Compile_DumpAll = Language_Compile_DoTheDump;
    Language_Compile_Parser();
    TLRESTORELF();
}
