#include "cinterface"
static struct {
    TLint4	dummy;
    char	dummy2[2023];
} TLFTAB =
    { 35,
    {'/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'e', 'x', 'e', 'c', 'u', 't', 'e', '.', 'b', 'd', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'e', 'x', 'e', 'c', 'u', 't', 'e', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', '.', '.', '/', '.', '.', '/', 'f', 'i', 'l', 'e', 'm', 'a', 'n', '/', 'f', 'i', 'l', 'e', 'm', 'a', 'n', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', '.', '.', '/', 'd', 'u', 'm', 'm', 'y', '.', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', '.', '.', '/', 'e', 'n', 'v', 'i', 'r', 'o', 'n', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', '.', '.', '/', 'm', 's', 'g', 's', '.', 'd', 'e', 'f', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', '.', '.', '/', 'd', 'e', 'b', 'u', 'g', '.', 'd', 'e', 'f', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', '.', '.', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', '.', '.', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '.', 'b', 'd', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', '.', '.', '/', 'u', 'n', 'i', 't', 'm', 'a', 'n', '/', 'u', 'n', 'i', 't', 'm', 'a', 'n', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', '.', '.', '/', 'e', 'r', 'r', 'o', 'r', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', '.', '.', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'p', 's', 'e', 'u', 'd', 'o', '.', 'd', 'e', 'f', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', '.', '.', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'o', 'p', 'c', 'o', 'd', 'e', '.', 'i', 'n', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', '.', '.', '/', 'd', 'e', 'b', 'u', 'g', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', '.', '.', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'E', 'x', 'e', 'c', 'E', 'r', 'r', 'B', 'o', 'd', 'y', '\0',
    '/', 'l', 'o', 'c', 'a', 'l', '/', 'i', 'n', 'c', 'l', 'u', 'd', 'e', '/', 't', 'p', 'l', 'u', 's', '/', 'D', 'O', 'S', '3', '2', '/', 'k', 'e', 'r', 'n', 'e', 'l', 'T', 'y', 'p', 'e', 's', '\0',
    '/', 'l', 'o', 'c', 'a', 'l', '/', 'i', 'n', 'c', 'l', 'u', 'd', 'e', '/', 't', 'p', 'l', 'u', 's', '/', 'c', 'o', 'm', 'm', 'o', 'n', '/', 'h', 'a', 'n', 'd', 'l', 'e', 'r', '\0',
    '/', 'l', 'o', 'c', 'a', 'l', '/', 'i', 'n', 'c', 'l', 'u', 'd', 'e', '/', 't', 'p', 'l', 'u', 's', '/', 'c', 'o', 'm', 'm', 'o', 'n', '/', 'm', 'o', 'n', 'i', 't', 'o', 'r', '\0',
    '/', 'l', 'o', 'c', 'a', 'l', '/', 'i', 'n', 'c', 'l', 'u', 'd', 'e', '/', 't', 'p', 'l', 'u', 's', '/', 'c', 'o', 'm', 'm', 'o', 'n', '/', 'k', 'e', 'r', 'n', 'e', 'l', '\0',
    '/', 'l', 'o', 'c', 'a', 'l', '/', 'i', 'n', 'c', 'l', 'u', 'd', 'e', '/', 't', 'p', 'l', 'u', 's', '/', 'c', 'o', 'm', 'm', 'o', 'n', '/', 'e', 'x', 'c', 'e', 'p', 't', 'i', 'o', 'n', 's', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'h', 'e', 'a', 'p', '.', 'c', 'h', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'M', 'I', 'O', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'k', 'e', 'r', 'n', 'e', 'l', '.', 'i', 'n', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'k', 'e', 'r', 'n', 'e', 'l', '.', 'c', 'h', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'p', 'c', '_', 'e', 'x', 't', 'e', 'r', 'n', 'a', 'l', '/', 'M', 'a', 't', 'h', '.', 'c', 'h', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'p', 'c', '_', 'e', 'x', 't', 'e', 'r', 'n', 'a', 'l', '/', 'S', 't', 'r', 'i', 'n', 'g', '.', 'c', 'h', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'p', 'c', '_', 'e', 'x', 't', 'e', 'r', 'n', 'a', 'l', '/', 'S', 'y', 's', 't', 'e', 'm', '.', 'c', 'h', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'p', 'c', '_', 'e', 'x', 't', 'e', 'r', 'n', 'a', 'l', '/', 'L', 'i', 'm', 'i', 't', 's', '.', 'c', 'h', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'p', 'c', '_', 'e', 'x', 't', 'e', 'r', 'n', 'a', 'l', '/', 'G', 'r', 'a', 'p', 'h', 'i', 'c', 's', '.', 'c', 'h', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'p', 'c', '_', 'e', 'x', 't', 'e', 'r', 'n', 'a', 'l', '/', 'E', 'v', 'e', 'n', 't', '.', 'c', 'h', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'p', 'c', '_', 'e', 'x', 't', 'e', 'r', 'n', 'a', 'l', '/', 'M', 'T', '.', 'c', 'h', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'p', 'c', '_', 'e', 'x', 't', 'e', 'r', 'n', 'a', 'l', '/', 's', 't', 'a', 'r', '/', 'S', 't', 'a', 'r', '.', 'c', 'h', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'r', 'u', 'n', '.', 's', 't', '\0',
    '/', 'l', 'o', 'c', 'a', 'l', '/', 'i', 'n', 'c', 'l', 'u', 'd', 'e', '/', 't', 'p', 'l', 'u', 's', '/', 'c', 'o', 'm', 'm', 'o', 'n', '/', 's', 'y', 's', 't', 'e', 'm', '\0'
    }};
typedef	TLnat2	FileManager_FileNoType;
typedef	TLnat4	FileManager_FileTimeStamp;
typedef	TLint2	FileManager_ResultCode;

extern void FileManager_OpenNamedHandle ();

extern void FileManager_OpenUnnamedHandle ();

extern void FileManager_OpenFileHandle ();

extern void FileManager_SetModified ();

extern void FileManager_WriteFile ();

extern void FileManager_WriteBackup ();

extern void FileManager_WriteTemp ();

extern void FileManager_RmTemp ();

extern void FileManager_CloseFileHandle ();

extern void FileManager_OpenNamedText ();

extern void FileManager_OpenFileText ();

extern void FileManager_CloseFileText ();

extern void FileManager_CloseAllText ();

extern void FileManager_ChangeDirectory ();

extern void FileManager_GetDirectory ();

extern void FileManager_ChangeExecDirectory ();

extern void FileManager_GetExecDirectory ();

extern void FileManager_ShortName ();

extern void FileManager_RelativeName ();

extern void FileManager_PathName ();

extern void FileManager_ExecPathName ();

extern void FileManager_ExtendName ();

extern void FileManager_FileName ();

extern TLboolean FileManager_IsUnnamed ();

extern TLboolean FileManager_IsOnDisk ();

extern TLboolean FileManager_IsSameFile ();

extern TLboolean FileManager_IsReadOK ();

extern TLboolean FileManager_IsWriteOK ();

extern TLboolean FileManager_IsOlder ();

extern TLboolean FileManager_FileExists ();

extern void FileManager_AddReference ();

extern void FileManager_DeleteReference ();

extern void FileManager_ReadTimeStamp ();

extern void FileManager_FlushUnreferencedFiles ();

extern void FileManager_CheckReferencedFiles ();

extern void FileManager_RmFile ();

extern void FileManager_SetDefaultInclude ();

extern void FileManager_AssertTextClosed ();

extern void FileManager_Dump ();

extern TLboolean AbortCheck ();

extern void FeedBack ();
struct	SrcPosition {
    TLnat2	lineNo;
    FileManager_FileNoType	fileNo;
    TLnat2	linePos;
    TLnat2	tokLen;
};
typedef	TLchar	__x1926[256];
struct	ErrMsgDef {
    struct ErrMsgDef	*next;
    struct SrcPosition	srcPos;
    __x1926	text;
};
typedef	TLint4	CookieKind;
struct	Cookie {
    CookieKind	kind;
    TLaddressint	item;
    TLaddressint	fp;
    TLaddressint	data;
};
struct	CallDef {
    struct CallDef	*next;
    TLstring	routineName;
    struct SrcPosition	srcPos;
    struct Cookie	cookie;
};
struct	ThreadDef {
    struct ThreadDef	*next;
    TLaddressint	threadId;
    TLaddressint	threadName;
    struct CallDef	*traceback;
};
struct	ThreadQueueDef {
    struct ThreadQueueDef	*next;
    TLaddressint	queueId;
    TLstring	queueName;
    struct ThreadDef	*threadList;
};
struct	DumpIndexDef {
    struct DumpIndexDef	*next;
    TLint4	lowerBound;
    TLint4	upperBound;
};
struct	DumpSymbolDef {
    struct DumpSymbolDef	*next;
    TLaddressint	symbolName;
    TLaddressint	typeName;
    struct SrcPosition	srcPos;
    TLstring	value;
    struct Cookie	cookie;
    TLboolean	isPredef;
};
struct	DumpScopeDef {
    struct DumpSymbolDef	symbolInfo;
    struct Cookie	expandCookie;
    struct DumpSymbolDef	*parameters;
    struct DumpSymbolDef	*declarations;
};

extern void Language_Debugging ();

extern void Language_Paragraph ();

extern void Language_Reset ();

extern void Language_SetMaxErrorCount ();
typedef	TLstring	__x1927[20];

extern void Language_EnterPreprocSymbols ();

extern void Language_CompileUnit ();

extern void Language_CompileProgram ();

extern void Language_WriteObjectFile ();
typedef	TLstring	__x1930[21];
typedef	TLstring	__x1934[21];

extern void Language_SetupExecution ();
typedef	TLint1	Language_Step;

extern void Language_SetStep ();
typedef	TLint1	Language_ReturnState;
struct	Language_RunStatus {
    Language_ReturnState	state;
    TLint4	moreStateInfo;
    struct SrcPosition	srcPos;
    TLaddressint	threadId;
};

extern void Language_ExecuteProgram ();

extern void Language_EndExecution ();

extern void Language_StopExecution ();

extern void Language_DumpThreadList ();

extern void Language_DumpUnitList ();

extern void Language_DumpScopeInfo ();

extern void Language_DumpSymbolInfo ();

extern void Language_DumpArrayBounds ();

extern void Language_DumpArrayValues ();
extern TLboolean	Language_debug;
extern struct SrcPosition	Language_nullSrcPosition;
extern struct Cookie	Language_nullCookie;
extern struct DumpSymbolDef	Language_nullSymbolDef;
extern struct DumpScopeDef	Language_nullScopeDef;
typedef	TLint1	Language_UnitManager_UnitKind;
typedef	TLint1	Language_UnitManager_UnitStatus;

extern void Language_UnitManager_AddDepend ();

extern void Language_UnitManager_AddIncludeFile ();

extern void Language_UnitManager_AllocateCompileChunk ();

extern void * Language_UnitManager_BodyUnit ();

extern void Language_UnitManager_ClearAllMarks ();

extern void Language_UnitManager_ClearConfiguration ();

extern TLaddressint Language_UnitManager_CodeTable ();

extern FileManager_FileNoType Language_UnitManager_FileNo ();

extern void Language_UnitManager_FlushOldUnits ();

extern void Language_UnitManager_GetNextDepend ();

extern void Language_UnitManager_GetNextUnit ();

extern void Language_UnitManager_GetUnitPtr ();

extern TLaddressint Language_UnitManager_GlobalArea ();

extern TLint4 Language_UnitManager_GlobalSize ();

extern TLboolean Language_UnitManager_IsCompiled ();

extern TLboolean Language_UnitManager_IsMarked ();

extern TLboolean Language_UnitManager_IsPredef ();

extern Language_UnitManager_UnitKind Language_UnitManager_Kind ();

extern TLaddressint Language_UnitManager_ManifestTable ();

extern void * Language_UnitManager_OverrideBody ();

extern void Language_UnitManager_PrepareForCompile ();

extern void Language_UnitManager_PrepareForDepends ();

extern void Language_UnitManager_PrepareForScan ();

extern void Language_UnitManager_Reset ();

extern void Language_UnitManager_RewindDependList ();

extern void Language_UnitManager_RewindUnitList ();

extern void Language_UnitManager_SetCodeTable ();

extern void Language_UnitManager_SetDefaultBody ();

extern void Language_UnitManager_SetGlobalArea ();

extern void Language_UnitManager_SetKind ();

extern void Language_UnitManager_SetManifestTable ();

extern void Language_UnitManager_SetMark ();

extern void Language_UnitManager_SetOverrideBody ();

extern void Language_UnitManager_SetPredef ();

extern void Language_UnitManager_SetStub ();

extern void Language_UnitManager_SetSymbolTable ();

extern void Language_UnitManager_StartNewProgram ();

extern void * Language_UnitManager_StubUnit ();

extern void Language_UnitManager_SuccessfulCompile ();

extern TLaddressint Language_UnitManager_SymbolTable ();
typedef	TLint1	Language_ErrorModule_Severity;

extern void Language_ErrorModule_Initialize ();

extern void Language_ErrorModule_SetMaxErrors ();

extern void Language_ErrorModule_Message ();

extern void Language_ErrorModule_AbortIfErrors ();

extern void Language_ErrorModule_ReturnErrors ();
typedef	Language_ErrorModule_Severity	Language_ErrorSeverity;
typedef	TLstring	Language_StringDef;
typedef	TLnat4	Language_Offset;
extern TLint4	Language_codeOprSize;
extern TLint4	Language_codeInt1Size;
extern TLint4	Language_codeInt2Size;
extern TLint4	Language_codeIntSize;
extern TLint4	Language_codeRealSize;
extern TLint4	Language_codeAddrSize;
extern TLint4	Language_codeOffsetSize;
typedef	TLchar	Language_string1[2];
typedef	TLnat1	Language_set8;
typedef	TLnat2	Language_set16;
typedef	TLnat4	Language_set32;
typedef	TLint2	Language_Opcode;
typedef	TLchar	Language___x1938[22];
typedef	Language___x1938	Language___x1937[255];
//extern Language___x1937	Language_OpcodeName;
struct	Language_CodeHeader {
    TLaddressint	bodyCode;
};
struct	Language___x1940 {
    TLint4	lower, range;
};
typedef	struct Language___x1940	Language___x1939[255];
struct	Language_ArrayDescriptor {
    TLnat4	sizeArray;
    TLnat4	sizeElement;
    TLnat4	elementCount;
    TLnat4	numDimensions;
    Language___x1939	dim;
};
struct	Language_ForDescriptor {
    TLint4	counter;
    TLint4	right;
    TLint4	step;
    TLaddressint	savedSP;
};
typedef	Language_Offset	Language___x1941[1001];
struct	Language_CaseDescriptor {
    TLint4	lower, upper;
    Language_Offset	otherwise;
    Language___x1941	caseVector;
};
struct	Language_PointerDescriptor {
    TLaddressint	dataPtr;
    TLint4	timestamp;
};
typedef	TLnat2	Language___x1942[301];
struct	Language_UnionMapDescriptor {
    TLint4	lower, upper;
    Language___x1942	map;
};
typedef	TLnat4	Language_ClassAttr;
struct	Language_ClassDescriptor {
    TLaddressint	baseClass;
    TLaddressint	expandClass;
    Language_ClassAttr	attributes;
    TLnat4	objSize;
    TLaddressint	classId;
    TLaddressint	initRoutine;
    TLnat4	numOperations;
};
typedef	TLint1	Language_OpenKind;
typedef	TLint1	Language_PutKind;
typedef	TLint1	Language_GetKind;
typedef	TLint1	Language_SetStreamKind;
typedef	TLnat1	Language_StreamModeSet;
typedef	TLint1	Language_SubstringKind;
typedef	TLint1	Language_RangeCheckKind;
typedef	TLint1	Language_ConditionKind;

extern void Language_DebugModule_Initialize ();

extern void Language_DebugModule_NewQueue ();

extern void Language_DebugModule_NewThread ();

extern void Language_DebugModule_NewCall ();

extern void Language_DebugModule_ReturnThreadDump ();

extern void Language_DebugModule_NewSymbolList ();

extern void Language_DebugModule_NewSymbol ();

extern void Language_DebugModule_ReturnSymbolDump ();

extern void Language_DebugModule_NewIndexList ();

extern void Language_DebugModule_NewIndex ();

extern void Language_DebugModule_ReturnIndexDump ();

extern void Language_Compile_Reset ();

extern void Language_Compile_Initialize ();
typedef	TLstring	__x1945[20];

extern void Language_Compile_EnterPreprocSymbols ();

extern void Language_Compile_ScanUnit ();

extern void Language_Compile_CompileUnit ();

extern void Language_Compile_InstallUnit ();

extern void Language_Compile_CallInfo ();

extern void Language_Compile_DumpUnitList ();

extern void Language_Compile_DumpScopeInfo ();

extern void Language_Compile_DumpSymbolInfo ();

extern void Language_Compile_DumpArrayBounds ();

extern void Language_Compile_DumpArrayValues ();

extern void Language_Compile_SetObjectFileStream ();
typedef	TLstring	__x1948[21];

void Language_Execute_Initialize ();

TLint4 Language_Execute_GetStackAllocated ();

void Language_Execute_Executor ();

void Language_Execute_EndExecution ();

void Language_Execute_RecoverAllMemory ();

void Language_Execute_SetStep ();

void Language_Execute_DumpThreadList ();

void Language_Execute_UnitInitState ();
TLint2	Language_Execute_executionTimeout;
TLboolean	Language_Execute_externalExecutionTimeoutFlag;
TLint4	Language_Execute_stackAllocated;
TLboolean	Language_Execute_allWaitingForKeyboard;
TLboolean	Language_Execute_allWaitingForMouse;
TLboolean	Language_Execute_allWaitingForDelay;
TLint4	Language_Execute_minimumDelayCount;

extern void TL_TLB_TLBUUN ();

extern void TL_TLB_TLBUNI ();

//extern char *strcpy ();
typedef	TLint2	Language_Execute_ExecutionError_OverflowKind;
static TLint4	Language_Execute_ExecutionError_savedQuitCode;
static TLstring	Language_Execute_ExecutionError_savedMessage;

void Language_Execute_ExecutionError_Abort (quitCode, message)
TLint4	quitCode;
TLstring	message;
{
    TLSTKCHKSLF(1600018);
    TLSETF();
    TLSETL(1600018);
    Language_Execute_ExecutionError_savedQuitCode = quitCode;
    TLINCL();
    TLSTRASS(255, Language_Execute_ExecutionError_savedMessage, message);
    TLINCL();
    TL_TLE_TLEQUIT ((TLint4) 2, (char *) 0, 0);
    TLRESTORELF();
}
static Language_Execute_ExecutionError_OverflowKind	Language_Execute_ExecutionError_overflowKind;

void Language_Execute_ExecutionError_SetOverflowKind (kind)
Language_Execute_ExecutionError_OverflowKind	kind;
{
    TLSTKCHKSLF(1600029);
    TLSETF();
    TLSETL(1600029);
    Language_Execute_ExecutionError_overflowKind = kind;
    TLRESTORELF();
}
typedef	TLnat4	Language_Execute_ExecutionError_TL_priority_t;
struct	Language_Execute_ExecutionError_TL_ExceptionInfo {
    TLint4	quitCode;
    TLint4	libraryQuitCode;
    TLstring	errorMsg;
};
typedef	TLnat1	Language_Execute_ExecutionError___x1951[1];
struct	Language_Execute_ExecutionError_TL_HandlerArea {
    TLint4	quitCode;
    TLnat4	lineAndFile;
    TLaddressint	fileTable;
    struct Language_Execute_ExecutionError_TL_HandlerArea	*nextHandler;
    Language_Execute_ExecutionError___x1951	savedState;
};
typedef	TLnat4	Language_Execute_ExecutionError_TL_hardwarePriority_t;
typedef	Language_Execute_ExecutionError_TL_hardwarePriority_t	Language_Execute_ExecutionError_TL_lockStatus_t;
typedef	TLnat4	Language_Execute_ExecutionError_TL_lock_t;
struct	Language_Execute_ExecutionError_TL_link_t {
    struct Language_Execute_ExecutionError_TL_ProcessDescriptor	*flink;
    struct Language_Execute_ExecutionError_TL_ProcessDescriptor	*blink;
};
struct	Language_Execute_ExecutionError_TL_ProcessDescriptor {
    TLnat4	lineAndFile;
    TLaddressint	fileTable;
    TLaddressint	stackLimit;
    TLaddressint	stackPointer;
    struct Language_Execute_ExecutionError_TL_HandlerArea	*handlerQhead;
    struct Language_Execute_ExecutionError_TL_HandlerArea	*currentHandler;
    TLaddressint	name;
    struct Language_Execute_ExecutionError_TL_ExceptionInfo	exception;
    TLnat4	waitParameter;
    struct Language_Execute_ExecutionError_TL_ProcessDescriptor	*monitorQlink;
    TLnat4	timeOutStatus;
    TLnat4	pid;
    TLaddressint	memoryBase;
    TLnat4	timeoutTime;
    TLnat4	timeoutEpoch;
    struct Language_Execute_ExecutionError_TL_link_t	timeoutQ;
    TLboolean	timedOut;
    TLboolean	pausing;
    Language_Execute_ExecutionError_TL_priority_t	dispatchPriority;
    struct Language_Execute_ExecutionError_TL_ProcessDescriptor	*runQlink;
    TLboolean	ready;
    struct Language_Execute_ExecutionError_TL_ProcessDescriptor	*tsyncWaiter;
    TLnat4	quantum;
    TLnat4	quantumCntr;
    TLnat4	devmonLevel;
    TLaddressint	otherInfo;
};
struct	Language_Execute_ExecutionError_TL_queue_t {
    struct Language_Execute_ExecutionError_TL_ProcessDescriptor	*head;
    struct Language_Execute_ExecutionError_TL_ProcessDescriptor	*tail;
};
struct	Language_Execute_ExecutionError_TL_MonitorDescriptor {
    Language_Execute_ExecutionError_TL_lock_t	mQLock;
    TLint4	entryParameter;
    TLint4	monitorPriority;
    TLboolean	deviceMonitor;
    struct Language_Execute_ExecutionError_TL_queue_t	entryQ;
    struct Language_Execute_ExecutionError_TL_queue_t	reEntryQ;
    TLaddressint	name;
    struct Language_Execute_ExecutionError_TL_ConditionDescriptor	*firstCondition;
    struct Language_Execute_ExecutionError_TL_MonitorDescriptor	*nextMonitor;
    struct Language_Execute_ExecutionError_TL_MonitorDescriptor	*prevMonitor;
    TLaddressint	otherInfo;
};
struct	Language_Execute_ExecutionError_TL_ConditionDescriptor {
    struct Language_Execute_ExecutionError_TL_queue_t	signalQ;
    struct Language_Execute_ExecutionError_TL_MonitorDescriptor	*md;
    TLaddressint	name;
    TLnat4	index;
    struct Language_Execute_ExecutionError_TL_ConditionDescriptor	*nextCondition;
    struct Language_Execute_ExecutionError_TL_ConditionDescriptor	*prevCondition;
    TLaddressint	otherInfo;
};
typedef	struct Language_Execute_ExecutionError_TL_ConditionDescriptor	Language_Execute_ExecutionError___x1954[65535];
extern struct Language_Execute_ExecutionError_TL_ProcessDescriptor	*TL_TLKPD;
extern struct Language_Execute_ExecutionError_TL_ProcessDescriptor	*TL_TLK_TLKTQH;
extern struct Language_Execute_ExecutionError_TL_MonitorDescriptor	*TL_TLM_TLMMLH;

void Language_Execute_ExecutionError_GetAbort (quitCode, message)
TLint4	*quitCode;
TLstring	message;
{
    TLSTKCHKSLF(1600043);
    TLSETF();
    TLSETL(1600043);
    if ((*quitCode) == 2) {
	TLSETL(1600044);
	(*quitCode) = Language_Execute_ExecutionError_savedQuitCode;
	TLINCL();
	TLSTRASS(255, message, Language_Execute_ExecutionError_savedMessage);
    } else {
	TLSETL(1600046);
	if ((*quitCode) == 51) {
	    TLSETL(1600047);
	    if (Language_Execute_ExecutionError_overflowKind == 1) {
		TLSETL(1600048);
		TLSTRASS(255, message, "Overflow in real \'mod\' operation");
	    } else {
		TLSETL(1600049);
		if (Language_Execute_ExecutionError_overflowKind == 2) {
		    TLSETL(1600050);
		    TLSTRASS(255, message, "Overflow in real \'div\' operation");
		} else {
		    TLSETL(1600055);
		    TLSTRASS(255, message, TL_TLKPD->exception.errorMsg);
		};
	    };
	} else {
	    TLSETL(1600063);
	    TLSTRASS(255, message, TL_TLKPD->exception.errorMsg);
	};
    };
    TLRESTORELF();
}

void Language_Execute_ExecutionError_Initialize () {
    TLSTKCHKSLF(1600072);
    TLSETF();
    TLSETL(1600072);
    Language_Execute_ExecutionError_savedQuitCode = 0;
    TLINCL();
    TLSTRASS(255, Language_Execute_ExecutionError_savedMessage, "");
    TLINCL();
    Language_Execute_ExecutionError_overflowKind = 0;
    TLRESTORELF();
}

void ExecutionError () {
    TLSAVELF();
    TLSETF();
    TLRESTORELF();
}

extern void Language_Execute_Heap_Alloc ();

extern void Language_Execute_Heap_CleanUp ();

extern void Language_Execute_Heap_Dealloc ();

extern void Language_Execute_Heap_Free ();

extern void Language_Execute_Heap_New ();

extern void Language_Execute_Heap_Realloc ();
typedef	TLint1	MIO_EventMode;
struct	MIO_EventDescriptor {
    MIO_EventMode	mode;
    TLint4	count;
    TLaddressint    data;
};

extern TLboolean MIO_HasEvent ();

extern TLboolean MIO_SetActive ();

extern void MIO_NextEvent ();

extern void MIO_SetEvents ();

extern void MIO_GetEvent ();
typedef	TLchar	__x1955[4];

extern void MIO_KeyTranslate ();

extern TLchar MIO_Getch ();

extern TLboolean MIO_Hasch ();

extern void MIO_Clip ();

extern void MIO_ClipOff ();

extern void MIO_Clear ();

extern TLint4 MIO_ColourNum ();

extern void MIO_DrawArc ();

extern void MIO_DrawBox ();

extern void MIO_DrawDot ();

extern void MIO_DrawFill ();

extern void MIO_DrawFillArc ();

extern void MIO_DrawFillBox ();

extern void MIO_DrawFillOval ();

extern void MIO_DrawFillPolygon ();

extern void MIO_DrawLine ();

extern void MIO_DrawOval ();

extern void MIO_DrawPic ();

extern void MIO_DrawPolygon ();

extern void MIO_DrawText ();

extern void MIO_DrawTextSize ();

extern TLint4 MIO_FontNum ();

extern void MIO_GetColour ();

extern TLint4 MIO_GetDotColour ();

extern void MIO_GetGraphMax ();

extern TLint4 MIO_GetMaxColour ();

extern TLint4 MIO_GetMaxFont ();

extern TLint4 MIO_GetPalette ();

extern void MIO_GetPos ();

extern void MIO_GetRgb ();

extern void MIO_GetScreenSize ();

extern void MIO_GetTextChar ();

extern TLint4 MIO_GetTextFont ();

extern void MIO_GetTextMax ();

extern void MIO_NumColour ();

extern void MIO_NumFont ();

extern void MIO_SetBackgroundColour ();

extern void MIO_SetPalette ();

extern void MIO_SetPos ();

extern void MIO_SetPosXY ();

extern void MIO_SetRgb ();

extern void MIO_SetTextBackgroundColour ();

extern void MIO_SetTextColour ();

extern void MIO_SetTextFont ();

extern TLint4 MIO_SizePic ();

extern void MIO_TakePic ();

extern void MIO_Init ();

extern void MIO_End ();

extern void MIO_Mode ();

extern void MIO_Delay ();

extern void MIO_PlaySound ();

extern void MIO_Play ();

extern TLboolean MIO_PlayDone ();

extern void MIO_RegisterOpen ();

extern void MIO_RegisterClose ();
TLnat2	Language_Execute_numArguments;
typedef	TLint1	Language_Execute___x1956[23];
Language_Execute___x1956	Language_Execute_fileMap;
typedef	Language_StringDef	*Language_Execute___x1959[21];
Language_Execute___x1959	Language_Execute_argumentNames;
static TLnat2	Language_Execute_numFilesOpen;
extern TLboolean	TL_TLI_TLIUXS;
extern TLint4	TL_TLI_TLIXSN;

extern void TL_TLI_TLIOF ();

extern void TL_TLI_TLISS ();

extern void TL_TLI_TLIPC ();

extern void TL_TLI_TLIGC ();

extern TLaddressint TL_TLI_TLIGF ();
struct	Language_Execute_LibraryAbort {
    TLint4	quitCode;
    TLstring	errorMsg;
};
struct	Language_Execute_SavedRegisters {
    TLaddressint	fp;
    TLaddressint	sp;
};
struct	Language_Execute_HandlerArea {
    TLint4	quitCode;
    struct SrcPosition	srcPos;
    struct Language_Execute_HandlerArea	*nextHandler;
    TLaddressint	handlerRoutine;
    struct Language_Execute_SavedRegisters	savedRegisters;
};
struct	Language_Execute_PendingEvent {
    TLint4	stream;
    struct MIO_EventDescriptor	event;
};
struct	Language_Execute_ProcessDescriptor {
    TLaddressint	pc;
    TLaddressint	fp;
    TLaddressint	sp;
    TLaddressint	minimumSP;
    TLaddressint	stackBase;
    struct SrcPosition	srcPos;
    TLint4	activeStream;
    struct Language_Execute_PendingEvent	pendingEvent;
    struct Language_Execute_LibraryAbort	abort;
    TLint4	errno;
    TLstring	errMessage;
    TLint4	prevErrno;
    TLstring	prevErrMessage;
    TLaddressint	name;
    struct Language_Execute_ProcessDescriptor	*nextProcess;
    TLint4	dispatchPriority;
    TLnat4	waitParameter;
    struct Language_Execute_ConditionDescriptor	*waitCondition;
    struct Language_Execute_ProcessDescriptor	*nextTimeout;
    TLnat4	totalPause;
    struct Language_Execute_HandlerArea	*activeHandler;
    struct Language_Execute_HandlerArea	*runningHandler;
    Language_Step	stepSpec;
    TLaddressint	stepFP;
};
struct	Language_Execute_MonitorDescriptor {
    TLint2	entryParameter;
    TLint2	monitorPriority;
    struct Language_Execute_ProcessDescriptor	*entryHead;
    struct Language_Execute_ProcessDescriptor	*entryTail;
    TLaddressint	name;
    struct Language_Execute_ConditionDefinition	*firstCondition;
    struct Language_Execute_MonitorDescriptor	*nextMonitor;
    struct Language_Execute_MonitorDescriptor	*prevMonitor;
};
struct	Language_Execute_ConditionDescriptor {
    struct Language_Execute_ProcessDescriptor	*signalHead;
    struct Language_Execute_ProcessDescriptor	*signalTail;
    struct Language_Execute_MonitorDescriptor	*md;
};
typedef	struct Language_Execute_ConditionDescriptor	Language_Execute___x1960[65535];
struct	Language_Execute_ConditionDefinition {
    TLnat2	cdArraySize;
    Language_Execute___x1960	*cdArray;
    TLaddressint	name;
    struct Language_Execute_ConditionDefinition	*nextVariable;
};
struct Language_Execute_ProcessDescriptor	*Language_Execute_RQHead;
struct Language_Execute_ProcessDescriptor	*Language_Execute_EQHead;
TLnat4	Language_Execute_Chrono;
TLint4	Language_Execute_processCount;
TLaddressint	Language_Execute_globalPC;
TLaddressint	Language_Execute_globalSP;
typedef	Language_Opcode	Language_Execute___x1961[1];
Language_Execute___x1961	Language_Execute_nullRoutine = 
    {206};

void Language_Execute_RunSrcPosition (srcPos)
struct SrcPosition	*srcPos;
{
    TLSTKCHKSLF(100248);
    TLSETF();
    TLSETL(100248);
    if (Language_Execute_RQHead == ((struct Language_Execute_ProcessDescriptor *) 0)) {
	TLSETL(100249);
	TLSTRCTASS((*srcPos), Language_nullSrcPosition, struct SrcPosition);
    } else {
	TLSETL(100251);
	TLSTRCTASS((*srcPos), Language_Execute_RQHead->srcPos, struct SrcPosition);
    };
    TLRESTORELF();
}

void Language_Execute_SetErrno (errno, errMessage)
TLint4	errno;
TLaddressint	errMessage;
{
    TLBINDREG((*pd), struct Language_Execute_ProcessDescriptor);
    TLSTKCHKSLF(100260);
    TLSETF();
    TLSETL(100260);
    pd = &((*(Language_Execute_RQHead)));
    TLSETL(100262);
    (*pd).prevErrno = (*pd).errno;
    TLINCL();
    TLSTRASS(255, (*pd).prevErrMessage, (*pd).errMessage);
    TLINCL();
    (*pd).errno = errno;
    TLINCL();
    if ((unsigned long) errMessage == 0) {
	TLSETL(100266);
	TLSTRASS(255, (*pd).errMessage, "");
    } else {
	TLSETL(100268);
	TLSTRASS(255, (*pd).errMessage, (* (TLstring *) errMessage));
    };
    TLRESTORELF();
}

void Language_Execute_GetErrno (errno, prevErrno, errMessage, prevErrMessage)
TLint4	*errno;
TLint4	*prevErrno;
TLaddressint	*errMessage;
TLaddressint	*prevErrMessage;
{
    TLBINDREG((*pd), struct Language_Execute_ProcessDescriptor);
    TLSTKCHKSLF(100278);
    TLSETF();
    TLSETL(100278);
    pd = &((*(Language_Execute_RQHead)));
    TLINCL();
    (*errno) = (*pd).errno;
    TLINCL();
    (*errMessage) = (TLaddressint) ((unsigned long)(*pd).errMessage);
    TLINCL();
    (*prevErrno) = (*pd).prevErrno;
    TLINCL();
    (*prevErrMessage) = (TLaddressint) ((unsigned long)(*pd).prevErrMessage);
    TLRESTORELF();
}

static void Language_Execute_OpenFile (openMode, fileName, streamNo)
TLint2	openMode;
TLstring	fileName;
TLint4	*streamNo;
{
    TLstring	fullName;
    TLSTKCHKSLF(100289);
    TLSETF();
    TLSETL(100289);
    {
	TLchar	__x1965[6];
	{
	    TLchar	__x1964[10];
	    {
		TLchar	__x1963[9];
		if ((((TL_TLS_TLSLEN(fileName) >= 7) && ((TL_TLS_TLSBXX(__x1963, (TLint4) 7, (TLint4) 1, fileName), strcmp(__x1963, "%window") == 0))) || ((TL_TLS_TLSLEN(fileName) >= 8) && ((TL_TLS_TLSBXX(__x1964, (TLint4) 8, (TLint4) 1, fileName), strcmp(__x1964, "%printer") == 0)))) || ((TL_TLS_TLSLEN(fileName) >= 4) && ((TL_TLS_TLSBXX(__x1965, (TLint4) 4, (TLint4) 1, fileName), strcmp(__x1965, "%net") == 0)))) {
		    TLSETL(100292);
		    TLSTRASS(255, fullName, fileName);
		} else {
		    TLSETL(100294);
		    {
			TLstring	__x1966;
			FileManager_ExecPathName(fileName, __x1966);
			TLSTRASS(255, fullName, __x1966);
		    };
		};
	    };
	};
    };
    TLSETL(100301);
    TL_TLI_TLIOF((TLint2) openMode, fullName, &((*streamNo)));
    TLRESTORELF();
}

TLint4 Language_Execute_GetStackAllocated () {
    TLSTKCHKSLF(100305);
    TLSETF();
    TLSETL(100305);
    TLRESTORELF();
    return (Language_Execute_stackAllocated);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}
static TLint4	Language_Execute_failedOpenStream;
struct	Language_Execute___x1968 {
    TLint4	streamNo;
    TLstring	msg;
    struct SrcPosition	srcPos;
};
typedef	struct Language_Execute___x1968	Language_Execute___x1967[10];
static Language_Execute___x1967	Language_Execute_failedOpenInfo;

void Language_Execute_AddFile (fnum, mode)
TLint4	*fnum;
TLint4	mode;
{
    TLSTKCHKSLF(100318);
    TLSETF();
    TLSETL(100318);
    if ((*fnum) == 0) {
	TLint4	arrayPos;
	TLint4	errno;
	TLint4	prevErrno;
	TLaddressint	errMsg;
	TLaddressint	prevErrMsg;
	TLSETL(100327);
	(*fnum) = Language_Execute_failedOpenStream;
	TLINCL();
	Language_Execute_failedOpenStream -= 1;
	TLINCL();
	arrayPos = (( TLSIMPLEABS((*fnum))) % 10) + 1;
	TLINCL();
	Language_Execute_failedOpenInfo[TLINRANGELOW(arrayPos, 1, 10, 1)].streamNo = (*fnum);
	TLSETL(100334);
	Language_Execute_GetErrno(&(errno), &(prevErrno), &(errMsg), &(prevErrMsg));
	TLINCL();
	strcpy(Language_Execute_failedOpenInfo[TLINRANGELOW(arrayPos, 1, 10, 1)].msg, (* (TLstring *) errMsg));
	TLSETL(100337);
	Language_Execute_RunSrcPosition(&(Language_Execute_failedOpenInfo[TLINRANGELOW(arrayPos, 1, 10, 1)].srcPos));
	TLINCL();
	TLRESTORELF();
	return;
    };
    TLSETL(100340);
    if ((Language_Execute_numArguments + Language_Execute_numFilesOpen) == 20) {
	TLSETL(100341);
	TL_TLI_TLICL ((TLint4) (*fnum));
	TLINCL();
	(*fnum) = 0;
	TLSETL(100344);
	TLRESTORELF();
	return;
    };
    TLSETL(100346);
    {
	register TLint4	i;
	for (i = Language_Execute_numArguments + 1; i <= 20; i++) {
	    TLSETL(100347);
	    if ((Language_Execute_fileMap[TLINRANGELOW(i, -2, 20, 1)]) == -3) {
		TLSETL(100348);
		Language_Execute_fileMap[TLINRANGELOW(i, -2, 20, 1)] = (*fnum);
		TLINCL();
		(*fnum) = i;
		TLINCL();
		Language_Execute_numFilesOpen += 1;
		TLSETL(100355);
		MIO_RegisterOpen((TLint4) (*fnum), (TLint4) mode);
		TLINCL();
		TLRESTORELF();
		return;
	    };
	};
    };
    TLSETL(100358);
    TLASSERT (0);
    TLRESTORELF();
}

static void Language_Execute_BadStreamAbortMessage (streamNumber, op)
TLint4	streamNumber;
TLstring	op;
{
    TLint4	arrayPos;
    struct SrcPosition	srcPos;
    TLint4	failedOpenLineNo;
    TLint4	failedOpenFileNo;
    TLstring	failedOpenMsg;
    TLSTKCHKSLF(100365);
    TLSETF();
    TLSETL(100365);
    if ((streamNumber <= Language_Execute_failedOpenStream) || (((- 10) < streamNumber) && (streamNumber < (- 2)))) {
	TLSETL(100372);
	{
	    TLstring	__x1972;
	    TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x1972);
	    {
		TLstring	__x1971;
		TL_TLS_TLSCAT(op, " attempted on illegal stream number ", __x1971);
		{
		    TLstring	__x1970;
		    TL_TLS_TLSCAT(__x1971, __x1972, __x1970);
		    Language_Execute_ExecutionError_Abort((TLint4) 10000, __x1970);
		};
	    };
	};
    };
    TLSETL(100377);
    arrayPos = (( TLSIMPLEABS(streamNumber)) % 10) + 1;
    TLINCL();
    if (TL_TLI_TLIXSN != (Language_Execute_failedOpenInfo[TLINRANGELOW(arrayPos, 1, 10, 1)].streamNo)) {
	TLSETL(100387);
	{
	    TLstring	__x1976;
	    TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x1976);
	    {
		TLstring	__x1975;
		TL_TLS_TLSCAT(op, " attempted on unopened stream number ", __x1975);
		{
		    TLstring	__x1974;
		    TL_TLS_TLSCAT(__x1975, __x1976, __x1974);
		    {
			TLstring	__x1973;
			TL_TLS_TLSCAT(__x1974, ". Previous open statement failed", __x1973);
			Language_Execute_ExecutionError_Abort((TLint4) 10000, __x1973);
		    };
		};
	    };
	};
    };
    TLSETL(100392);
    failedOpenLineNo = Language_Execute_failedOpenInfo[TLINRANGELOW(arrayPos, 1, 10, 1)].srcPos.lineNo;
    TLSETL(100394);
    failedOpenFileNo = Language_Execute_failedOpenInfo[TLINRANGELOW(arrayPos, 1, 10, 1)].srcPos.fileNo;
    TLSETL(100396);
    TLSTRASS(255, failedOpenMsg, Language_Execute_failedOpenInfo[TLINRANGELOW(arrayPos, 1, 10, 1)].msg);
    TLSETL(100399);
    Language_Execute_RunSrcPosition(&(srcPos));
    if ((srcPos.fileNo) != failedOpenFileNo) {
	TLSETL(100409);
	{
	    TLstring	__x1988;
	    FileManager_FileName((FileManager_FileNoType) failedOpenFileNo, __x1988);
	    {
		TLstring	__x1987;
		TL_TLS_TLSVIS((TLint4) failedOpenLineNo, (TLint4) 1, (TLint4) 10, __x1987);
		{
		    TLstring	__x1986;
		    TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x1986);
		    {
			TLstring	__x1985;
			TL_TLS_TLSCAT(op, " attempted on unopened stream number ", __x1985);
			{
			    TLstring	__x1984;
			    TL_TLS_TLSCAT(__x1985, __x1986, __x1984);
			    {
				TLstring	__x1983;
				TL_TLS_TLSCAT(__x1984, ". Open on line ", __x1983);
				{
				    TLstring	__x1982;
				    TL_TLS_TLSCAT(__x1983, __x1987, __x1982);
				    {
					TLstring	__x1981;
					TL_TLS_TLSCAT(__x1982, " of ", __x1981);
					{
					    TLstring	__x1980;
					    TL_TLS_TLSCAT(__x1981, __x1988, __x1980);
					    {
						TLstring	__x1979;
						TL_TLS_TLSCAT(__x1980, "failed with message \'", __x1979);
						{
						    TLstring	__x1978;
						    TL_TLS_TLSCAT(__x1979, failedOpenMsg, __x1978);
						    {
							TLstring	__x1977;
							TL_TLS_TLSCAT(__x1978, "\'", __x1977);
							Language_Execute_ExecutionError_Abort((TLint4) 10000, __x1977);
						    };
						};
					    };
					};
				    };
				};
			    };
			};
		    };
		};
	    };
	};
    };
    TLSETL(100413);
    if ((((srcPos.lineNo) - failedOpenLineNo) <= 3) && ((srcPos.lineNo) >= failedOpenLineNo)) {
	TLSETL(100422);
	{
	    TLstring	__x1994;
	    TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x1994);
	    {
		TLstring	__x1993;
		TL_TLS_TLSCAT(op, " attempted on unopened stream number ", __x1993);
		{
		    TLstring	__x1992;
		    TL_TLS_TLSCAT(__x1993, __x1994, __x1992);
		    {
			TLstring	__x1991;
			TL_TLS_TLSCAT(__x1992, ". Open failed with message \'", __x1991);
			{
			    TLstring	__x1990;
			    TL_TLS_TLSCAT(__x1991, failedOpenMsg, __x1990);
			    {
				TLstring	__x1989;
				TL_TLS_TLSCAT(__x1990, "\'", __x1989);
				Language_Execute_ExecutionError_Abort((TLint4) 10000, __x1989);
			    };
			};
		    };
		};
	    };
	};
    };
    TLSETL(100437);
    {
	TLstring	__x2003;
	TL_TLS_TLSVIS((TLint4) failedOpenLineNo, (TLint4) 1, (TLint4) 10, __x2003);
	{
	    TLstring	__x2002;
	    TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x2002);
	    {
		TLstring	__x2001;
		TL_TLS_TLSCAT(op, " attempted on unopened stream number ", __x2001);
		{
		    TLstring	__x2000;
		    TL_TLS_TLSCAT(__x2001, __x2002, __x2000);
		    {
			TLstring	__x1999;
			TL_TLS_TLSCAT(__x2000, ". Open on line ", __x1999);
			{
			    TLstring	__x1998;
			    TL_TLS_TLSCAT(__x1999, __x2003, __x1998);
			    {
				TLstring	__x1997;
				TL_TLS_TLSCAT(__x1998, " failed with message \'", __x1997);
				{
				    TLstring	__x1996;
				    TL_TLS_TLSCAT(__x1997, failedOpenMsg, __x1996);
				    {
					TLstring	__x1995;
					TL_TLS_TLSCAT(__x1996, "\'", __x1995);
					Language_Execute_ExecutionError_Abort((TLint4) 10000, __x1995);
				    };
				};
			    };
			};
		    };
		};
	    };
	};
    };
    TLRESTORELF();
}

static void Language_Execute_CloseArguments () {
    TLSTKCHKSLF(100441);
    TLSETF();
    TLSETL(100441);
    {
	register TLint4	i;
	TLint4	__x2004;
	__x2004 = Language_Execute_numArguments;
	i = 1;
	if (i <= __x2004) {
	    for(;;) {
		TLSETL(100442);
		if ((Language_Execute_argumentNames[TLINRANGELOW(i, 0, 20, 1)]) != ((Language_StringDef *) 0)) {
		    TLSETL(100443);
		    TL_TLB_TLBFRU(& Language_Execute_argumentNames[TLINRANGELOW(i, 0, 20, 1)], (TLint4)  sizeof (		    Language_StringDef));
		    TLINCL();
		    Language_Execute_argumentNames[TLINRANGELOW(i, 0, 20, 1)] = (Language_StringDef *) 0;
		};
		if (i == __x2004) break;
		i++;
	    }
	};
    };
    TLSETL(100447);
    Language_Execute_numArguments = 0;
    TLRESTORELF();
}

void Language_Execute_CloseFile (fnum)
register TLint4	fnum;
{
    TLSTKCHKSLF(100452);
    TLSETF();
    TLSETL(100452);
    TL_TLI_TLIXSN = fnum;
    TLINCL();
    if (fnum < (- 2)) {
	TLSETL(100455);
	Language_Execute_BadStreamAbortMessage((TLint4) fnum, "Close");
    } else {
	TLSETL(100455);
	if (fnum > 20) {
	    TLSETL(100458);
	    {
		TLstring	__x2006;
		TL_TLS_TLSVIS((TLint4) fnum, (TLint4) 1, (TLint4) 10, __x2006);
		{
		    TLstring	__x2005;
		    TL_TLS_TLSCAT("Close of illegal stream number ", __x2006, __x2005);
		    Language_Execute_ExecutionError_Abort((TLint4) 10000, __x2005);
		};
	    };
	} else {
	    TLSETL(100458);
	    if ((Language_Execute_fileMap[TLINRANGELOW(fnum, -2, 20, 1)]) == -3) {
		TLSETL(100461);
		{
		    TLstring	__x2008;
		    TL_TLS_TLSVIS((TLint4) fnum, (TLint4) 1, (TLint4) 10, __x2008);
		    {
			TLstring	__x2007;
			TL_TLS_TLSCAT("Close of closed stream number ", __x2008, __x2007);
			Language_Execute_ExecutionError_Abort((TLint4) 10000, __x2007);
		    };
		};
	    };
	};
    };
    TLSETL(100463);
    TL_TLI_TLICL ((TLint4) (Language_Execute_fileMap[TLINRANGELOW(fnum, -2, 20, 1)]));
    TLSETL(100468);
    MIO_RegisterClose((TLint4) fnum);
    Language_Execute_fileMap[TLINRANGELOW(fnum, -2, 20, 1)] = -3;
    TLSETL(100470);
    if (fnum > Language_Execute_numArguments) {
	TLSETL(100471);
	Language_Execute_numFilesOpen -= 1;
    };
    TLRESTORELF();
}

static void Language_Execute_CloseAllFiles () {
    TLSTKCHKSLF(100477);
    TLSETF();
    TLSETL(100477);
    if ((Language_Execute_fileMap[0]) != -2) {
	TLSETL(100478);
	TL_TLI_TLICL ((TLint4) (Language_Execute_fileMap[0]));
	TLINCL();
	Language_Execute_fileMap[0] = -2;
    };
    TLSETL(100481);
    if ((Language_Execute_fileMap[1]) != -1) {
	TLSETL(100482);
	TL_TLI_TLICL ((TLint4) (Language_Execute_fileMap[1]));
	TLINCL();
	Language_Execute_fileMap[1] = -1;
	TLINCL();
	Language_Execute_fileMap[2] = -1;
    };
    TLSETL(100486);
    {
	register TLint4	i;
	for (i = 1; i <= 20; i++) {
	    TLSETL(100487);
	    if ((Language_Execute_fileMap[TLINRANGELOW(i, -2, 20, 1)]) != -3) {
		TLSETL(100488);
		TL_TLI_TLICL ((TLint4) (Language_Execute_fileMap[TLINRANGELOW(i, -2, 20, 1)]));
		TLSETL(100493);
		MIO_RegisterClose((TLint4) i);
		Language_Execute_fileMap[TLINRANGELOW(i, -2, 20, 1)] = -3;
	    };
	};
    };
    TLSETL(100496);
    Language_Execute_numFilesOpen = 0;
    TLRESTORELF();
}

static void Language_Execute_OpenArgumentFile (mode, abort)
Language_StreamModeSet	mode;
TLboolean	abort;
{
    TLint4	f;
    TLSTKCHKSLF(100501);
    TLSETF();
    TLSETL(100501);
    TLPRE (((TL_TLI_TLIXSN > 0) && (TL_TLI_TLIXSN <= Language_Execute_numArguments)) && ((Language_Execute_fileMap[TLINRANGELOW(TL_TLI_TLIXSN, -2, 20, 1)]) == -3));
    TLSETL(100505);
    if ((Language_Execute_argumentNames[TLINRANGELOW(TL_TLI_TLIXSN, 0, 20, 1)]) == ((Language_StringDef *) 0)) {
	TLSETL(100508);
	{
	    TLstring	__x2011;
	    TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x2011);
	    {
		TLstring	__x2010;
		TL_TLS_TLSCAT("Open argument ", __x2011, __x2010);
		{
		    TLstring	__x2009;
		    TL_TLS_TLSCAT(__x2010, " does not exist", __x2009);
		    Language_Execute_ExecutionError_Abort((TLint4) 10000, __x2009);
		};
	    };
	};
    };
    TLSETL(100513);
    Language_Execute_OpenFile((TLint2) (* (TLnat1 *) &mode), (*(Language_Execute_argumentNames[TLINRANGELOW(TL_TLI_TLIXSN, 0, 20, 1)])), &(f));
    if (f == 0) {
	TLSETL(100514);
	if (abort) {
	    TLSETL(100518);
	    {
		TLstring	__x2013;
		TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x2013);
		{
		    TLstring	__x2012;
		    TL_TLS_TLSCAT("Cannot open argument file number ", __x2013, __x2012);
		    Language_Execute_ExecutionError_Abort((TLint4) 10000, __x2012);
		};
	    };
	} else {
	    TLSETL(100519);
	    TL_TLI_TLIXSN = 0;
	};
    } else {
	TLSETL(100522);
	Language_Execute_fileMap[TLINRANGELOW(TL_TLI_TLIXSN, -2, 20, 1)] = f;
    };
    TLRESTORELF();
}

void Language_Execute_SetActive (stream)
TLint4	*stream;
{
    TLint4	fd;
    TLSTKCHKSLF(100530);
    TLSETF();
    TLSETL(100530);
    fd = -1;
    TLINCL();
    if ((*stream) != 0) {
	TLSETL(100532);
	if ((Language_Execute_fileMap[TLINRANGELOW((*stream), -2, 20, 1)]) != -3) {
	    TLSETL(100533);
	    fd = Language_Execute_fileMap[TLINRANGELOW((*stream), -2, 20, 1)];
	} else {
	    TLSETL(100535);
	    (*stream) = 0;
	};
    };
    TLSETL(100538);
    if (MIO_SetActive((TLaddressint) TL_TLI_TLIGF((TLint4) fd))) {
	TLboolean	dummy;
	TLSETL(100540);
	dummy = MIO_SetActive((TLaddressint) TL_TLI_TLIGF((TLint4) -1));
    };
    TLRESTORELF();
}
TLaddressint	Language_Execute_savedInitPC;
TLaddressint	Language_Execute_savedInitFP;

void Language_Execute_UnitInitState (pc, fp)
TLaddressint	*pc;
TLaddressint	*fp;
{
    TLSTKCHKSLF(100551);
    TLSETF();
    TLSETL(100551);
    if ((unsigned long) Language_Execute_savedInitPC == 0) {
	TLSETL(100552);
	(*pc) = (TLaddressint) Language_Execute_globalPC;
	TLINCL();
	if (Language_Execute_RQHead == ((struct Language_Execute_ProcessDescriptor *) 0)) {
	    TLSETL(100554);
	    (*fp) = (TLaddressint) 0;
	} else {
	    TLSETL(100556);
	    (*fp) = (TLaddressint) (Language_Execute_RQHead->fp);
	};
    } else {
	TLSETL(100559);
	(*pc) = (TLaddressint) Language_Execute_savedInitPC;
	TLINCL();
	(*fp) = (TLaddressint) Language_Execute_savedInitFP;
    };
    TLRESTORELF();
}

void Language_Execute_DumpStack (pd)
register struct Language_Execute_ProcessDescriptor	*pd;
{
    TLaddressint	pc;
    register TLaddressint	fp;
    TLstring	routineName;
    struct SrcPosition	srcPos;
    struct Cookie	cookie;
    TLSTKCHKSLF(100570);
    TLSETF();
    TLSETL(100570);
    TLASSERT (pd != ((struct Language_Execute_ProcessDescriptor *) 0));
    TLINCL();
    pc = (TLaddressint) (pd->pc);
    TLINCL();
    fp = (TLaddressint) (pd->fp);
    TLSETL(100574);
    TLSTRCTASS(srcPos, Language_nullSrcPosition, struct SrcPosition);
    TLSETL(100579);
    Language_DebugModule_NewThread((TLaddressint) ((TLnat4) pd), (TLaddressint) (pd->name));
    TLINCL();
    Language_Compile_CallInfo((TLaddressint) pc, (TLaddressint) fp, routineName, &(cookie));
    TLSETL(100582);
    Language_DebugModule_NewCall(routineName, &(pd->srcPos), &(cookie));
    if (((cookie.kind) == 0) || ((unsigned long) fp == 0)) {
	TLSETL(100584);
	TLRESTORELF();
	return;
    };
    TLSETL(100587);
    for(;;) {
	TLSETL(100587);
	if ((unsigned long) ((* (TLaddressint *) fp)) == 0) {
	    break;
	};
	TLSETL(100588);
	srcPos.lineNo = (* (TLnat2 *) (((unsigned long) fp + 4) + 2));
	TLINCL();
	srcPos.fileNo = (* (TLnat2 *) ((unsigned long) fp + 4));
	TLINCL();
	pc = (TLaddressint) ((* (TLaddressint *) (((unsigned long) fp + 4) + (2 * 2))));
	TLINCL();
	fp = (TLaddressint) ((* (TLaddressint *) fp));
	TLSETL(100593);
	Language_Compile_CallInfo((TLaddressint) pc, (TLaddressint) fp, routineName, &(cookie));
	TLINCL();
	Language_DebugModule_NewCall(routineName, &(srcPos), &(cookie));
	if ((cookie.kind) == 0) {
	    TLSETL(100596);
	    TLRESTORELF();
	    return;
	};
    };
    TLSETL(100598);
    if (((* (TLnat2 *) (((unsigned long) fp + 4) + 2))) != 0) {
	TLSETL(100600);
	srcPos.lineNo = (* (TLnat2 *) (((unsigned long) fp + 4) + 2));
	TLINCL();
	srcPos.fileNo = (* (TLnat2 *) ((unsigned long) fp + 4));
	TLINCL();
	pc = (TLaddressint) ((* (TLaddressint *) (((unsigned long) fp + 4) + (2 * 2))));
	TLSETL(100604);
	Language_Compile_CallInfo((TLaddressint) pc, (TLaddressint) 0, routineName, &(cookie));
	TLINCL();
	Language_DebugModule_NewCall(routineName, &(srcPos), &(cookie));
    };
    TLRESTORELF();
}

extern TLboolean Language_Execute_Kernel_ConditionEmpty ();

extern TLnat4 Language_Execute_Kernel_GetProcessPriority ();

extern void Language_Execute_Kernel_Initialize ();

extern void Language_Execute_Kernel_InitializeCondition ();

extern void Language_Execute_Kernel_MonitorEnter ();

extern void Language_Execute_Kernel_MonitorExit ();

extern void Language_Execute_Kernel_MonitorFree ();

extern void Language_Execute_Kernel_MonitorInitialize ();

extern void Language_Execute_Kernel_Pause ();

extern void Language_Execute_Kernel_RunQueueDispatch ();

extern void Language_Execute_Kernel_RunQueueInsert ();

extern void Language_Execute_Kernel_SetProcessPriority ();

extern void Language_Execute_Kernel_SignalDeferredCondition ();

extern void Language_Execute_Kernel_SignalPriorityCondition ();

extern void Language_Execute_Kernel_SignalRegularCondition ();

extern void Language_Execute_Kernel_SignalTimeoutCondition ();

extern void Language_Execute_Kernel_TimeSlice ();

extern void Language_Execute_Kernel_WaitDeferredCondition ();

extern void Language_Execute_Kernel_WaitPriorityCondition ();

extern void Language_Execute_Kernel_WaitRegularCondition ();

extern void Language_Execute_Kernel_WaitTimeoutCondition ();

extern void Language_Execute_Kernel_DumpThreadList ();

void Language_Execute_DumpThreadList (firstThreadQueue)
struct ThreadQueueDef	**firstThreadQueue;
{
    TLSTKCHKSLF(100619);
    TLSETF();
    TLSETL(100619);
    Language_DebugModule_Initialize();
    TLINCL();
    Language_Execute_Kernel_DumpThreadList();
    TLINCL();
    Language_DebugModule_ReturnThreadDump(&((*firstThreadQueue)));
    TLRESTORELF();
}

TLboolean Language_Execute_HasEvent (stream, event)
TLint4	stream;
struct MIO_EventDescriptor	*event;
{
    TLint4	fileStream;
    TLSTKCHKSLF(100629);
    TLSETF();
    TLSETL(100629);
    fileStream = Language_Execute_fileMap[TLINRANGELOW(stream, -2, 20, 1)];
    TLINCL();
    if (fileStream == -3) {
	TLSETL(100632);
	TLRESTORELF();
	return (1);
    } else {
	TLSETL(100634);
	TLRESTORELF();
	return (MIO_HasEvent((TLaddressint) TL_TLI_TLIGF((TLint4) fileStream), &((*event))));
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

void Language_Execute_EventQueueInsert (stream, event)
TLint4	stream;
struct MIO_EventDescriptor	*event;
{
    register struct Language_Execute_ProcessDescriptor	*pd;
    TLSTKCHKSLF(100642);
    TLSETF();
    TLSETL(100642);
    pd = Language_Execute_RQHead;
    TLINCL();
    pd->pendingEvent.stream = stream;
    TLINCL();
    TLSTRCTASS(pd->pendingEvent.event, (*event), struct MIO_EventDescriptor);
    TLINCL();
    Language_Execute_RQHead = pd->nextProcess;
    TLINCL();
    pd->nextProcess = Language_Execute_EQHead;
    TLINCL();
    Language_Execute_EQHead = pd;
    TLSETL(100649);
    Language_Execute_Kernel_RunQueueDispatch();
    TLRESTORELF();
}

static void Language_Execute_EventQueueDispatch () {
    struct Language_Execute_ProcessDescriptor	*pd;
    struct Language_Execute_ProcessDescriptor	*lastPD;
    TLSTKCHKSLF(100653);
    TLSETF();
    TLSETL(100653);
    pd = Language_Execute_EQHead;
    TLINCL();
    lastPD = (struct Language_Execute_ProcessDescriptor *) 0;
    TLINCL();
    Language_Execute_allWaitingForKeyboard = 1;
    TLINCL();
    Language_Execute_allWaitingForMouse = 1;
    TLINCL();
    Language_Execute_allWaitingForDelay = 1;
    TLINCL();
    Language_Execute_minimumDelayCount = 2000000000;
    TLSETL(100660);
    for(;;) {
	TLSETL(100660);
	if (pd == ((struct Language_Execute_ProcessDescriptor *) 0)) {
	    break;
	};
	TLSETL(100661);
	if (Language_Execute_HasEvent((TLint4) (pd->pendingEvent.stream), &(pd->pendingEvent.event))) {
	    TLSETL(100663);
	    if (lastPD == ((struct Language_Execute_ProcessDescriptor *) 0)) {
		TLSETL(100664);
		Language_Execute_EQHead = pd->nextProcess;
		TLSETL(100666);
		Language_Execute_Kernel_RunQueueInsert(pd);
		pd = Language_Execute_EQHead;
	    } else {
		TLSETL(100668);
		lastPD->nextProcess = pd->nextProcess;
		TLSETL(100670);
		Language_Execute_Kernel_RunQueueInsert(pd);
		pd = lastPD->nextProcess;
	    };
	} else {
	    TLnat1	mode;
	    TLSETL(100673);
	    mode = pd->pendingEvent.event.mode;
	    TLSETL(100676);
	    if ((((mode != 0) && (mode != 1)) && (mode != 2)) && (mode != 3)) {
		TLSETL(100680);
		Language_Execute_allWaitingForKeyboard = 0;
		TLINCL();
		if (mode != 6) {
		    TLSETL(100682);
		    Language_Execute_allWaitingForMouse = 0;
		    TLINCL();
		    if (((mode != 5) && (mode != 7)) && (mode != 8)) {
			TLSETL(100686);
			Language_Execute_allWaitingForDelay = 0;
		    } else {
			TLSETL(100689);
			if (mode == 99) {
			    TLSETL(100690);
			    Language_Execute_minimumDelayCount =  TL_TLA_TLAIMN((TLint4) Language_Execute_minimumDelayCount, (TLint4) ((* (TLint4 *) (pd->pendingEvent.event.count))));
			} else {
			    TLSETL(100693);
			    Language_Execute_minimumDelayCount =  TLSIMPLEMIN(Language_Execute_minimumDelayCount, (pd->pendingEvent.event.count));
			};
		    };
		};
	    };
	    TLSETL(100700);
	    lastPD = pd;
	    TLINCL();
	    pd = pd->nextProcess;
	};
    };
    TLRESTORELF();
}

TLboolean Language_Execute_Strintok (str, base)
TLstring	str;
TLint4	base;
{
    TLboolean	__x1681;
    struct TLHAREA	quitCode;
    TLSTKCHKSLF(100708);
    if (TLHANDENTER(quitCode)) {
	TLSETF();
	TLSETL(100708);
	{
	    __x1681 = 0;
	    TLRESTORELF();
	    return (__x1681);
	};
    } else {
	TLint4	dummy;
	TLSETF();
	TLSETL(100712);
	dummy = TL_TLS_TLSVSI(str, (TLint4) base);
	TLINCL();
	{
	    __x1681 = 1;
	    TL_TLE_TLEHX();
	    TLRESTORELF();
	    return (__x1681);
	};
	TL_TLE_TLEHX();
    }
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

TLboolean Language_Execute_Strnatok (str, base)
TLstring	str;
TLint4	base;
{
    TLboolean	__x1686;
    struct TLHAREA	quitCode;
    TLSTKCHKSLF(100719);
    if (TLHANDENTER(quitCode)) {
	TLSETF();
	TLSETL(100719);
	{
	    __x1686 = 0;
	    TLRESTORELF();
	    return (__x1686);
	};
    } else {
	TLnat4	dummy;
	TLSETF();
	TLSETL(100723);
	dummy = TL_TLS_TLSVSN(str, (TLint4) base);
	TLINCL();
	{
	    __x1686 = 1;
	    TL_TLE_TLEHX();
	    TLRESTORELF();
	    return (__x1686);
	};
	TL_TLE_TLEHX();
    }
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

void Language_Execute_Open () {
    Language_OpenKind	oKind;
    Language_StreamModeSet	oMode;
    TLSTKCHKSLF(100729);
    TLSETF();
    TLSETL(100729);
    TLASSERT (sizeof(Language_OpenKind) == 1);
    TLINCL();
    oKind = (* (Language_OpenKind *) Language_Execute_globalPC);
    TLINCL();
    Language_Execute_globalPC += Language_codeInt1Size;
    TLINCL();
    TLASSERT (sizeof(Language_StreamModeSet) == 1);
    TLINCL();
    oMode = (* (Language_StreamModeSet *) Language_Execute_globalPC);
    TLINCL();
    Language_Execute_globalPC += Language_codeInt1Size;
    TLSETL(100740);
    switch (oKind) {
	case 0:
	    {
		TLSETL(100744);
		TL_TLI_TLIOP (((* (TLstring *) ((* (TLaddressint *) Language_Execute_globalSP)))), ((* (TLstring *) ((* (TLaddressint *) ((unsigned long) Language_Execute_globalSP + 4))))), &((* (TLint4 *) ((* (TLaddressint *) ((unsigned long) Language_Execute_globalSP + (2 * 4)))))));
		TLSETL(100748);
		Language_Execute_AddFile(&((* (TLint4 *) ((* (TLaddressint *) ((unsigned long) Language_Execute_globalSP + (2 * 4)))))), (TLint4) 0);
		Language_Execute_globalSP += 12;
	    }
	    break;
	case 1:
	    {
		TLSETL(100755);
		Language_Execute_OpenFile((TLint2) (* (TLnat1 *) &oMode), (* (TLstring *) ((* (TLaddressint *) Language_Execute_globalSP))), &((* (TLint4 *) ((* (TLaddressint *) ((unsigned long) Language_Execute_globalSP + 4))))));
		TLINCL();
		Language_Execute_AddFile(&((* (TLint4 *) ((* (TLaddressint *) ((unsigned long) Language_Execute_globalSP + 4))))), (TLint4) (* (TLnat1 *) &oMode));
		Language_Execute_globalSP += 8;
	    }
	    break;
	case 2:
	    {
		TLSETL(100760);
		TL_TLI_TLIXSN = (* (TLint4 *) Language_Execute_globalSP);
		TLINCL();
		if ((TL_TLI_TLIXSN <= 0) || (TL_TLI_TLIXSN > Language_Execute_numArguments)) {
		    TLSETL(100765);
		    {
			TLstring	__x2043;
			TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x2043);
			{
			    TLstring	__x2042;
			    TL_TLS_TLSCAT("Open argument ", __x2043, __x2042);
			    {
				TLstring	__x2041;
				TL_TLS_TLSCAT(__x2042, " does not exist", __x2041);
				Language_Execute_ExecutionError_Abort((TLint4) 10000, __x2041);
			    };
			};
		    };
		};
		TLSETL(100766);
		if ((Language_Execute_fileMap[TLINRANGELOW(TL_TLI_TLIXSN, -2, 20, 1)]) != -3) {
		    TLSETL(100769);
		    {
			TLstring	__x2046;
			TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x2046);
			{
			    TLstring	__x2045;
			    TL_TLS_TLSCAT("Open argument ", __x2046, __x2045);
			    {
				TLstring	__x2044;
				TL_TLS_TLSCAT(__x2045, " is already open", __x2044);
				Language_Execute_ExecutionError_Abort((TLint4) 10000, __x2044);
			    };
			};
		    };
		};
		TLSETL(100771);
		Language_Execute_OpenArgumentFile((Language_StreamModeSet) oMode, (TLboolean) 0);
		(* (TLint4 *) ((* (TLaddressint *) ((unsigned long) Language_Execute_globalSP + 4)))) = TL_TLI_TLIXSN;
		TLINCL();
		Language_Execute_globalSP += 8;
	    }
	    break;
	default:
	    TLCASEABORT;
    };
    TLRESTORELF();
}

void Language_Execute_Put () {
    Language_PutKind	pKind;
    TLint4	stream;
    TLSTKCHKSLF(100778);
    TLSETF();
    TLSETL(100778);
    TLASSERT (sizeof(Language_PutKind) == 1);
    TLINCL();
    pKind = (* (Language_PutKind *) Language_Execute_globalPC);
    TLINCL();
    Language_Execute_globalPC += Language_codeInt1Size;
    TLSETL(100782);
    TL_TLI_TLIXSN = (* (TLint4 *) ((* (TLaddressint *) Language_Execute_globalSP)));
    TLINCL();
    Language_Execute_globalSP += 4;
    TLINCL();
    stream = Language_Execute_fileMap[TLINRANGELOW(TL_TLI_TLIXSN, -2, 20, 1)];
    TLINCL();
    if (stream == -3) {
	TLSETL(100789);
	{
	    TLstring	__x2053;
	    TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x2053);
	    {
		TLstring	__x2052;
		TL_TLS_TLSCAT("I/O attempted on closed stream ", __x2053, __x2052);
		Language_Execute_ExecutionError_Abort((TLint4) 10000, __x2052);
	    };
	};
    };
    TLSETL(100791);
    switch (pKind) {
	case 0:
	    {
		TLSETL(100793);
		if (((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4))) != 0) {
		    TLSETL(100794);
		    TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		    TL_TLI_TLIPS ((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), "true", (TLint2) stream);
		} else {
		    TLSETL(100796);
		    TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		    TL_TLI_TLIPS ((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), "false", (TLint2) stream);
		};
		TLSETL(100798);
		Language_Execute_globalSP += 8;
	    }
	    break;
	case 1:
	    {
		TLSETL(100801);
		{
		    TLchar	__x2058[1];
		    TLCHRTOCHARS(((TLchar) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4)))), __x2058);
		    TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		    TL_TLI_TLIPC ((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), __x2058, (TLint4) 1, (TLint2) stream);
		};
		TLINCL();
		Language_Execute_globalSP += 8;
	    }
	    break;
	case 2:
	    {
		TLSETL(100811);
		TL_TLI_TLISS((TLint4) stream, (TLint2) 2);
		TLSETL(100814);
		TL_TLI_TLIPC((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), (TLaddressint) ((* (TLaddressint *) ((unsigned long) Language_Execute_globalSP + (2 * 4)))), (TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4))), (TLint2) stream);
		Language_Execute_globalSP += 12;
	    }
	    break;
	case 3:
	    {
		TLint4	value;
		register TLaddressint	ptr;
		TLSETL(100818);
		value = (* (TLint4 *) (((unsigned long) Language_Execute_globalSP + 4) + 4));
		TLINCL();
		ptr = (TLaddressint) ((* (TLaddressint *) Language_Execute_globalSP));
		TLINCL();
		if ((value >= 0) && (value < ((* (TLint4 *) ptr)))) {
		    TLSETL(100821);
		    ptr += 4;
		    TLINCL();
		    {
			register TLint4	__x1695;
			TLint4	__x2066;
			__x2066 = value;
			__x1695 = 1;
			if (__x1695 <= __x2066) {
			    for(;;) {
				TLSETL(100824);
				for(;;) {
				    TLSETL(100824);
				    ptr += 1;
				    TLINCL();
				    if (((* (TLchar *) ptr)) == '\0') {
					break;
				    };
				};
				TLSETL(100828);
				for(;;) {
				    TLSETL(100828);
				    ptr += 1;
				    TLINCL();
				    if (((* (TLchar *) ptr)) != '\0') {
					break;
				    };
				};
				if (__x1695 == __x2066) break;
				__x1695++;
			    }
			};
		    };
		    TLSETL(100832);
		    TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		    TL_TLI_TLIPS ((TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4))), ((* (TLstring *) ptr)), (TLint2) stream);
		} else {
		    TLSETL(100834);
		    TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		    TL_TLI_TLIPI ((TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4))), (TLint4) value, (TLint2) stream);
		};
		TLSETL(100836);
		Language_Execute_globalSP += 12;
	    }
	    break;
	case 4:
	    {
		TLSETL(100839);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		TL_TLI_TLIPI ((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), (TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4))), (TLint2) stream);
		TLINCL();
		Language_Execute_globalSP += 8;
	    }
	    break;
	case 5:
	    {
		TLSETL(100843);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		TL_TLI_TLIPF ((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), (TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4))), ((TLreal8) (TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + (2 * 4))))), (TLint2) stream);
		TLSETL(100845);
		Language_Execute_globalSP += 12;
	    }
	    break;
	case 6:
	    {
		TLSETL(100848);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		TL_TLI_TLIPE ((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), (TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4))), (TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + (2 * 4)))), ((TLreal8) (TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + (3 * 4))))), (TLint2) stream);
		TLSETL(100851);
		Language_Execute_globalSP += 16;
	    }
	    break;
	case 7:
	    {
		TLSETL(100854);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		TL_TLI_TLIPN ((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), (TLnat4) ((* (TLnat4 *) ((unsigned long) Language_Execute_globalSP + 4))), (TLint2) stream);
		TLINCL();
		Language_Execute_globalSP += 8;
	    }
	    break;
	case 8:
	    {
		TLSETL(100858);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		TL_TLI_TLIPN ((TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4))), (TLnat4) ((* (TLnat4 *) ((unsigned long) Language_Execute_globalSP + (2 * 4)))), (TLint2) stream);
		TLSETL(100860);
		Language_Execute_globalSP += 12;
	    }
	    break;
	case 9:
	    {
		TLSETL(100863);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		TL_TLI_TLIPN ((TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + (2 * 4)))), (TLnat4) ((* (TLnat4 *) ((unsigned long) Language_Execute_globalSP + (3 * 4)))), (TLint2) stream);
		TLSETL(100866);
		Language_Execute_globalSP += 16;
	    }
	    break;
	case 10:
	    {
		TLSETL(100869);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		TL_TLI_TLIPR ((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), (TLreal8) ((* (TLreal8 *) ((unsigned long) Language_Execute_globalSP + 4))), (TLint2) stream);
		TLINCL();
		Language_Execute_globalSP += 12;
	    }
	    break;
	case 11:
	    {
		TLSETL(100873);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		TL_TLI_TLIPF ((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), (TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4))), (TLreal8) ((* (TLreal8 *) ((unsigned long) Language_Execute_globalSP + (2 * 4)))), (TLint2) stream);
		TLSETL(100875);
		Language_Execute_globalSP += 16;
	    }
	    break;
	case 12:
	    {
		TLSETL(100878);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		TL_TLI_TLIPE ((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), (TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4))), (TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + (2 * 4)))), (TLreal8) ((* (TLreal8 *) ((unsigned long) Language_Execute_globalSP + (3 * 4)))), (TLint2) stream);
		TLSETL(100881);
		Language_Execute_globalSP += 20;
	    }
	    break;
	case 13:
	    {
		TLSETL(100884);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		TL_TLI_TLIPS ((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), ((* (TLstring *) ((* (TLaddressint *) ((unsigned long) Language_Execute_globalSP + 4))))), (TLint2) stream);
		TLSETL(100886);
		Language_Execute_globalSP += 8;
	    }
	    break;
	case 14:
	    {
		TLSETL(100889);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		TL_TLI_TLIPS ((TLint4) 0, "", (TLint2) stream);
		TL_TLI_TLIPK ((TLint2) stream);
	    }
	    break;
	default:
	    TLCASEABORT;
    };
    TLSETL(100892);
    Language_Execute_executionTimeout -= 500;
    TLRESTORELF();
}

void Language_Execute_Get () {
    TLaddressint	startPC;
    TLaddressint	startSP;
    Language_GetKind	gKind;
    Language_Offset	sz;
    TLint4	stream;
    struct MIO_EventDescriptor	event;
    TLSTKCHKSLF(100897);
    TLSETF();
    TLSETL(100897);
    startPC = (TLaddressint) ((unsigned long) Language_Execute_globalPC - Language_codeOprSize);
    TLINCL();
    startSP = (TLaddressint) Language_Execute_globalSP;
    TLSETL(100900);
    TLASSERT (sizeof(Language_GetKind) == 1);
    TLINCL();
    gKind = (* (Language_GetKind *) Language_Execute_globalPC);
    TLINCL();
    Language_Execute_globalPC += Language_codeInt1Size;
    TLSETL(100905);
    if (gKind == 13) {
	TLSETL(100906);
	sz = 0;
    } else {
	TLSETL(100908);
	TLASSERT (((unsigned long) Language_Execute_globalPC & (3)) == 0);
	TLINCL();
	sz = (* (Language_Offset *) Language_Execute_globalPC);
	TLINCL();
	Language_Execute_globalPC += Language_codeOffsetSize;
    };
    TLSETL(100913);
    TL_TLI_TLIXSN = (* (TLint4 *) ((* (TLaddressint *) Language_Execute_globalSP)));
    TLINCL();
    Language_Execute_globalSP += 4;
    TLINCL();
    stream = Language_Execute_fileMap[TLINRANGELOW(TL_TLI_TLIXSN, -2, 20, 1)];
    TLINCL();
    if (stream == -3) {
	TLSETL(100920);
	{
	    TLstring	__x2107;
	    TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x2107);
	    {
		TLstring	__x2106;
		TL_TLS_TLSCAT("I/O attempted on closed stream ", __x2107, __x2106);
		Language_Execute_ExecutionError_Abort((TLint4) 10000, __x2106);
	    };
	};
    };
    TLSETL(100923);
    switch (gKind) {
	case 1:
	case 2:
	    {
		TLSETL(100925);
		event.mode = 2;
		TLINCL();
		event.count = 1;
	    }
	    break;
	case 3:
	    {
		TLint4	width;
		TLSETL(100928);
		width = (* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4));
		TLINCL();
		if (width < 0) {
		    TLSETL(100932);
		    {
			TLstring	__x2111;
			TL_TLS_TLSVIS((TLint4) width, (TLint4) 1, (TLint4) 10, __x2111);
			{
			    TLstring	__x2110;
			    TL_TLS_TLSCAT("Negative get width of ", __x2111, __x2110);
			    {
				TLstring	__x2109;
				TL_TLS_TLSCAT(__x2110, " specified", __x2109);
				Language_Execute_ExecutionError_Abort((TLint4) 10000, __x2109);
			    };
			};
		    };
		};
		TLSETL(100933);
		if (width > ((* (TLint4 *) Language_Execute_globalSP))) {
		    TLSETL(100938);
		    {
			TLstring	__x2118;
			TL_TLS_TLSVIS((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), (TLint4) 1, (TLint4) 10, __x2118);
			{
			    TLstring	__x2116;
			    TL_TLS_TLSVIS((TLint4) width, (TLint4) 1, (TLint4) 10, __x2116);
			    {
				TLstring	__x2115;
				TL_TLS_TLSCAT("Get width of ", __x2116, __x2115);
				{
				    TLstring	__x2114;
				    TL_TLS_TLSCAT(__x2115, " is longer than char string variable size of ", __x2114);
				    {
					TLstring	__x2113;
					TL_TLS_TLSCAT(__x2114, __x2118, __x2113);
					Language_Execute_ExecutionError_Abort((TLint4) 10000, __x2113);
				    };
				};
			    };
			};
		    };
		};
		TLSETL(100939);
		event.mode = 2;
		TLINCL();
		event.count = width;
	    }
	    break;
	case 11:
	    {
		TLSETL(100942);
		event.mode = 1;
		TLINCL();
		event.count = 0;
	    }
	    break;
	case 10:
	    {
		TLint4	width;
		TLSETL(100945);
		width = (* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4));
		TLINCL();
		if (width < 0) {
		    TLSETL(100949);
		    {
			TLstring	__x2122;
			TL_TLS_TLSVIS((TLint4) width, (TLint4) 1, (TLint4) 10, __x2122);
			{
			    TLstring	__x2121;
			    TL_TLS_TLSCAT("Negative get width of ", __x2122, __x2121);
			    {
				TLstring	__x2120;
				TL_TLS_TLSCAT(__x2121, " specified", __x2120);
				Language_Execute_ExecutionError_Abort((TLint4) 10000, __x2120);
			    };
			};
		    };
		};
		TLSETL(100950);
		if (width > ((* (TLint4 *) Language_Execute_globalSP))) {
		    TLSETL(100955);
		    {
			TLstring	__x2129;
			TL_TLS_TLSVIS((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), (TLint4) 1, (TLint4) 10, __x2129);
			{
			    TLstring	__x2127;
			    TL_TLS_TLSVIS((TLint4) width, (TLint4) 1, (TLint4) 10, __x2127);
			    {
				TLstring	__x2126;
				TL_TLS_TLSCAT("Get width of ", __x2127, __x2126);
				{
				    TLstring	__x2125;
				    TL_TLS_TLSCAT(__x2126, " is longer than string variable size of ", __x2125);
				    {
					TLstring	__x2124;
					TL_TLS_TLSCAT(__x2125, __x2129, __x2124);
					Language_Execute_ExecutionError_Abort((TLint4) 10000, __x2124);
				    };
				};
			    };
			};
		    };
		};
		TLSETL(100956);
		event.mode = 1;
		TLINCL();
		event.count = 0;
	    }
	    break;
	default :
	    {
		TLSETL(100959);
		event.mode = 0;
		TLINCL();
		event.count = 0;
	    }
	    break;
    };
    TLSETL(100963);
    if (!Language_Execute_HasEvent((TLint4) TL_TLI_TLIXSN, &(event))) {
	TLSETL(100964);
	Language_Execute_globalPC = (TLaddressint) startPC;
	TLINCL();
	Language_Execute_globalSP = (TLaddressint) startSP;
	TLSETL(100967);
	Language_Execute_EventQueueInsert((TLint4) TL_TLI_TLIXSN, &(event));
	TLINCL();
	TLRESTORELF();
	return;
    };
    TLSETL(100970);
    switch (gKind) {
	case 0:
	    {
		TLstring	tstring;
		TLSETL(100973);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
		TL_TLI_TLIGS ((TLint4) 255, tstring, (TLint2) stream);
		TLINCL();
		if (strcmp(tstring, "true") == 0) {
		    TLSETL(100975);
		    (* (TLboolean *) ((* (TLaddressint *) Language_Execute_globalSP))) = 1;
		} else {
		    TLSETL(100976);
		    if (strcmp(tstring, "false") == 0) {
			TLSETL(100977);
			(* (TLboolean *) ((* (TLaddressint *) Language_Execute_globalSP))) = 0;
		    } else {
			TLSETL(100981);
			{
			    TLstring	__x2135;
			    TL_TLS_TLSCAT("Value of \'", tstring, __x2135);
			    {
				TLstring	__x2134;
				TL_TLS_TLSCAT(__x2135, "\' is invalid for boolean input", __x2134);
				Language_Execute_ExecutionError_Abort((TLint4) 10000, __x2134);
			    };
			};
		    };
		};
	    }
	    break;
	case 1:
	    {
		TLSETL(100984);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
		TL_TLI_TLIGC ((TLint4) sizeof ((* (TLchar *) ((* (TLaddressint *) Language_Execute_globalSP)))), &((* (TLchar *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint4) sizeof ((* (TLchar *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint2) stream);
		TLINCL();
		Language_Execute_globalSP += 4;
	    }
	    break;
	case 3:
	    {
		TLSETL(100994);
		TL_TLI_TLISS((TLint4) stream, (TLint2) 1);
		TLSETL(100997);
		TL_TLI_TLIGC((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), (TLaddressint) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + (2 * 4)))), (TLint4) ((* (TLaddressint *) ((unsigned long) Language_Execute_globalSP + 4))), (TLint2) stream);
		Language_Execute_globalSP += 12;
	    }
	    break;
	case 2:
	    {
		TLchar	c;
		TLSETL(101001);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
		TL_TLI_TLIGC ((TLint4) sizeof c, &c, (TLint4) sizeof c, (TLint2) stream);
		TLINCL();
		TLASSERT (((unsigned long) Language_Execute_globalPC & (3)) == 0);
		TLINCL();
		if (((* (TLnat1 *) &c) < ((* (TLint4 *) Language_Execute_globalPC))) || ((* (TLnat1 *) &c) > ((* (TLint4 *) ((unsigned long) Language_Execute_globalPC + Language_codeIntSize))))) {
		    TLSETL(101005);
		    Language_Execute_ExecutionError_Abort((TLint4) 10000, "Input value is out of range");
		};
		TLSETL(101006);
		Language_Execute_globalPC += 2 * Language_codeIntSize;
		TLINCL();
		(* (TLchar *) ((* (TLaddressint *) Language_Execute_globalSP))) = c;
		TLINCL();
		Language_Execute_globalSP += 4;
	    }
	    break;
	case 4:
	    {
		TLstring	tstring;
		register TLaddressint	ptr;
		TLint4	count;
		TLSETL(101012);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
		TL_TLI_TLIGS ((TLint4) 255, tstring, (TLint2) stream);
		TLSETL(101014);
		ptr = (TLaddressint) ((* (TLaddressint *) Language_Execute_globalSP));
		TLINCL();
		Language_Execute_globalSP += 4;
		TLSETL(101017);
		count = (* (TLint4 *) ptr);
		TLINCL();
		ptr += 4;
		TLSETL(101020);
		{
		    register TLint4	i;
		    TLint4	__x2147;
		    __x2147 = count - 1;
		    i = 0;
		    if (i <= __x2147) {
			for(;;) {
			    TLSETL(101022);
			    for(;;) {
				TLSETL(101022);
				if (((* (TLchar *) ptr)) != '\0') {
				    break;
				};
				TLSETL(101023);
				ptr += 1;
			    };
			    TLSETL(101025);
			    if (strcmp(tstring, (* (TLstring *) ptr)) == 0) {
				TLSETL(101026);
				switch (sz) {
				    case 1:
					{
					    TLSETL(101028);
					    (* (TLint1 *) ((* (TLaddressint *) Language_Execute_globalSP))) = i;
					}
					break;
				    case 2:
					{
					    TLSETL(101030);
					    (* (TLint2 *) ((* (TLaddressint *) Language_Execute_globalSP))) = i;
					}
					break;
				    case 4:
					{
					    TLSETL(101032);
					    (* (TLint4 *) ((* (TLaddressint *) Language_Execute_globalSP))) = i;
					}
					break;
				    default:
					TLCASEABORT;
				};
				TLSETL(101035);
				break;
			    };
			    TLSETL(101037);
			    for(;;) {
				TLSETL(101037);
				ptr += 1;
				TLINCL();
				if (((* (TLchar *) ptr)) == '\0') {
				    break;
				};
			    };
			    if (i == __x2147) break;
			    i++;
			}
		    };
		};
		TLSETL(101041);
		if (((* (TLchar *) ptr)) == '\0') {
		    TLSETL(101044);
		    {
			TLstring	__x2159;
			TL_TLS_TLSCAT("Value of \'", tstring, __x2159);
			{
			    TLstring	__x2158;
			    TL_TLS_TLSCAT(__x2159, "\' is not a valid enum member", __x2158);
			    Language_Execute_ExecutionError_Abort((TLint4) 10000, __x2158);
			};
		    };
		};
		TLSETL(101045);
		Language_Execute_globalSP += 4;
	    }
	    break;
	case 6:
	    {
		TLSETL(101048);
		switch (sz) {
		    case 1:
			{
			    TLSETL(101050);
			    TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
			    TL_TLI_TLIGI (&((* (TLint1 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint4) sizeof ((* (TLint1 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint2) stream);
			}
			break;
		    case 2:
			{
			    TLSETL(101052);
			    TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
			    TL_TLI_TLIGI (&((* (TLint2 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint4) sizeof ((* (TLint2 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint2) stream);
			}
			break;
		    case 4:
			{
			    TLSETL(101054);
			    TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
			    TL_TLI_TLIGI (&((* (TLint4 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint4) sizeof ((* (TLint4 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint2) stream);
			}
			break;
		    default:
			TLCASEABORT;
		};
		TLSETL(101056);
		Language_Execute_globalSP += 4;
	    }
	    break;
	case 8:
	    {
		TLSETL(101059);
		switch (sz) {
		    case 1:
			{
			    TLSETL(101061);
			    TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
			    TL_TLI_TLIGN (&((* (TLnat1 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint4) sizeof ((* (TLnat1 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint2) stream);
			}
			break;
		    case 2:
			{
			    TLSETL(101063);
			    TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
			    TL_TLI_TLIGN (&((* (TLnat2 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint4) sizeof ((* (TLnat2 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint2) stream);
			}
			break;
		    case 4:
			{
			    TLSETL(101065);
			    TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
			    TL_TLI_TLIGN (&((* (TLnat4 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint4) sizeof ((* (TLnat4 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint2) stream);
			}
			break;
		    default:
			TLCASEABORT;
		};
		TLSETL(101067);
		Language_Execute_globalSP += 4;
	    }
	    break;
	case 9:
	    {
		TLSETL(101070);
		if (sz == 8) {
		    TLSETL(101071);
		    TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
		    TL_TLI_TLIGR (&((* (TLreal8 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint4) sizeof ((* (TLreal8 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint2) stream);
		} else {
		    TLSETL(101073);
		    TLASSERT (sz == 4);
		    TLINCL();
		    TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
		    TL_TLI_TLIGR (&((* (TLreal4 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint4) sizeof ((* (TLreal4 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint2) stream);
		};
		TLSETL(101076);
		Language_Execute_globalSP += 4;
	    }
	    break;
	case 13:
	    {
		TLSETL(101079);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
		TL_TLI_TLIGK ((TLint2) stream);
	    }
	    break;
	case 11:
	    {
		TLstring	tstring;
		TLSETL(101083);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
		TL_TLI_TLIGSS((TLint4) 255, tstring, (TLint2) stream);
		TLINCL();
		if (TL_TLS_TLSLEN(tstring) > ((* (TLint4 *) Language_Execute_globalSP))) {
		    TLSETL(101087);
		    Language_Execute_ExecutionError_Abort((TLint4) 10000, "Input string is too large for string variable");
		};
		TLSETL(101088);
		Language_Execute_globalSP += 4;
		TLINCL();
		(* (TLint1 *) ((* (TLaddressint *) Language_Execute_globalSP))) = 0;
		TLSETL(101091);
		strcpy((* (TLstring *) ((* (TLaddressint *) Language_Execute_globalSP))), tstring);
		Language_Execute_globalSP += 4;
	    }
	    break;
	case 10:
	    {
		register TLint4	width;
		TLSETL(101094);
		width = (* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4));
		TLINCL();
		Language_Execute_globalSP += 8;
		TLINCL();
		(* (TLint1 *) ((* (TLaddressint *) Language_Execute_globalSP))) = 0;
		TLINCL();
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
		TL_TLI_TLIGSW ((TLint4) 255, (TLint4) width, (* (TLstring *) ((* (TLaddressint *) Language_Execute_globalSP))), (TLint2) stream);
		TLINCL();
		Language_Execute_globalSP += 4;
	    }
	    break;
	case 12:
	    {
		TLstring	tstring;
		TLSETL(101102);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
		TL_TLI_TLIGS ((TLint4) 255, tstring, (TLint2) stream);
		TLINCL();
		if (TL_TLS_TLSLEN(tstring) > ((* (TLint4 *) Language_Execute_globalSP))) {
		    TLSETL(101106);
		    Language_Execute_ExecutionError_Abort((TLint4) 10000, "Input string is too large for string variable");
		};
		TLSETL(101107);
		Language_Execute_globalSP += 4;
		TLINCL();
		(* (TLint1 *) ((* (TLaddressint *) Language_Execute_globalSP))) = 0;
		TLSETL(101110);
		strcpy((* (TLstring *) ((* (TLaddressint *) Language_Execute_globalSP))), tstring);
		Language_Execute_globalSP += 4;
	    }
	    break;
	case 7:
	    {
		TLint4	i;
		TLSETL(101114);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
		TL_TLI_TLIGI (&i, (TLint4) sizeof i, (TLint2) stream);
		TLINCL();
		TLASSERT (((unsigned long) Language_Execute_globalPC & (3)) == 0);
		TLINCL();
		if ((i < ((* (TLint4 *) Language_Execute_globalPC))) || (i > ((* (TLint4 *) ((unsigned long) Language_Execute_globalPC + Language_codeIntSize))))) {
		    TLSETL(101119);
		    Language_Execute_ExecutionError_Abort((TLint4) 10000, "Input value is out of range");
		};
		TLSETL(101120);
		Language_Execute_globalPC += 2 * Language_codeIntSize;
		TLINCL();
		switch (sz) {
		    case 1:
			{
			    TLSETL(101123);
			    (* (TLint1 *) ((* (TLaddressint *) Language_Execute_globalSP))) = i;
			}
			break;
		    case 2:
			{
			    TLSETL(101125);
			    (* (TLint2 *) ((* (TLaddressint *) Language_Execute_globalSP))) = i;
			}
			break;
		    case 4:
			{
			    TLSETL(101127);
			    (* (TLint4 *) ((* (TLaddressint *) Language_Execute_globalSP))) = i;
			}
			break;
		    default:
			TLCASEABORT;
		};
		TLSETL(101129);
		Language_Execute_globalSP += 4;
	    }
	    break;
	default:
	    TLCASEABORT;
    };
    TLRESTORELF();
}

void Language_Execute_DispatchHandler (quitCode)
TLint4	quitCode;
{
    TLBINDREG((*pd), struct Language_Execute_ProcessDescriptor);
    register struct Language_Execute_HandlerArea	*ha;
    TLSTKCHKSLF(101135);
    TLSETF();
    TLSETL(101135);
    pd = &((*(Language_Execute_RQHead)));
    TLSETL(101137);
    ha = (*pd).activeHandler;
    TLINCL();
    (*pd).runningHandler = ha;
    TLSETL(101140);
    if (ha != ((struct Language_Execute_HandlerArea *) 0)) {
	TLSETL(101144);
	TLSTRCTASS(ha->srcPos, (*pd).srcPos, struct SrcPosition);
	TLINCL();
	ha->quitCode = quitCode;
	TLSETL(101148);
	(*pd).activeHandler = ha->nextHandler;
	TLSETL(101151);
	Language_Execute_globalPC = (TLaddressint) (ha->handlerRoutine);
	TLINCL();
	Language_Execute_globalSP = (TLaddressint) (ha->savedRegisters.sp);
	TLINCL();
	(*pd).fp = (TLaddressint) (ha->savedRegisters.fp);
    } else {
	TLstring	message;
	TLSETL(101158);
	TLSTRASS(255, message, "");
	TLSETL(101160);
	if ((unsigned long) ((*pd).name) != 0) {
	    TLSETL(101161);
	    {
		TLstring	__x2200;
		TL_TLS_TLSCAT("Process \"", (* (TLstring *) ((*pd).name)), __x2200);
		{
		    TLstring	__x2199;
		    TL_TLS_TLSCAT(__x2200, "\": ", __x2199);
		    TLSTRASS(255, message, __x2199);
		};
	    };
	};
	TLSETL(101163);
	if ((((*pd).abort.quitCode) != 0) && (quitCode == ((*pd).abort.quitCode))) {
	    TLSETL(101165);
	    TLSTRCATASS(message, (*pd).abort.errorMsg, 255);
	} else {
	    TLSETL(101168);
	    {
		TLstring	__x2203;
		TL_TLS_TLSVIS((TLint4) quitCode, (TLint4) 1, (TLint4) 10, __x2203);
		{
		    TLstring	__x2202;
		    TL_TLS_TLSCAT("Quit #", __x2203, __x2202);
		    TLSTRCATASS(message, __x2202, 255);
		};
	    };
	};
	TLSETL(101173);
	Language_ErrorModule_Message(&((*pd).srcPos), (Language_ErrorModule_Severity) 3, message);
    };
    TLRESTORELF();
}

extern void TLEABT ();

void Language_Execute_ExtraRoutines (op)
Language_Opcode	op;
{
    TLSTKCHKSLF(101190);
    TLSETF();
    TLSETL(101190);
    switch (op) {
	case 77:
	    {
		TLint4	stream;
		struct MIO_EventDescriptor	event;
		TLSETL(101194);
		TL_TLI_TLIXSN = (* (TLint4 *) ((* (TLaddressint *) Language_Execute_globalSP)));
		TLINCL();
		stream = Language_Execute_fileMap[TLINRANGELOW(TL_TLI_TLIXSN, -2, 20, 1)];
		TLINCL();
		if (stream == -3) {
		    TLSETL(101201);
		    {
			TLstring	__x2207;
			TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x2207);
			{
			    TLstring	__x2206;
			    TL_TLS_TLSCAT("I/O attempted on closed stream ", __x2207, __x2206);
			    Language_Execute_ExecutionError_Abort((TLint4) 10000, __x2206);
			};
		    };
		};
		TLSETL(101203);
		event.mode = 2;
		TLINCL();
		event.count = 1;
		TLINCL();
		if (Language_Execute_HasEvent((TLint4) TL_TLI_TLIXSN, &(event))) {
		    TLSETL(101206);
		    Language_Execute_globalSP -= 0;
		    TLINCL();
		    if (TL_TLI_TLIEOF((TLint4) stream)) {
			TLSETL(101208);
			(* (TLnat4 *) Language_Execute_globalSP) = 1;
		    } else {
			TLSETL(101210);
			(* (TLnat4 *) Language_Execute_globalSP) = 0;
		    };
		} else {
		    TLSETL(101213);
		    Language_Execute_globalPC -= Language_codeOprSize;
		    TLSETL(101215);
		    Language_Execute_EventQueueInsert((TLint4) TL_TLI_TLIXSN, &(event));
		};
	    }
	    break;
	case 120:
	    {
		TLSETL(101220);
		Language_Execute_Get();
	    }
	    break;
	case 181:
	    {
		TLSETL(101223);
		Language_Execute_Open();
	    }
	    break;
	case 196:
	    {
		TLSETL(101226);
		Language_Execute_Put();
	    }
	    break;
	case 198:
	    {
		TLaddressint	startPC;
		TLaddressint	startSP;
		register TLaddressint	statusAddr;
		TLint4	stream;
		register TLaddressint	resultAddr;
		struct MIO_EventDescriptor	event;
		TLSETL(101231);
		startPC = (TLaddressint) ((unsigned long) Language_Execute_globalPC - Language_codeOprSize);
		TLINCL();
		startSP = (TLaddressint) Language_Execute_globalSP;
		TLSETL(101234);
		statusAddr = (TLaddressint) ((* (TLaddressint *) ((* (TLaddressint *) Language_Execute_globalSP))));
		TLSETL(101236);
		Language_Execute_globalSP += 4;
		TLSETL(101238);
		TL_TLI_TLIXSN = (* (TLint4 *) ((* (TLaddressint *) Language_Execute_globalSP)));
		TLINCL();
		Language_Execute_globalSP += 4;
		TLINCL();
		stream = Language_Execute_fileMap[TLINRANGELOW(TL_TLI_TLIXSN, -2, 20, 1)];
		TLINCL();
		if (stream == -3) {
		    TLSETL(101246);
		    {
			TLstring	__x2215;
			TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x2215);
			{
			    TLstring	__x2214;
			    TL_TLS_TLSCAT("I/O attempted on closed stream ", __x2215, __x2214);
			    Language_Execute_ExecutionError_Abort((TLint4) 10000, __x2214);
			};
		    };
		};
		TLSETL(101248);
		resultAddr = (TLaddressint) ((* (TLaddressint *) Language_Execute_globalSP));
		TLINCL();
		Language_Execute_globalSP += 4;
		TLSETL(101257);
		event.mode = 2;
		TLINCL();
		event.count = (TLint4) ((* (TLint4 *) Language_Execute_globalSP));
		TLSETL(101260);
		if (Language_Execute_HasEvent((TLint4) TL_TLI_TLIXSN, &(event))) {
		    TLint4	status;
		    TLint4	sizeRead;
		    TLSETL(101264);
		    TL_TLI_TLISSS (&status, (TLint4) stream, (TLint2) 3);
		    TL_TLI_TLIRER (&sizeRead, &((* (TLint4 *) ((* (TLaddressint *) ((unsigned long) Language_Execute_globalSP + 4))))), (TLint4) ((* (TLint4 *) Language_Execute_globalSP)), &status, (TLint2) stream);
		    TLSETL(101267);
		    if ((unsigned long) statusAddr != 0) {
			TLSETL(101268);
			(* (TLint4 *) statusAddr) = status;
		    };
		    TLSETL(101270);
		    if ((unsigned long) resultAddr != 0) {
			TLSETL(101271);
			(* (TLint4 *) resultAddr) = sizeRead;
		    };
		    TLSETL(101273);
		    Language_Execute_globalSP += 8;
		} else {
		    TLSETL(101275);
		    Language_Execute_globalPC = (TLaddressint) startPC;
		    TLINCL();
		    Language_Execute_globalSP = (TLaddressint) startSP;
		    TLSETL(101278);
		    Language_Execute_EventQueueInsert((TLint4) TL_TLI_TLIXSN, &(event));
		};
	    }
	    break;
	case 216:
	    {
		Language_SetStreamKind	streamMode;
		TLSETL(101284);
		streamMode = (* (Language_SetStreamKind *) Language_Execute_globalPC);
		TLINCL();
		Language_Execute_globalPC += Language_codeInt1Size;
		TLSETL(101287);
		if ((Language_Execute_RQHead->activeStream) == 0) {
		    TLSETL(101288);
		    if (streamMode == 1) {
			TLSETL(101289);
			(* (TLint4 *) ((* (TLaddressint *) Language_Execute_globalSP))) = -2;
		    } else {
			TLSETL(101291);
			TLASSERT (streamMode == 2);
			TLINCL();
			(* (TLint4 *) ((* (TLaddressint *) Language_Execute_globalSP))) = -1;
		    };
		} else {
		    TLSETL(101295);
		    (* (TLint4 *) ((* (TLaddressint *) Language_Execute_globalSP))) = Language_Execute_RQHead->activeStream;
		};
		TLSETL(101297);
		Language_Execute_globalSP += 4;
	    }
	    break;
	case 217:
	    {
		Language_SetStreamKind	streamMode;
		TLSETL(101303);
		streamMode = (* (Language_SetStreamKind *) Language_Execute_globalPC);
		TLINCL();
		Language_Execute_globalPC += Language_codeInt1Size;
		TLSETL(101306);
		(* (TLaddressint *) ((* (TLaddressint *) Language_Execute_globalSP))) = (TLaddressint) ((* (TLaddressint *) ((unsigned long) Language_Execute_globalSP + (2 * 4))));
		TLSETL(101308);
		Language_Execute_globalSP += 4;
		TLINCL();
		TL_TLI_TLIXSN = (* (TLint4 *) ((unsigned long) Language_Execute_globalSP + (2 * 4)));
		TLINCL();
		(* (TLint4 *) ((* (TLaddressint *) Language_Execute_globalSP))) = TL_TLI_TLIXSN;
		TLINCL();
		Language_Execute_globalSP += 12;
		TLSETL(101313);
		if (TL_TLI_TLIXSN < (- 2)) {
		    TLSETL(101315);
		    Language_Execute_BadStreamAbortMessage((TLint4) TL_TLI_TLIXSN, "I/O");
		} else {
		    TLSETL(101315);
		    if (TL_TLI_TLIXSN > 20) {
			TLSETL(101319);
			{
			    TLstring	__x2237;
			    TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x2237);
			    {
				TLstring	__x2236;
				TL_TLS_TLSCAT("I/O attempted on illegal stream number ", __x2237, __x2236);
				Language_Execute_ExecutionError_Abort((TLint4) 10000, __x2236);
			    };
			};
		    };
		};
		TLSETL(101320);
		if ((Language_Execute_fileMap[TLINRANGELOW(TL_TLI_TLIXSN, -2, 20, 1)]) == -3) {
		    Language_StreamModeSet	openMode;
		    TLSETL(101321);
		    if (TL_TLI_TLIXSN > Language_Execute_numArguments) {
			TLSETL(101325);
			{
			    TLstring	__x2239;
			    TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x2239);
			    {
				TLstring	__x2238;
				TL_TLS_TLSCAT("I/O attempted on unopened or closed stream ", __x2239, __x2238);
				Language_Execute_ExecutionError_Abort((TLint4) 10000, __x2238);
			    };
			};
		    };
		    TLSETL(101327);
		    openMode = (TLSMLSMLSETCONST(TLINRANGELOW(streamMode, 0, 5, 19)));
		    TLINCL();
		    if (streamMode == 0) {
			TLSETL(101329);
			openMode |= 0x2;
		    };
		    TLSETL(101332);
		    Language_Execute_OpenArgumentFile((Language_StreamModeSet) openMode, (TLboolean) 1);
		};
	    }
	    break;
	case 55:
	    {
		register TLint4	Index;
		TLSETL(101339);
		if (((* (Language_SubstringKind *) Language_Execute_globalPC)) == 0) {
		    TLSETL(101340);
		    Index = (* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4));
		} else {
		    TLSETL(101342);
		    TLASSERT (((* (Language_SubstringKind *) Language_Execute_globalPC)) == 1);
		    TLINCL();
		    Index = ((* (TLint4 *) Language_Execute_globalSP)) - ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4)));
		};
		TLSETL(101346);
		if (Index <= 0) {
		    TLSETL(101349);
		    Language_Execute_ExecutionError_Abort((TLint4) 10000, "Char substring index is less than 1");
		} else {
		    TLSETL(101349);
		    if (Index > ((* (TLint4 *) Language_Execute_globalSP))) {
			TLSETL(101352);
			Language_Execute_ExecutionError_Abort((TLint4) 10000, "Char substring index is greater than length of char(n)");
		    };
		};
		TLSETL(101354);
		(* (TLaddressint *) ((unsigned long) Language_Execute_globalSP + (2 * 4))) += Index - 1;
		TLINCL();
		Language_Execute_globalSP += 8;
		TLINCL();
		Language_Execute_globalPC += Language_codeInt1Size;
	    }
	    break;
	case 56:
	    {
		register TLint4	startIndex;
		register TLint4	endIndex;
		register TLint4	slen;
		register TLaddressint	tAddr;
		register TLaddressint	sAddr;
		TLSETL(101362);
		slen = (* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4));
		TLSETL(101364);
		switch ((* (Language_SubstringKind *) Language_Execute_globalPC)) {
		    case 2:
			{
			    TLSETL(101366);
			    startIndex = (* (TLint4 *) (((unsigned long) Language_Execute_globalSP + 4) + (2 * 4)));
			    TLINCL();
			    endIndex = (* (TLint4 *) (((unsigned long) Language_Execute_globalSP + 4) + 4));
			}
			break;
		    case 3:
			{
			    TLSETL(101370);
			    startIndex = (* (TLint4 *) (((unsigned long) Language_Execute_globalSP + 4) + (2 * 4)));
			    TLINCL();
			    endIndex = slen - ((* (TLint4 *) (((unsigned long) Language_Execute_globalSP + 4) + 4)));
			}
			break;
		    case 4:
			{
			    TLSETL(101374);
			    startIndex = slen - ((* (TLint4 *) (((unsigned long) Language_Execute_globalSP + 4) + (2 * 4))));
			    TLINCL();
			    endIndex = (* (TLint4 *) (((unsigned long) Language_Execute_globalSP + 4) + 4));
			}
			break;
		    case 5:
			{
			    TLSETL(101378);
			    startIndex = slen - ((* (TLint4 *) (((unsigned long) Language_Execute_globalSP + 4) + (2 * 4))));
			    TLINCL();
			    endIndex = slen - ((* (TLint4 *) (((unsigned long) Language_Execute_globalSP + 4) + 4)));
			}
			break;
		    default:
			TLCASEABORT;
		};
		TLSETL(101382);
		if (startIndex <= 0) {
		    TLSETL(101385);
		    Language_Execute_ExecutionError_Abort((TLint4) 10000, "Left bound of char substring is less than 1");
		} else {
		    TLSETL(101385);
		    if ((startIndex - endIndex) > 1) {
			TLSETL(101388);
			Language_Execute_ExecutionError_Abort((TLint4) 10000, "Left bound of char substring exceeds right bound by more than 1");
		    } else {
			TLSETL(101388);
			if (endIndex > slen) {
			    TLSETL(101391);
			    Language_Execute_ExecutionError_Abort((TLint4) 10000, "Right bound of char substring is greater than size of char(n)");
			} else {
			    TLSETL(101391);
			    if ((endIndex - startIndex) >= 256) {
				TLSETL(101394);
				Language_Execute_ExecutionError_Abort((TLint4) 10000, "Char substring too large to fit into \'string\'");
			    };
			};
		    };
		};
		TLSETL(101397);
		(* (TLint1 *) ((* (TLaddressint *) Language_Execute_globalSP))) = 0;
		TLSETL(101400);
		tAddr = (TLaddressint) ((* (TLaddressint *) Language_Execute_globalSP));
		TLINCL();
		sAddr = (TLaddressint) (((unsigned long) ((* (TLaddressint *) (((unsigned long) Language_Execute_globalSP + 4) + (3 * 4)))) + startIndex) - 1);
		TLSETL(101404);
		{
		    register TLint4	__x1739;
		    TLint4	__x2261;
		    __x2261 = endIndex;
		    __x1739 = startIndex;
		    if (__x1739 <= __x2261) {
			for(;;) {
			    register TLnat4	val;
			    TLSETL(101405);
			    val = (* (TLnat1 *) sAddr);
			    TLINCL();
			    sAddr += 1;
			    TLSETL(101408);
			    if ((val & 127) == 0) {
				TLSETL(101411);
				Language_Execute_ExecutionError_Abort((TLint4) 10000, "char(n) converted to string contains EOS or uninitchar");
			    };
			    TLSETL(101412);
			    (* (TLnat1 *) tAddr) = val;
			    TLINCL();
			    tAddr += 1;
			    if (__x1739 == __x2261) break;
			    __x1739++;
			}
		    };
		};
		TLSETL(101415);
		(* (TLnat1 *) tAddr) = 0;
		TLSETL(101417);
		(* (TLaddressint *) (((unsigned long) Language_Execute_globalSP + 4) + (3 * 4))) = (TLaddressint) ((* (TLaddressint *) Language_Execute_globalSP));
		TLSETL(101419);
		Language_Execute_globalSP += 16;
		TLINCL();
		Language_Execute_globalPC += Language_codeInt1Size;
	    }
	    break;
	default :
	    {
		TLSETL(101423);
		if (op > 254) {
		    TLSETL(101426);
		    {
			TLstring	__x2268;
			TL_TLS_TLSVIS((TLint4) (* (TLnat2 *) &op), (TLint4) 1, (TLint4) 10, __x2268);
			{
			    TLstring	__x2267;
			    TL_TLS_TLSCAT("Undecodeable opcode #", __x2268, __x2267);
			    Language_Execute_ExecutionError_Abort((TLint4) 10000, __x2267);
			};
		    };
		} else {
		    TLSETL(101434);
		    {
			TLstring	__x2269;
			//TL_TLS_TLSCAT("Unimplemented opcode ", Language_OpcodeName[TLINRANGELOW(op, 0, 254, 1)], __x2269);
			TL_TLS_TLSCAT("Unimplemented opcode ", "<opcode finding disabled, see execute.c>", __x2269);
			Language_Execute_ExecutionError_Abort((TLint4) 10000, __x2269);
		    };
		};
	    }
	    break;
    };
    TLRESTORELF();
}

void Language_Execute_EndExecution () {
    TLSTKCHKSLF(101440);
    TLSETF();
    TLSETL(101440);
    Language_Execute_failedOpenStream = -10;
    TLSETL(101442);
    Language_Execute_CloseArguments();
    TLINCL();
    Language_Execute_CloseAllFiles();
    TLRESTORELF();
}

void Language_Execute_RecoverAllMemory () {
    TLSTKCHKSLF(101448);
    TLSETF();
    TLSETL(101448);
    Language_Execute_EndExecution();
    TLINCL();
    Language_Execute_Heap_CleanUp();
    Language_Execute_RQHead = (struct Language_Execute_ProcessDescriptor *) 0;
    TLINCL();
    Language_Execute_EQHead = (struct Language_Execute_ProcessDescriptor *) 0;
    TLRESTORELF();
}
TLint4	Language_Execute_quantaCount;

void Language_Execute_Initialize (startPC, maxStackSize, inName, outName, args, numArgs)
TLaddressint	startPC;
TLnat4	maxStackSize;
TLstring	inName;
TLstring	outName;
__x1948	args;
TLint4	numArgs;
{
    TLnat4	stackSize;
    TLaddressint	stackBase;

    extern void TL_TLA_TLARZ ();
    TLSTKCHKSLF(101464);
    TLSETF();
    TLSETL(101464);
    if (strcmp(inName, "") == 0) {
	TLSETL(101465);
	Language_Execute_fileMap[0] = -2;
    } else {
	TLint4	inStream;
	TLSETL(101468);
	TL_TLI_TLIOF ((TLnat2) 2, inName, &inStream);
	TLINCL();
	if (inStream == 0) {
	    TLSETL(101473);
	    {
		TLstring	__x2271;
		TL_TLS_TLSCAT("Unable to open file \'", inName, __x2271);
		{
		    TLstring	__x2270;
		    TL_TLS_TLSCAT(__x2271, "\' for input", __x2270);
		    Language_ErrorModule_Message(&(Language_nullSrcPosition), (Language_ErrorModule_Severity) 3, __x2270);
		};
	    };
	};
	TLSETL(101474);
	Language_Execute_fileMap[0] = inStream;
    };
    TLSETL(101477);
    if (strcmp(outName, "") == 0) {
	TLSETL(101478);
	Language_Execute_fileMap[1] = -1;
	TLINCL();
	Language_Execute_fileMap[2] = -1;
    } else {
	TLint4	outStream;
	TLSETL(101482);
	TL_TLI_TLIOF ((TLnat2) 4, outName, &outStream);
	TLINCL();
	if (outStream == 0) {
	    TLSETL(101487);
	    {
		TLstring	__x2273;
		TL_TLS_TLSCAT("Unable to open file \'", outName, __x2273);
		{
		    TLstring	__x2272;
		    TL_TLS_TLSCAT(__x2273, "\' for output", __x2272);
		    Language_ErrorModule_Message(&(Language_nullSrcPosition), (Language_ErrorModule_Severity) 3, __x2272);
		};
	    };
	};
	TLSETL(101488);
	Language_Execute_fileMap[1] = outStream;
	TLINCL();
	Language_Execute_fileMap[2] = outStream;
    };
    TLSETL(101492);
    Language_Execute_numArguments =  TLSIMPLEMIN(numArgs, 20);
    TLSETL(101494);
    {
	register TLint4	i;
	TLint4	__x2274;
	__x2274 = Language_Execute_numArguments;
	i = 0;
	if (i <= __x2274) {
	    for(;;) {
		TLSETL(101495);
		TL_TLB_TLBNWU(& Language_Execute_argumentNames[TLINRANGELOW(i, 0, 20, 1)], (TLint4)  sizeof (		Language_StringDef));
		TLINCL();
		if ((Language_Execute_argumentNames[TLINRANGELOW(i, 0, 20, 1)]) == ((Language_StringDef *) 0)) {
		    TLSETL(101500);
		    Language_ErrorModule_Message(&(Language_nullSrcPosition), (Language_ErrorModule_Severity) 3, "Unable to allocate memory for arguments");
		};
		TLSETL(101501);
		TLSTRASS(255, (*(Language_Execute_argumentNames[TLINRANGELOW(i, 0, 20, 1)])), args[TLINRANGELOW(i, 0, 20, 1)]);
		if (i == __x2274) break;
		i++;
	    }
	};
    };
    TLSETL(101505);
    stackSize = maxStackSize * 1024;
    TLINCL();
    if (stackSize < 0x1000) {
	TLSETL(101507);
	stackSize = 4096;
    };
    TLSETL(101511);
    for(;;) {
	TLSETL(101513);
	Language_Execute_Heap_Alloc(&(stackBase), (TLnat4) ((256 + stackSize) + sizeof(struct Language_Execute_ProcessDescriptor)));
	if ((unsigned long) stackBase != 0) {
	    break;
	};
	TLSETL(101514);
	if (stackSize > (64 * 1024)) {
	    TLSETL(101515);
	    stackSize /= 2;
	} else {
	    TLSETL(101517);
	    stackSize -= 2048;
	};
	TLSETL(101519);
	if (stackSize < 0x1000) {
	    TLSETL(101523);
	    Language_ErrorModule_Message(&(Language_nullSrcPosition), (Language_ErrorModule_Severity) 3, "Unable to allocate memory for stack");
	};
    };
    TLSETL(101525);
    Language_Execute_stackAllocated = stackSize;
    TLSETL(101527);
    * (TLnat4 *) &Language_Execute_RQHead = ((unsigned long) stackBase + 256) + stackSize;
    TLINCL();
    Language_Execute_RQHead->pc = (TLaddressint) startPC;
    TLINCL();
    Language_Execute_RQHead->fp = (TLaddressint) 0;
    TLINCL();
    Language_Execute_RQHead->sp = (TLaddressint) ((* (TLnat4 *) &Language_Execute_RQHead) - 4);
    TLINCL();
    (* (TLaddressint *) (Language_Execute_RQHead->sp)) = (TLaddressint) 0;
    TLINCL();
    Language_Execute_RQHead->minimumSP = (TLaddressint) ((unsigned long) stackBase + 256);
    TLINCL();
    Language_Execute_RQHead->stackBase = (TLaddressint) stackBase;
    TLINCL();
    TLSTRCTASS(Language_Execute_RQHead->srcPos, Language_nullSrcPosition, struct SrcPosition);
    TLINCL();
    Language_Execute_RQHead->activeStream = 0;
    TLINCL();
    TLSTRASS(255, Language_Execute_RQHead->errMessage, "");
    TLINCL();
    TLSTRASS(255, Language_Execute_RQHead->prevErrMessage, "");
    TLINCL();
    Language_Execute_RQHead->name = (TLaddressint) 0;
    TLINCL();
    Language_Execute_RQHead->nextProcess = (struct Language_Execute_ProcessDescriptor *) 0;
    TLINCL();
    Language_Execute_RQHead->dispatchPriority = 1000;
    TLINCL();
    Language_Execute_RQHead->totalPause = 0;
    TLINCL();
    Language_Execute_RQHead->activeHandler = (struct Language_Execute_HandlerArea *) 0;
    TLINCL();
    Language_Execute_RQHead->runningHandler = (struct Language_Execute_HandlerArea *) 0;
    TLSETL(101545);
    Language_Execute_RQHead->stepSpec = 0;
    TLINCL();
    Language_Execute_RQHead->stepFP = (TLaddressint) 0;
    TLSETL(101550);
    Language_Execute_savedInitPC = (TLaddressint) 0;
    TLINCL();
    Language_Execute_savedInitFP = (TLaddressint) 0;
    TLSETL(101554);
    Language_Execute_EQHead = (struct Language_Execute_ProcessDescriptor *) 0;
    TLSETL(101557);
    Language_Execute_ExecutionError_Initialize();
    Language_Execute_Chrono = 0;
    TLINCL();
    Language_Execute_quantaCount = 20;
    TLINCL();
    Language_Execute_processCount = 0;
    TLSETL(101565);
    Language_Execute_Kernel_Initialize();
    TLSETL(101569);
    TL_TLA_TLARZ();
    TLINCL();
    MIO_Init();
    TLRESTORELF();
}

void Language_Execute_SetStep (step)
Language_Step	step;
{
    register struct Language_Execute_ProcessDescriptor	*pd;
    TLSTKCHKSLF(101576);
    TLSETF();
    TLSETL(101576);
    pd = Language_Execute_RQHead;
    TLINCL();
    if (pd == ((struct Language_Execute_ProcessDescriptor *) 0)) {
	TLSETL(101578);
	pd = Language_Execute_EQHead;
    };
    TLSETL(101580);
    if (pd != ((struct Language_Execute_ProcessDescriptor *) 0)) {
	TLSETL(101581);
	pd->stepSpec = step;
	TLINCL();
	if (step == 3) {
	    TLSETL(101583);
	    if ((unsigned long) (pd->fp) == 0) {
		TLSETL(101584);
		pd->stepSpec = 0;
		TLINCL();
		pd->stepFP = (TLaddressint) 0;
	    } else {
		TLSETL(101587);
		pd->stepFP = (TLaddressint) ((* (TLaddressint *) (pd->fp)));
	    };
	} else {
	    TLSETL(101590);
	    pd->stepFP = (TLaddressint) 0;
	};
    };
    TLRESTORELF();
}

extern void Math_Arctan ();

extern void Math_Arctand ();

extern void Math_Ceil ();

extern void Math_Cos ();

extern void Math_Cosd ();

extern void Math_Exp ();

extern void Math_Floor ();

extern void Math_Intreal ();

extern void Math_Ln ();

extern void Math_Natreal ();

extern void Math_Rand ();

extern void Math_Randint ();

extern void Math_Randnext ();

extern void Math_Randomize ();

extern void Math_Randseed ();

extern void Math_Round ();

extern void Math_Sign ();

extern void Math_Sin ();

extern void Math_Sind ();

extern void Math_Sqrt ();

extern void String_Erealstr ();

extern void String_Frealstr ();

extern void String_Index ();

extern void String_Length ();

extern void String_Realstr ();

extern void String_Repeat ();

extern void String_Strreal ();

extern void Language_Execute_System_Clock ();

extern void Language_Execute_System_Date ();

extern void Language_Execute_System_Fetcharg ();

extern void Language_Execute_System_Flushstreams ();

extern void Language_Execute_System_Getenv ();

extern void Language_Execute_System_Getpid ();

extern void Language_Execute_System_Nargs ();

extern void Language_Execute_System_Setactive ();

extern void Language_Execute_System_Simutime ();

extern void Language_Execute_System_Sysclock ();

extern void Language_Execute_System_System ();

extern void Language_Execute_System_Time ();

extern void Language_Execute_System_Wallclock ();

extern void Limits_Getexp ();

extern void Limits_Rreb ();

extern void Limits_Setexp ();

extern void Language_Execute_Graphics_Drawpic ();

extern void Language_Execute_Graphics_Getch ();

extern void Language_Execute_Graphics_Hasch ();

extern void Language_Execute_Graphics_Sizepic ();

extern void Language_Execute_Graphics_Takepic ();

extern void Language_Execute_Event_Getevent ();

extern void Language_Execute_Event_Hasevent ();

extern void MT_InterpretIfc ();

extern void Star_initialize ();

extern void Star_getToken ();

extern void Star_finalize ();
struct	Language_Execute_RunDescriptor {
    Language_ReturnState	state;
    TLboolean	doQuit;
};

extern void Language_Execute_Run ();
extern TLint4	TL_TLI_TLIARC;

extern void TL_TLI_TLIFA ();

extern void TL_TLX_TLXGE ();

extern void TL_TLX_TLXDT ();

extern void TL_TLX_TLXTM ();

extern void TL_TLX_TLXCL ();

extern void TL_TLX_TLXSC ();

extern void time ();

extern void TL_TLX_TLXSYS ();

extern TLint4 getpid ();

extern void TL_TLI_TLIFS ();

extern void TL_TLK_TLKUEXIT ();
extern TLnat4	TL_TLK_TLKTIME;
extern TLnat4	TL_TLK_TLKEPOCH;

extern void TL_TLK_TLKUDMPA ();

extern void TL_TLK_TLKCINI ();
extern TLboolean	TL_TLK_TLKCLKON;
extern TLnat4	TL_TLK_TLKHZ;
extern TLnat4	TL_TLK_TLKCRESO;
extern TLnat4	TL_TLK_TLKTIME;
extern TLnat4	TL_TLK_TLKEPOCH;

extern void TL_TLK_TLKPSID ();

extern TLnat4 TL_TLK_TLKPGID ();

extern void TL_TLK_TLKRSETP ();

void Language_Execute_Executor (runStatus)
struct Language_RunStatus	*runStatus;
{
    struct TLHAREA	quitCode;
    TLSTKCHKSLF(101643);
    if (TLHANDENTER(quitCode)) {
	TLSETF();
	TLSETL(101643);
	(*runStatus).state = 0;
	TLSETL(101645);
	if (Language_Execute_RQHead != ((struct Language_Execute_ProcessDescriptor *) 0)) {
	    TLSETL(101646);
	    Language_Execute_RQHead->pc = (TLaddressint) Language_Execute_globalPC;
	    TLINCL();
	    Language_Execute_RQHead->sp = (TLaddressint) Language_Execute_globalSP;
	    TLINCL();
	    TLSTRCTASS((*runStatus).srcPos, Language_Execute_RQHead->srcPos, struct SrcPosition);
	} else {
	    TLSETL(101650);
	    TLSTRCTASS((*runStatus).srcPos, Language_nullSrcPosition, struct SrcPosition);
	};
	TLSETL(101652);
	(*runStatus).threadId = (TLaddressint) (* (TLnat4 *) &Language_Execute_RQHead);
	TLSETL(101654);
	TL_TLI_TLIFS();
	if (quitCode.quitCode != 1) {
	    TLSETL(101655);
	    TL_TLE_TLEQUIT ((TLint4) quitCode.quitCode, (char *) 0, 1);
	};
    } else {
	struct Language_Execute_ProcessDescriptor	*oldRQHead;
	struct Language_Execute_RunDescriptor	runDesc;
	TLSETF();
	TLSETL(101661);
	oldRQHead = Language_Execute_RQHead;
	TLSETL(101664);
	Language_Execute_EventQueueDispatch();
	TLINCL();
	Language_Execute_Kernel_RunQueueDispatch();
	if (Language_Execute_RQHead == ((struct Language_Execute_ProcessDescriptor *) 0)) {
	    TLSETL(101666);
	    if (Language_Execute_EQHead == ((struct Language_Execute_ProcessDescriptor *) 0)) {
		TLSETL(101667);
		(*runStatus).state = 0;
	    } else {
		TLSETL(101669);
		if (Language_Execute_allWaitingForKeyboard) {
		    TLSETL(101670);
		    (*runStatus).state = 6;
		} else {
		    TLSETL(101671);
		    if (Language_Execute_allWaitingForMouse) {
			TLSETL(101672);
			(*runStatus).state = 7;
		    } else {
			TLSETL(101673);
			if (Language_Execute_allWaitingForDelay) {
			    TLSETL(101674);
			    (*runStatus).state = 8;
			    TLINCL();
			    (*runStatus).moreStateInfo = Language_Execute_minimumDelayCount;
			} else {
			    TLSETL(101677);
			    (*runStatus).state = 2;
			};
		    };
		};
	    };
	    TLSETL(101680);
	    TLSTRCTASS((*runStatus).srcPos, Language_nullSrcPosition, struct SrcPosition);
	    TLINCL();
	    (*runStatus).threadId = (TLaddressint) 0;
	    TLSETL(101684);
	    TL_TLE_TLEHX();
	    TLRESTORELF();
	    return;
	} else {
	    TLSETL(101684);
	    if (Language_Execute_RQHead != oldRQHead) {
		TLSETL(101685);
		Language_Execute_quantaCount = 20;
		TLINCL();
		if ((oldRQHead == ((struct Language_Execute_ProcessDescriptor *) 0)) || ((oldRQHead->stepSpec) != 0)) {
		    TLSETL(101688);
		    (*runStatus).state = 5;
		    TLINCL();
		    TLSTRCTASS((*runStatus).srcPos, Language_Execute_RQHead->srcPos, struct SrcPosition);
		    TLINCL();
		    (*runStatus).threadId = (TLaddressint) (* (TLnat4 *) &Language_Execute_RQHead);
		    TLSETL(101693);
		    TL_TLE_TLEHX();
		    TLRESTORELF();
		    return;
		};
	    };
	};
	TLSETL(101696);
	Language_Execute_globalPC = (TLaddressint) (Language_Execute_RQHead->pc);
	TLINCL();
	Language_Execute_globalSP = (TLaddressint) (Language_Execute_RQHead->sp);
	TLSETL(101699);
	if ((unsigned long) Language_Execute_savedInitPC == (unsigned long) Language_Execute_globalPC) {
	    TLSETL(101700);
	    Language_Execute_savedInitPC = (TLaddressint) 0;
	    TLINCL();
	    Language_Execute_savedInitFP = (TLaddressint) 0;
	};
	TLSETL(101706);
	Language_Execute_SetActive(&(Language_Execute_RQHead->activeStream));
	TLSETL(101708);
	for(;;) {
	    TLSETL(101709);
	    Language_Execute_Run(&(runDesc));
	    if (!(runDesc.doQuit)) {
		break;
	    };
	    TLSETL(101712);
	    Language_Execute_ExecutionError_GetAbort(&(Language_Execute_RQHead->abort.quitCode), Language_Execute_RQHead->abort.errorMsg);
	    TLINCL();
	    Language_Execute_DispatchHandler((TLint4) (Language_Execute_RQHead->abort.quitCode));
	};
	TLSETL(101714);
	(*runStatus).state = runDesc.state;
	TLSETL(101716);
	if (Language_Execute_RQHead != ((struct Language_Execute_ProcessDescriptor *) 0)) {
	    TLSETL(101717);
	    Language_Execute_RQHead->pc = (TLaddressint) Language_Execute_globalPC;
	    TLINCL();
	    Language_Execute_RQHead->sp = (TLaddressint) Language_Execute_globalSP;
	    TLINCL();
	    TLSTRCTASS((*runStatus).srcPos, Language_Execute_RQHead->srcPos, struct SrcPosition);
	} else {
	    TLSETL(101721);
	    TLSTRCTASS((*runStatus).srcPos, Language_nullSrcPosition, struct SrcPosition);
	};
	TLSETL(101723);
	(*runStatus).threadId = (TLaddressint) (* (TLnat4 *) &Language_Execute_RQHead);
	TL_TLE_TLEHX();
    }
}

void Language_Execute () {
    TLSAVELF();
    TLSETF();
    TLSETL(100129);
    Language_Execute_externalExecutionTimeoutFlag = 0;
    TLSETL(100131);
    Language_Execute_stackAllocated = 0;
    ExecutionError();
    Language_Execute_Heap();
    MIO();
    TLSETL(100181);
    Language_Execute_numArguments = 0;
    TLSETL(100186);
    Language_Execute_numFilesOpen = 0;
    TLSETL(100191);
    Language_Execute_fileMap[0] = -2;
    TLINCL();
    Language_Execute_fileMap[1] = -1;
    TLINCL();
    Language_Execute_fileMap[2] = -1;
    TLINCL();
    {
	register TLint4	i;
	for (i = 1; i <= 20; i++) {
	    TLSETL(100195);
	    Language_Execute_fileMap[TLINRANGELOW(i, -2, 20, 1)] = -3;
	    TLINCL();
	    Language_Execute_argumentNames[TLINRANGELOW(i, 0, 20, 1)] = (Language_StringDef *) 0;
	};
    };
    TLSETL(100214);
    TL_TLI_TLIUXS = 1;
    TLSETL(100231);
    Language_Execute_RQHead = (struct Language_Execute_ProcessDescriptor *) 0;
    TLINCL();
    Language_Execute_EQHead = (struct Language_Execute_ProcessDescriptor *) 0;
    TLINCL();
    Language_Execute_Chrono = 0;
    TLINCL();
    Language_Execute_processCount = 0;
    TLSETL(100309);
    Language_Execute_failedOpenStream = -10;
    Language_Execute_Kernel();
    Math();
    String();
    Language_Execute_System();
    Limits();
    Language_Execute_Graphics();
    Language_Execute_Event();
    MT();
    Star();
    TLRESTORELF();
}
