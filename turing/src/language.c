#include "cinterface"
static struct {
    TLint4	dummy;
    char	dummy2[840];
} TLFTAB =
    { 17,
    {'/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '.', 'b', 'd', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', '.', '.', '/', 'f', 'i', 'l', 'e', 'm', 'a', 'n', '/', 'f', 'i', 'l', 'e', 'm', 'a', 'n', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'd', 'u', 'm', 'm', 'y', '.', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'n', 'v', 'i', 'r', 'o', 'n', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'm', 's', 'g', 's', '.', 'd', 'e', 'f', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'd', 'e', 'b', 'u', 'g', '.', 'd', 'e', 'f', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'u', 'n', 'i', 't', 'm', 'a', 'n', '/', 'u', 'n', 'i', 't', 'm', 'a', 'n', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'r', 'r', 'o', 'r', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'p', 's', 'e', 'u', 'd', 'o', '.', 'd', 'e', 'f', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'o', 'p', 'c', 'o', 'd', 'e', '.', 'i', 'n', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'd', 'e', 'b', 'u', 'g', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'e', 'x', 'e', 'c', 'u', 't', 'e', '.', 's', 't', '\0',
    '/', 'l', 'o', 'c', 'a', 'l', '/', 'i', 'n', 'c', 'l', 'u', 'd', 'e', '/', 't', 'p', 'l', 'u', 's', '/', 'D', 'O', 'S', '3', '2', '/', 'm', 'e', 'm', 'o', 'r', 'y', '\0',
    '/', 'l', 'o', 'c', 'a', 'l', '/', 'i', 'n', 'c', 'l', 'u', 'd', 'e', '/', 't', 'p', 'l', 'u', 's', '/', 'c', 'o', 'm', 'm', 'o', 'n', '/', 's', 'y', 's', 't', 'e', 'm', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'p', 'a', 'r', 'a', '/', 'p', 'a', 'r', 'a', 'O', 'O', 'T', '.', 'c', 'h', '\0'
    }};
typedef	TLnat2	FileManager_FileNoType;
typedef	TLnat4	FileManager_FileTimeStamp;
typedef	TLint2	FileManager_ResultCode;

extern void FileManager_OpenNamedHandle ();

extern void FileManager_OpenUnnamedHandle ();

extern void FileManager_OpenFileHandle ();

extern void FileManager_SetModified ();

extern void FileManager_WriteFile ();

extern void FileManager_WriteBackup ();

extern void FileManager_WriteTemp ();

extern void FileManager_RmTemp ();

extern void FileManager_CloseFileHandle ();

extern void FileManager_OpenNamedText ();

extern void FileManager_OpenFileText ();

extern void FileManager_CloseFileText ();

extern void FileManager_CloseAllText ();

extern void FileManager_ChangeDirectory ();

extern void FileManager_GetDirectory ();

extern void FileManager_ChangeExecDirectory ();

extern void FileManager_GetExecDirectory ();

extern void FileManager_ShortName ();

extern void FileManager_RelativeName ();

extern void FileManager_PathName ();

extern void FileManager_ExecPathName ();

extern void FileManager_ExtendName ();

extern void FileManager_FileName ();

extern TLboolean FileManager_IsUnnamed ();

extern TLboolean FileManager_IsOnDisk ();

extern TLboolean FileManager_IsSameFile ();

extern TLboolean FileManager_IsReadOK ();

extern TLboolean FileManager_IsWriteOK ();

extern TLboolean FileManager_IsOlder ();

extern TLboolean FileManager_FileExists ();

extern void FileManager_AddReference ();

extern void FileManager_DeleteReference ();

extern void FileManager_ReadTimeStamp ();

extern void FileManager_FlushUnreferencedFiles ();

extern void FileManager_CheckReferencedFiles ();

extern void FileManager_RmFile ();

extern void FileManager_SetDefaultInclude ();

extern void FileManager_AssertTextClosed ();

extern void FileManager_Dump ();

extern void FeedBack ();
struct	SrcPosition {
    TLnat2	lineNo;
    FileManager_FileNoType	fileNo;
    TLnat2	linePos;
    TLnat2	tokLen;
};
typedef	TLchar	__x1100[256];
struct	ErrMsgDef {
    struct ErrMsgDef	*next;
    struct SrcPosition	srcPos;
    __x1100	text;
};
typedef	TLint4	CookieKind;
struct	Cookie {
    CookieKind	kind;
    TLaddressint	item;
    TLaddressint	fp;
    TLaddressint	data;
};
struct	CallDef {
    struct CallDef	*next;
    TLstring	routineName;
    struct SrcPosition	srcPos;
    struct Cookie	cookie;
};
struct	ThreadDef {
    struct ThreadDef	*next;
    TLaddressint	threadId;
    TLaddressint	threadName;
    struct CallDef	*traceback;
};
struct	ThreadQueueDef {
    struct ThreadQueueDef	*next;
    TLaddressint	queueId;
    TLstring	queueName;
    struct ThreadDef	*threadList;
};
struct	DumpIndexDef {
    struct DumpIndexDef	*next;
    TLint4	lowerBound;
    TLint4	upperBound;
};
struct	DumpSymbolDef {
    struct DumpSymbolDef	*next;
    TLaddressint	symbolName;
    TLaddressint	typeName;
    struct SrcPosition	srcPos;
    TLstring	value;
    struct Cookie	cookie;
    TLboolean	isPredef;
};
struct	DumpScopeDef {
    struct DumpSymbolDef	symbolInfo;
    struct Cookie	expandCookie;
    struct DumpSymbolDef	*parameters;
    struct DumpSymbolDef	*declarations;
};

void Language_Debugging ();

void Language_Paragraph ();

void Language_Reset ();

void Language_SetMaxErrorCount ();
typedef	TLstring	__x1101[20];

void Language_EnterPreprocSymbols ();

void Language_CompileUnit ();

void Language_CompileProgram ();

void Language_WriteObjectFile ();
typedef	TLstring	__x1104[21];

typedef	TLstring	__x1108[21];
void Language_SetupExecution ();
typedef	TLint1	Language_Step;

void Language_SetStep ();
typedef	TLint1	Language_ReturnState;
struct	Language_RunStatus {
    Language_ReturnState	state;
    TLint4	moreStateInfo;
    struct SrcPosition	srcPos;
    TLaddressint	threadId;
};

void Language_ExecuteProgram ();

void Language_EndExecution ();

void Language_StopExecution ();

void Language_DumpThreadList ();

void Language_DumpUnitList ();

void Language_DumpScopeInfo ();

void Language_DumpSymbolInfo ();

void Language_DumpArrayBounds ();

void Language_DumpArrayValues ();
TLboolean	Language_debug;

void Language_Debugging (val)
TLboolean	val;
{
    TLSTKCHKSLF(100065);
    TLSETF();
    TLSETL(100065);
    Language_debug = val;
    TLRESTORELF();
}
struct SrcPosition	Language_nullSrcPosition = 
    {0, 0, 0, 0};
struct Cookie	Language_nullCookie = 
    {0, 0, 0, 0};
struct DumpSymbolDef	Language_nullSymbolDef;
struct DumpScopeDef	Language_nullScopeDef;
typedef	TLint1	Language_UnitManager_UnitKind;
typedef	TLint1	Language_UnitManager_UnitStatus;

extern void Language_UnitManager_AddDepend ();

extern void Language_UnitManager_AddIncludeFile ();

extern void Language_UnitManager_AllocateCompileChunk ();

extern void * Language_UnitManager_BodyUnit ();

extern void Language_UnitManager_ClearAllMarks ();

extern void Language_UnitManager_ClearConfiguration ();

extern TLaddressint Language_UnitManager_CodeTable ();

extern FileManager_FileNoType Language_UnitManager_FileNo ();

extern void Language_UnitManager_FlushOldUnits ();

extern void Language_UnitManager_GetNextDepend ();

extern void Language_UnitManager_GetNextUnit ();

extern void Language_UnitManager_GetUnitPtr ();

extern TLaddressint Language_UnitManager_GlobalArea ();

extern TLint4 Language_UnitManager_GlobalSize ();

extern TLboolean Language_UnitManager_IsCompiled ();

extern TLboolean Language_UnitManager_IsMarked ();

extern TLboolean Language_UnitManager_IsPredef ();

extern Language_UnitManager_UnitKind Language_UnitManager_Kind ();

extern TLaddressint Language_UnitManager_ManifestTable ();

extern void * Language_UnitManager_OverrideBody ();

extern void Language_UnitManager_PrepareForCompile ();

extern void Language_UnitManager_PrepareForDepends ();

extern void Language_UnitManager_PrepareForScan ();

extern void Language_UnitManager_Reset ();

extern void Language_UnitManager_RewindDependList ();

extern void Language_UnitManager_RewindUnitList ();

extern void Language_UnitManager_SetCodeTable ();

extern void Language_UnitManager_SetDefaultBody ();

extern void Language_UnitManager_SetGlobalArea ();

extern void Language_UnitManager_SetKind ();

extern void Language_UnitManager_SetManifestTable ();

extern void Language_UnitManager_SetMark ();

extern void Language_UnitManager_SetOverrideBody ();

extern void Language_UnitManager_SetPredef ();

extern void Language_UnitManager_SetStub ();

extern void Language_UnitManager_SetSymbolTable ();

extern void Language_UnitManager_StartNewProgram ();

extern void * Language_UnitManager_StubUnit ();

extern void Language_UnitManager_SuccessfulCompile ();

extern TLaddressint Language_UnitManager_SymbolTable ();
typedef	TLint1	Language_ErrorModule_Severity;

extern void Language_ErrorModule_Initialize ();

extern void Language_ErrorModule_SetMaxErrors ();

extern void Language_ErrorModule_Message ();

extern void Language_ErrorModule_AbortIfErrors ();

extern void Language_ErrorModule_ReturnErrors ();
typedef	Language_ErrorModule_Severity	Language_ErrorSeverity;

void Language_SetMaxErrorCount (maxErrorCount)
TLint4	maxErrorCount;
{
    TLSTKCHKSLF(100109);
    TLSETF();
    TLSETL(100109);
    Language_ErrorModule_SetMaxErrors((TLint4) maxErrorCount);
    TLRESTORELF();
}

typedef	TLstring	Language_StringDef;
typedef	TLnat4	Language_Offset;
TLint4	Language_codeOprSize;
TLint4	Language_codeInt1Size;
TLint4	Language_codeInt2Size;
TLint4	Language_codeIntSize;
TLint4	Language_codeRealSize;
TLint4	Language_codeAddrSize;
TLint4	Language_codeOffsetSize;
typedef	TLchar	Language_string1[2];
typedef	TLnat1	Language_set8;
typedef	TLnat2	Language_set16;
typedef	TLnat4	Language_set32;
typedef	TLint2	Language_Opcode;
typedef	TLchar	Language___x1112[22];
typedef	Language___x1112	Language___x1111[255];
Language___x1111	Language_OpcodeName = 
    {"ABORT", "ABORTCOND", "ABSINT", "ABSREAL", "ADDINT", "ADDINTNAT", "ADDNAT", "ADDNATINT", "ADDREAL", "ADDSET",
    "ALLOCFLEXARRAY", "ALLOCGLOB", "ALLOCGLOBARRAY", "ALLOCLOC", "ALLOCLOCARRAY", "AND", "ARRAYUPPER", "ASNADDR", "ASNADDRINV", "ASNINT",
    "ASNINTINV", "ASNINT1", "ASNINT1INV", "ASNINT2", "ASNINT2INV", "ASNINT4", "ASNINT4INV", "ASNNAT", "ASNNATINV", "ASNNAT1",
    "ASNNAT1INV", "ASNNAT2", "ASNNAT2INV", "ASNNAT4", "ASNNAT4INV", "ASNNONSCALAR", "ASNNONSCALARINV", "ASNPTR", "ASNPTRINV", "ASNREAL",
    "ASNREALINV", "ASNREAL4", "ASNREAL4INV", "ASNREAL8", "ASNREAL8INV", "ASNSTR", "ASNSTRINV", "BEGINHANDLER", "BITSASSIGN", "BITSEXTRACT",
    "CALL", "CALLEXTERNAL", "CALLIMPLEMENTBY", "CASE", "CAT", "CHARSUBSTR1", "CHARSUBSTR2", "CHARTOCSTR", "CHARTOSTR", "CHARTOSTRLEFT",
    "CHKCHRSTRSIZE", "CHKCSTRRANGE", "CHKRANGE", "CHKSTRRANGE", "CHKSTRSIZE", "CLOSE", "COPYARRAYDESC", "CSTRTOCHAR", "CSTRTOSTR", "CSTRTOSTRLEFT",
    "DEALLOCFLEXARRAY", "DECSP", "DIVINT", "DIVNAT", "DIVREAL", "EMPTY", "ENDFOR", "EOF", "EQADDR", "EQCHARN",
    "EQINT", "EQINTNAT", "EQNAT", "EQREAL", "EQSET", "EQSTR", "EXPINTINT", "EXPREALINT", "EXPREALREAL", "FETCHADDR",
    "FETCHBOOL", "FETCHINT", "FETCHINT1", "FETCHINT2", "FETCHINT4", "FETCHNAT", "FETCHNAT1", "FETCHNAT2", "FETCHNAT4", "FETCHPTR",
    "FETCHREAL", "FETCHREAL4", "FETCHREAL8", "FETCHSET", "FETCHSTR", "FIELD", "FOR", "FORK", "FREE", "FREECLASS",
    "FREEU", "GECHARN", "GECLASS", "GEINT", "GEINTNAT", "GENAT", "GENATINT", "GEREAL", "GESET", "GESTR",
    "GET", "GETPRIORITY", "GTCLASS", "IF", "IN", "INCLINENO", "INCSP", "INFIXAND", "INFIXOR", "INITARRAYDESC",
    "INITCONDITION", "INITMONITOR", "INITUNIT", "INTREAL", "INTREALLEFT", "INTSTR", "JSR", "JUMP", "JUMPB", "LECHARN",
    "LECLASS", "LEINT", "LEINTNAT", "LENAT", "LENATINT", "LEREAL", "LESET", "LESTR", "LOCATEARG", "LOCATECLASS",
    "LOCATELOC", "LOCATEPARM", "LOCATETEMP", "LTCLASS", "MAXINT", "MAXNAT", "MAXREAL", "MININT", "MINNAT", "MINREAL",
    "MODINT", "MODNAT", "MODREAL", "MONITORENTER", "MONITOREXIT", "MULINT", "MULNAT", "MULREAL", "MULSET", "NATREAL",
    "NATREALLEFT", "NATSTR", "NEGINT", "NEGREAL", "NEW", "NEWARRAY", "NEWCLASS", "NEWU", "NOT", "NUMARRAYELEMENTS",
    "OBJCLASS", "OPEN", "OR", "ORD", "PAUSE", "PRED", "PROC", "PUSHADDR", "PUSHADDR1", "PUSHCOPY",
    "PUSHINT", "PUSHINT1", "PUSHINT2", "PUSHREAL", "PUSHVAL0", "PUSHVAL1", "PUT", "QUIT", "READ", "REALDIVIDE",
    "REMINT", "REMREAL", "RESOLVEDEF", "RESOLVEPTR", "RESTORESP", "RETURN", "RTS", "SAVESP", "SEEK", "SEEKSTAR",
    "SETALL", "SETCLR", "SETELEMENT", "SETFILENO", "SETLINENO", "SETPRIORITY", "SETSTDSTREAM", "SETSTREAM", "SHL", "SHR",
    "SIGNAL", "STRINT", "STRINTOK", "STRNAT", "STRNATOK", "STRTOCHAR", "SUBINT", "SUBINTNAT", "SUBNAT", "SUBNATINT",
    "SUBREAL", "SUBSCRIPT", "SUBSET", "SUBSTR1", "SUBSTR2", "SUCC", "TAG", "TELL", "UFIELD", "UNINIT",
    "UNINITADDR", "UNINITBOOLEAN", "UNINITINT", "UNINITNAT", "UNINITREAL", "UNINITSTR", "UNLINKHANDLER", "VSUBSCRIPT", "WAIT", "WRITE",
    "XOR", "XORSET", "BREAK", "SYSEXIT", "ILLEGAL"};
struct	Language_CodeHeader {
    TLaddressint	bodyCode;
};
struct	Language___x1114 {
    TLint4	lower, range;
};
typedef	struct Language___x1114	Language___x1113[255];
struct	Language_ArrayDescriptor {
    TLnat4	sizeArray;
    TLnat4	sizeElement;
    TLnat4	elementCount;
    TLnat4	numDimensions;
    Language___x1113	dim;
};
struct	Language_ForDescriptor {
    TLint4	counter;
    TLint4	right;
    TLint4	step;
    TLaddressint	savedSP;
};
typedef	Language_Offset	Language___x1115[1001];
struct	Language_CaseDescriptor {
    TLint4	lower, upper;
    Language_Offset	otherwise;
    Language___x1115	caseVector;
};
struct	Language_PointerDescriptor {
    TLaddressint	dataPtr;
    TLint4	timestamp;
};
typedef	TLnat2	Language___x1116[301];
struct	Language_UnionMapDescriptor {
    TLint4	lower, upper;
    Language___x1116	map;
};
typedef	TLnat4	Language_ClassAttr;
struct	Language_ClassDescriptor {
    TLaddressint	baseClass;
    TLaddressint	expandClass;
    Language_ClassAttr	attributes;
    TLnat4	objSize;
    TLaddressint	classId;
    TLaddressint	initRoutine;
    TLnat4	numOperations;
};
typedef	TLint1	Language_OpenKind;
typedef	TLint1	Language_PutKind;
typedef	TLint1	Language_GetKind;
typedef	TLint1	Language_SetStreamKind;
typedef	TLnat1	Language_StreamModeSet;
typedef	TLint1	Language_SubstringKind;
typedef	TLint1	Language_RangeCheckKind;
typedef	TLint1	Language_ConditionKind;

extern void Language_DebugModule_Initialize ();

extern void Language_DebugModule_NewQueue ();

extern void Language_DebugModule_NewThread ();

extern void Language_DebugModule_NewCall ();

extern void Language_DebugModule_ReturnThreadDump ();

extern void Language_DebugModule_NewSymbolList ();

extern void Language_DebugModule_NewSymbol ();

extern void Language_DebugModule_ReturnSymbolDump ();

extern void Language_DebugModule_NewIndexList ();

extern void Language_DebugModule_NewIndex ();

extern void Language_DebugModule_ReturnIndexDump ();

extern void Language_Compile_Reset ();

extern void Language_Compile_Initialize ();
typedef	TLstring	__x1119[20];

extern void Language_Compile_EnterPreprocSymbols ();

extern void Language_Compile_ScanUnit ();

extern void Language_Compile_CompileUnit ();

extern void Language_Compile_InstallUnit ();

extern void Language_Compile_CallInfo ();

extern void Language_Compile_DumpUnitList ();

extern void Language_Compile_DumpScopeInfo ();

extern void Language_Compile_DumpSymbolInfo ();

extern void Language_Compile_DumpArrayBounds ();

extern void Language_Compile_DumpArrayValues ();

extern void Language_Compile_SetObjectFileStream ();
typedef	TLstring	__x1122[21];

extern void Language_Execute_Initialize ();

extern TLint4 Language_Execute_GetStackAllocated ();

extern void Language_Execute_Executor ();

extern void Language_Execute_EndExecution ();

extern void Language_Execute_RecoverAllMemory ();

extern void Language_Execute_SetStep ();

extern void Language_Execute_DumpThreadList ();

extern void Language_Execute_UnitInitState ();

/*





*/

void Language_Reset () {
    TLSTKCHKSLF(100171);
    TLSETF();
    TLSETL(100171);
    Language_ErrorModule_Initialize();
    TLSETL(100174);
    Language_UnitManager_Reset();
    TLSETL(100177);
    Language_DebugModule_Initialize();
    TLSETL(100180);
    Language_Compile_Reset();
    TLSETL(100182);
    Language_Execute_RecoverAllMemory();
    TLRESTORELF();
}
typedef	TLstring	Language___x1125[20];
static Language___x1125	Language_preprocDefs;
static TLint4	Language_preprocCount;
static TLboolean	Language_newPreprocs;

void Language_EnterPreprocSymbols (defs, numDefs)
__x1101	defs;
TLint4	numDefs;
{
    TLSTKCHKSLF(100193);
    TLSETF();
    TLSETL(100193);
    TLNONSCLASS(Language_preprocDefs, defs, Language___x1125);
    TLINCL();
    Language_preprocCount = numDefs;
    TLINCL();
    Language_newPreprocs = 1;
    TLRESTORELF();
}
static void	*Language_mainUnitPtr;

static void Language_Initialize () {
    TLSTKCHKSLF(100209);
    TLSETF();
    TLSETL(100209);
    Language_ErrorModule_Initialize();
    TLSETL(100213);
    Language_DebugModule_Initialize();
    if (Language_newPreprocs) {
	TLSETL(100215);
	Language_UnitManager_Reset();
	TLINCL();
	Language_Compile_Reset();
	TLINCL();
	Language_Compile_Initialize();
	TLINCL();
	Language_Compile_EnterPreprocSymbols(Language_preprocDefs, (TLint4) Language_preprocCount);
	Language_newPreprocs = 0;
    } else {
	TLSETL(100221);
	Language_Compile_Initialize();
    };
    TLSETL(100231);
    // Language_Execute_RecoverAllMemory();
    TLINCL();
    Language_UnitManager_StartNewProgram();
    Language_mainUnitPtr = (void *) 0;
    TLRESTORELF();
}
extern TLint4	TL_TLI_TLIARC;

extern void TL_TLI_TLIFA ();

extern void TL_TLX_TLXGE ();

extern void TL_TLX_TLXDT ();

extern void TL_TLX_TLXTM ();

extern void TL_TLX_TLXCL ();

extern void TL_TLX_TLXSC ();

extern void time ();

extern void TL_TLX_TLXSYS ();

extern TLint4 getpid ();

extern void TL_TLI_TLIFS ();

extern void TL_TLK_TLKUEXIT ();
extern TLnat4	TL_TLK_TLKTIME;
extern TLnat4	TL_TLK_TLKEPOCH;

extern void TL_TLK_TLKUDMPA ();

extern void TL_TLK_TLKCINI ();
extern TLboolean	TL_TLK_TLKCLKON;
extern TLnat4	TL_TLK_TLKHZ;
extern TLnat4	TL_TLK_TLKCRESO;
extern TLnat4	TL_TLK_TLKTIME;
extern TLnat4	TL_TLK_TLKEPOCH;

extern void TL_TLK_TLKPSID ();

extern TLnat4 TL_TLK_TLKPGID ();

extern void TL_TLK_TLKRSETP ();


static void Language_ScanUnitPtr (unitPtr, unitKind)
void	*unitPtr;
Language_UnitManager_UnitKind	unitKind;
{
    Language_UnitManager_UnitStatus	unitStatus;
    void	*bodyUnit;
    TLSTKCHKSLF(100247);
    TLSETF();
    TLSETL(100247);
    TLPRE (unitPtr != ((void *) 0));
    TLSETL(100251);
    Language_UnitManager_PrepareForScan(unitPtr, &(unitStatus));
    if (unitStatus == 2) {
	TLSETL(100256);
	TLRESTORELF();
	return;
    };
    TLSETL(100258);
    TLSETL(100262);
    if (unitStatus == 0) {
	TLSETL(100264);
	if (Language_debug) {
	    FileManager_FileNoType	fileNo;
	    TLSETL(100265);
	    TL_TLI_TLISS ((TLint4) 0, (TLint2) 2);
	    TL_TLI_TLIPS ((TLint4) 0, "Scanning ", (TLint2) 0);
	    TLINCL();
	    fileNo = Language_UnitManager_FileNo(unitPtr);
	    TLSETL(100268);
	    if (fileNo == 0) {
		TLSETL(100269);
		TL_TLI_TLISS ((TLint4) 0, (TLint2) 2);
		TL_TLI_TLIPS ((TLint4) 0, "builtins", (TLint2) 0);
		TL_TLI_TLIPK ((TLint2) 0);
	    } else {
		TLSETL(100271);
		{
		    TLstring	__x1130;
		    FileManager_FileName((FileManager_FileNoType) fileNo, __x1130);
		    TL_TLI_TLISS ((TLint4) 0, (TLint2) 2);
		    TL_TLI_TLIPS ((TLint4) 0, __x1130, (TLint2) 0);
		    TL_TLI_TLIPK ((TLint2) 0);
		};
	    };
	};
	TLSETL(100276);
	Language_Compile_ScanUnit(unitPtr, (Language_UnitManager_UnitKind) unitKind);
	TLSETL(100278);
	Language_ErrorModule_AbortIfErrors();
	TLSETL(100280);
	FileManager_AssertTextClosed();
    };
    TLSETL(100286);
    Language_UnitManager_RewindDependList(unitPtr);
    switch (Language_UnitManager_Kind(unitPtr)) {
	case 3:
	    {
		void	*mainUnit;
		TLSETL(100290);
		Language_UnitManager_GetNextDepend(unitPtr, &(mainUnit));
		TLASSERT (mainUnit != ((void *) 0));
		TLSETL(100292);
		Language_ScanUnitPtr(mainUnit, (Language_UnitManager_UnitKind) 5);
	    }
	    break;
	case 5:
	    {
		TLSETL(100293);
		if (Language_mainUnitPtr == ((void *) 0)) {
		    TLSETL(100294);
		    Language_mainUnitPtr = unitPtr;
		};
	    }
	    break;
	default :
	    break;
    };
    TLSETL(100299);
    for(;;) {
	void	*dependUnit;
	TLSETL(100301);
	Language_UnitManager_GetNextDepend(unitPtr, &(dependUnit));
	if (dependUnit == ((void *) 0)) {
	    break;
	};
	TLSETL(100303);
	Language_ScanUnitPtr(dependUnit, (Language_UnitManager_UnitKind) 4);
    };
    TLSETL(100305);
    bodyUnit = Language_UnitManager_BodyUnit(unitPtr);
    TLINCL();
    if (bodyUnit != ((void *) 0)) {
	TLSETL(100308);
	Language_ScanUnitPtr(bodyUnit, (Language_UnitManager_UnitKind) 4);
    };
    TLRESTORELF();
}

static void Language_ScanPredefs () {
    FileManager_FileNoType	fileNo;
    TLaddressint	textPtr;
    FileManager_ResultCode	resultCode;
    TLstring	predefFile;
    void	*unitPtr;
    TLSTKCHKSLF(100321);
    TLSETF();
    TLSETL(100321);
    {
	TLstring	__x1131;
	FileManager_PathName("%oot/support/predefs/Predefs.lst", __x1131);
	TLSTRASS(255, predefFile, __x1131);
    };
    TLSETL(100331);
    FileManager_OpenNamedText(predefFile, (FileManager_FileNoType) 0, &(fileNo), &(textPtr), &(resultCode));
    if (fileNo == 0) {
	TLSETL(100335);
	{
	    TLstring	__x1133;
	    TL_TLS_TLSCAT("Unable to open predefs list file \'", predefFile, __x1133);
	    {
		TLstring	__x1132;
		TL_TLS_TLSCAT(__x1133, "\'", __x1132);
		Language_ErrorModule_Message(&(Language_nullSrcPosition), (Language_ErrorModule_Severity) 3, __x1132);
	    };
	};
    } else {
	TLSETL(100335);
	if (resultCode == 3) {
	    struct SrcPosition	srcPos;
	    TLSETL(100336);
	    TLSTRCTASS(srcPos, Language_nullSrcPosition, struct SrcPosition);
	    TLINCL();
	    srcPos.fileNo = fileNo;
	    TLSETL(100340);
	    Language_ErrorModule_Message(&(srcPos), (Language_ErrorModule_Severity) 1, "Predefs list file contains non-ascii characters (deleted)");
	};
    };
    TLSETL(100343);
    FileManager_CloseFileText((FileManager_FileNoType) fileNo);
    TLSETL(100345);
    Language_UnitManager_GetUnitPtr((FileManager_FileNoType) fileNo, &(unitPtr));
    if (unitPtr == ((void *) 0)) {
	struct SrcPosition	srcPos;
	TLSETL(100346);
	TLSTRCTASS(srcPos, Language_nullSrcPosition, struct SrcPosition);
	TLINCL();
	srcPos.fileNo = fileNo;
	TLSETL(100351);
	Language_ErrorModule_Message(&(srcPos), (Language_ErrorModule_Severity) 3, "Can\'t allocate memory for unit descriptor");
    };
    TLSETL(100354);
    Language_ScanUnitPtr(unitPtr, (Language_UnitManager_UnitKind) 2);
    TLRESTORELF();
}

static void Language_CompileUnitPtr (unitPtr)
void	*unitPtr;
{
    Language_UnitManager_UnitStatus	unitStatus;
    FileManager_FileNoType	fileNo;
    TLstring	unitName;
    TLSTKCHKSLF(100358);
    TLSETF();
    TLSETL(100358);
    TLPRE (unitPtr != ((void *) 0));
    TLSETL(100362);
    Language_UnitManager_PrepareForDepends(unitPtr, &(unitStatus));
    if (unitStatus == 2) {
	TLSETL(100367);
	TLRESTORELF();
	return;
    };
    TLSETL(100369);
    TLSETL(100376);
    if (Language_UnitManager_Kind(unitPtr) == 3) {
	TLSETL(100377);
	TLASSERT (Language_mainUnitPtr != ((void *) 0));
	TLSETL(100379);
	Language_CompileUnitPtr(Language_mainUnitPtr);
    } else {
	TLSETL(100381);
	Language_UnitManager_RewindDependList(unitPtr);
	TLINCL();
	for(;;) {
	    void	*dependUnit;
	    TLSETL(100384);
	    Language_UnitManager_GetNextDepend(unitPtr, &(dependUnit));
	    if (dependUnit == ((void *) 0)) {
		break;
	    };
	    TLSETL(100386);
	    Language_CompileUnitPtr(dependUnit);
	};
    };
    TLSETL(100392);
    fileNo = Language_UnitManager_FileNo(unitPtr);
    TLSETL(100394);
    if (fileNo == 0) {
	TLSETL(100395);
	TLSTRASS(255, unitName, "builtins");
    } else {
	TLSETL(100397);
	{
	    TLstring	__x1134;
	    FileManager_FileName((FileManager_FileNoType) fileNo, __x1134);
	    TLSTRASS(255, unitName, __x1134);
	};
    };
    TLSETL(100413);
    Language_UnitManager_PrepareForCompile(unitPtr, &(unitStatus));
    if (unitStatus != 1) {
	TLSETL(100415);
	if (Language_debug) {
	    TLSETL(100416);
	    TL_TLI_TLISS ((TLint4) 0, (TLint2) 2);
	    TL_TLI_TLIPS ((TLint4) 0, "Compiling ", (TLint2) 0);
	    TL_TLI_TLIPS ((TLint4) 0, unitName, (TLint2) 0);
	    TL_TLI_TLIPK ((TLint2) 0);
	};
	TLSETL(100420);
	{
	    TLstring	__x1135;
	    TL_TLS_TLSCAT("Compiling ", unitName, __x1135);
	    FeedBack(__x1135);
	};
	TLINCL();
	Language_Compile_CompileUnit(unitPtr);
	TLINCL();
	TL_TLI_TLIFS();
	TLSETL(100424);
	Language_ErrorModule_AbortIfErrors();
	TLSETL(100426);
	FileManager_AssertTextClosed();
	TLSETL(100434);
	Language_UnitManager_SuccessfulCompile(unitPtr);
    } else {
	TLSETL(100442);
	if (Language_debug) {
	    TLSETL(100443);
	    TL_TLI_TLISS ((TLint4) 0, (TLint2) 2);
	    TL_TLI_TLIPS ((TLint4) 0, "Installing ", (TLint2) 0);
	    TL_TLI_TLIPS ((TLint4) 0, unitName, (TLint2) 0);
	    TL_TLI_TLIPK ((TLint2) 0);
	};
	TLSETL(100448);
	Language_Compile_InstallUnit(unitPtr);
    };
    TLRESTORELF();
}
static void	*Language_lastCompileUnit;

static void Language_CompileFile (fileName, fileNo, canBeUnit)
TLstring	fileName;
FileManager_FileNoType	fileNo;
TLboolean	canBeUnit;
{
    FileManager_FileNoType	compileFileNo;
    void	*compileUnitPtr;
    TLSTKCHKSLF(100458);
    TLSETF();
    TLSETL(100458);
    Language_Initialize();
    compileFileNo = fileNo;
    TLINCL();
    if (compileFileNo == 0) {
	TLaddressint	textPtr;
	FileManager_ResultCode	resultCode;
	TLSETL(100464);
	FileManager_OpenNamedText(fileName, (FileManager_FileNoType) 0, &(compileFileNo), &(textPtr), &(resultCode));
	if (compileFileNo == 0) {
	    TLSETL(100469);
	    {
		TLstring	__x1140;
		FileManager_PathName(fileName, __x1140);
		{
		    TLstring	__x1139;
		    TL_TLS_TLSCAT("Unable to open file \"", fileName, __x1139);
		    {
			TLstring	__x1138;
			TL_TLS_TLSCAT(__x1139, "\" [\"", __x1138);
			{
			    TLstring	__x1137;
			    TL_TLS_TLSCAT(__x1138, __x1140, __x1137);
			    {
				TLstring	__x1136;
				TL_TLS_TLSCAT(__x1137, "\"]", __x1136);
				Language_ErrorModule_Message(&(Language_nullSrcPosition), (Language_ErrorModule_Severity) 3, __x1136);
			    };
			};
		    };
		};
	    };
	} else {
	    TLSETL(100469);
	    if (resultCode == 3) {
		struct SrcPosition	srcPos;
		TLSETL(100470);
		TLSTRCTASS(srcPos, Language_nullSrcPosition, struct SrcPosition);
		TLINCL();
		srcPos.fileNo = compileFileNo;
		TLSETL(100475);
		{
		    TLstring	__x1142;
		    TL_TLS_TLSCAT("File \"", fileName, __x1142);
		    {
			TLstring	__x1141;
			TL_TLS_TLSCAT(__x1142, "\" contains non-ascii characters (deleted)", __x1141);
			Language_ErrorModule_Message(&(srcPos), (Language_ErrorModule_Severity) 1, __x1141);
		    };
		};
	    };
	};
	TLSETL(100477);
	FileManager_CloseFileText((FileManager_FileNoType) compileFileNo);
    };
    TLSETL(100485);
    Language_UnitManager_GetUnitPtr((FileManager_FileNoType) 0, &(compileUnitPtr));
    if (compileUnitPtr == ((void *) 0)) {
	struct SrcPosition	srcPos;
	TLSETL(100486);
	TLSTRCTASS(srcPos, Language_nullSrcPosition, struct SrcPosition);
	TLINCL();
	srcPos.fileNo = compileFileNo;
	TLSETL(100491);
	Language_ErrorModule_Message(&(srcPos), (Language_ErrorModule_Severity) 3, "Can\'t allocate memory for builtin unit descriptor");
    };
    TLSETL(100493);
    FeedBack("Initializing builtins");
    TLINCL();
    Language_ScanUnitPtr(compileUnitPtr, (Language_UnitManager_UnitKind) 1);
    TLSETL(100499);
    Language_CompileUnitPtr(compileUnitPtr);
    TLINCL();
    Language_UnitManager_GetUnitPtr((FileManager_FileNoType) compileFileNo, &(compileUnitPtr));
    if (compileUnitPtr == ((void *) 0)) {
	struct SrcPosition	srcPos;
	TLSETL(100501);
	TLSTRCTASS(srcPos, Language_nullSrcPosition, struct SrcPosition);
	TLINCL();
	srcPos.fileNo = compileFileNo;
	TLSETL(100506);
	Language_ErrorModule_Message(&(srcPos), (Language_ErrorModule_Severity) 3, "Can\'t allocate memory for unit descriptor");
    };
    TLSETL(100510);
    FeedBack("Generating dependency graph");
    if ((Language_lastCompileUnit == ((void *) 0)) || (compileUnitPtr != Language_lastCompileUnit)) {
	TLSETL(100513);
	Language_UnitManager_ClearConfiguration();
	Language_lastCompileUnit = compileUnitPtr;
    };
    TLSETL(100517);
    Language_ScanPredefs();
    if (canBeUnit) {
	TLSETL(100519);
	Language_ScanUnitPtr(compileUnitPtr, (Language_UnitManager_UnitKind) 0);
    } else {
	TLSETL(100521);
	Language_ScanUnitPtr(compileUnitPtr, (Language_UnitManager_UnitKind) 3);
	if (Language_mainUnitPtr == ((void *) 0)) {
	    struct SrcPosition	srcPos;
	    TLSETL(100526);
	    TLSTRCTASS(srcPos, Language_nullSrcPosition, struct SrcPosition);
	    TLINCL();
	    srcPos.fileNo = compileFileNo;
	    TLSETL(100530);
	    Language_ErrorModule_Message(&(srcPos), (Language_ErrorModule_Severity) 3, "Cannot have unit as main program");
	};
    };
    TLSETL(100537);
    Language_CompileUnitPtr(compileUnitPtr);
    TLRESTORELF();
}

void Language_CompileUnit (fileName, fileNo, firstErrorMsg, errorCount)
TLstring	fileName;
FileManager_FileNoType	fileNo;
struct ErrMsgDef	**firstErrorMsg;
TLint4	*errorCount;
{
    struct TLHAREA	quitCode;
    TLSTKCHKSLF(100544);
    if (TLHANDENTER(quitCode)) {
	TLSETF();
	TLSETL(100546);
	FileManager_CloseAllText();
	TLINCL();
	Language_ErrorModule_ReturnErrors(&((*firstErrorMsg)), &((*errorCount)));
	if (quitCode.quitCode != 1) {
	    TLSETL(100548);
	    TL_TLE_TLEQUIT ((TLint4) quitCode.quitCode, (char *) 0, 1);
	};
    } else {
	TLSETF();
	TLSETL(100555);
	Language_CompileFile(fileName, (FileManager_FileNoType) fileNo, (TLboolean) 1);
	TLINCL();
	Language_ErrorModule_ReturnErrors(&((*firstErrorMsg)), &((*errorCount)));
	TL_TLE_TLEHX();
    }
}

void Language_WriteObjectFile (fileName, fileNo, firstErrorMsg, errorCount, objectFileStream)
TLstring	fileName;
FileManager_FileNoType	fileNo;
struct ErrMsgDef	**firstErrorMsg;
TLint4	*errorCount;
TLint4	objectFileStream;
{
    TLboolean	success;
    TLstring	mainFileName;
    FileManager_FileNoType	mainFileNo;
    TLSTKCHKSLF(100576);
    TLSETF();
    TLSETL(100576);
    Language_Compile_SetObjectFileStream((TLint4) objectFileStream);
    TLSETL(100580);
    Language_Reset();
    TLSETL(100585);
    Language_CompileProgram(fileName, (FileManager_FileNoType) fileNo, &((*firstErrorMsg)), &((*errorCount)));
    TLSETL(100589);
    Language_Compile_SetObjectFileStream((TLint4) 0);
    TLSTRASS(255, mainFileName, "***MAIN PROGRAM***");
    TLINCL();
    mainFileNo = Language_UnitManager_FileNo(Language_mainUnitPtr);
    TLSETL(100592);
    TL_TLI_TLISS ((TLint4) objectFileStream, (TLint2) 4);
    TL_TLI_TLIWR (&mainFileNo, (TLint4) sizeof mainFileNo, (TLaddressint) 0, (TLint2) objectFileStream);
    TL_TLI_TLIWR (mainFileName, (TLint4) 255, (TLaddressint) 0, (TLint2) objectFileStream);
    TLRESTORELF();
}

void Language_CompileProgram (fileName, fileNo, firstErrorMsg, errorCount)
TLstring	fileName;
FileManager_FileNoType	fileNo;
struct ErrMsgDef	**firstErrorMsg;
TLint4	*errorCount;
{
    struct TLHAREA	quitCode;
    TLSTKCHKSLF(100600);
    if (TLHANDENTER(quitCode)) {
	TLSETF();
	TLSETL(100602);
	FileManager_CloseAllText();
	TLINCL();
	Language_ErrorModule_ReturnErrors(&((*firstErrorMsg)), &((*errorCount)));
	if (quitCode.quitCode != 1) {
	    TLSETL(100604);
	    TL_TLE_TLEQUIT ((TLint4) quitCode.quitCode, (char *) 0, 1);
	};
    } else {
	TLSETF();
	TLSETL(100614);
	Language_CompileFile(fileName, (FileManager_FileNoType) fileNo, (TLboolean) 0);
	TLINCL();
	for(;;) {
	    void	*unitPtr;
	    TLSETL(100617);
	    Language_UnitManager_RewindUnitList();
	    TLINCL();
	    for(;;) {
		void	*bodyUnit;
		TLSETL(100619);
		Language_UnitManager_GetNextUnit(&(unitPtr));
		if (unitPtr == ((void *) 0)) {
		    break;
		};
		TLSETL(100620);
		bodyUnit = Language_UnitManager_BodyUnit(unitPtr);
		TLSETL(100622);
		if ((Language_UnitManager_IsCompiled(unitPtr) && (bodyUnit != ((void *) 0))) && (!Language_UnitManager_IsCompiled(bodyUnit))) {
		    TLSETL(100626);
		    Language_CompileUnitPtr(bodyUnit);
		    TLINCL();
		    break;
		};
	    };
	    TLSETL(100629);
	    if (unitPtr == ((void *) 0)) {
		break;
	    };
	};
	TLSETL(100633);
	Language_ErrorModule_ReturnErrors(&((*firstErrorMsg)), &((*errorCount)));
	if ((*errorCount) == 0) {
	    TLSETL(100635);
	    Language_UnitManager_FlushOldUnits();
	    TLINCL();
	    FileManager_FlushUnreferencedFiles();
	};
	TL_TLE_TLEHX();
    }
}
static TLboolean	Language_pendingError;

void Language_SetupExecution (maxStackSize, inName, outName, args, numArgs)
TLnat4	maxStackSize;
TLstring	inName;
TLstring	outName;
__x1108	args;
TLint4	numArgs;
{
    struct TLHAREA	quitCode;
    TLSTKCHKSLF(100681);
    if (TLHANDENTER(quitCode)) {
	TLSETF();
	TLSETL(100681);
	Language_pendingError = 1;
	TLSETL(100683);
	if (quitCode.quitCode != 1) {
	    TLSETL(100684);
	    TL_TLE_TLEQUIT ((TLint4) quitCode.quitCode, (char *) 0, 1);
	};
    } else {
	TLaddressint	startPC;
	TLSETF();
	TLSETL(100689);
	Language_pendingError = 0;
	TLSETL(100695);
	Language_ErrorModule_Initialize();
	TLINCL();
	Language_UnitManager_RewindUnitList();
	TLINCL();
	for(;;) {
	    void	*unitPtr;
	    TLaddressint	unitCode;
	    TLSETL(100700);
	    for(;;) {
		TLSETL(100701);
		Language_UnitManager_GetNextUnit(&(unitPtr));
		if (unitPtr == ((void *) 0)) {
		    break;
		};
		TLSETL(100702);
		if (Language_UnitManager_IsCompiled(unitPtr)) {
		    break;
		};
	    };
	    TLSETL(100704);
	    if (unitPtr == ((void *) 0)) {
		break;
	    };
	    TLSETL(100706);
	    unitCode = (TLaddressint) Language_UnitManager_CodeTable(unitPtr);
	    TLSETL(100711);
	    if ((unsigned long) unitCode != 0) {
		void	*bodyUnit;
		TLSETL(100712);
		bodyUnit = Language_UnitManager_BodyUnit(unitPtr);
		TLSETL(100714);
		if (bodyUnit == ((void *) 0)) {
		    TLSETL(100715);
		    (* (struct Language_CodeHeader *) unitCode).bodyCode = (TLaddressint) 0;
		} else {
		    TLSETL(100718);
		    for(;;) {
			void	*stubUnit;
			TLSETL(100718);
			stubUnit = Language_UnitManager_StubUnit(bodyUnit);
			TLSETL(100720);
			if (stubUnit == unitPtr) {
			    break;
			};
			TLSETL(100721);
			bodyUnit = stubUnit;
		    };
		    TLSETL(100723);
		    (* (struct Language_CodeHeader *) unitCode).bodyCode = (TLaddressint) ((unsigned long) Language_UnitManager_CodeTable(bodyUnit) + sizeof(struct Language_CodeHeader));
		};
	    };
	    TLSETL(100732);
	    {
		TLaddressint	globalArea;
		globalArea = (TLaddressint) Language_UnitManager_GlobalArea(unitPtr);
		TLINCL();
		if ((unsigned long) globalArea != 0) {
		    TLint4	globalSize;

		    //extern void memset ();
		    TLSETL(100734);
		    globalSize = Language_UnitManager_GlobalSize(unitPtr);
		    TLINCL();
		    TLASSERT (globalSize != 0);
		    TLSETL(100739);
		    memset((TLaddressint) globalArea, (TLint4) 0, (TLint4) globalSize);
		};
	    };
	};
	TLSETL(100743);
	TLASSERT (Language_mainUnitPtr != ((void *) 0));
	TLINCL();
	startPC = (TLaddressint) ((unsigned long) Language_UnitManager_CodeTable(Language_mainUnitPtr) + sizeof(struct Language_CodeHeader));
	TLSETL(100750);
	Language_Execute_Initialize((TLaddressint) startPC, (TLnat4) maxStackSize, inName, outName, args, (TLint4) numArgs);
	TL_TLE_TLEHX();
    }
}

void Language_SetStep (step)
Language_Step	step;
{
    TLSTKCHKSLF(100759);
    TLSETF();
    TLSETL(100759);
    Language_Execute_SetStep((Language_Step) step);
    TLRESTORELF();
}
static TLaddressint	Language_unitInitPC;
static TLaddressint	Language_unitInitFP;

void Language_ExecuteProgram (runStatus, firstErrorMsg, errorCount)
struct Language_RunStatus	*runStatus;
struct ErrMsgDef	**firstErrorMsg;
TLint4	*errorCount;
{
    struct TLHAREA	quitCode;
    TLSTKCHKSLF(100775);
    if (TLHANDENTER(quitCode)) {
	TLSETF();
	TLSETL(100775);
	(*runStatus).state = 0;
	TLSETL(100777);
	TLSTRCTASS((*runStatus).srcPos, Language_nullSrcPosition, struct SrcPosition);
	TLSETL(100779);
	Language_ErrorModule_ReturnErrors(&((*firstErrorMsg)), &((*errorCount)));
	TLINCL();
	TL_TLI_TLIFS();
	if (quitCode.quitCode != 1) {
	    TLSETL(100781);
	    TL_TLE_TLEQUIT ((TLint4) quitCode.quitCode, (char *) 0, 1);
	};
    } else {
	TLSETF();
	TLSETL(100786);
	if (Language_pendingError) {
	    TLSETL(100787);
	    (*runStatus).state = 0;
	    TLINCL();
	    TLSTRCTASS((*runStatus).srcPos, Language_nullSrcPosition, struct SrcPosition);
	} else {
	    TLSETL(100791);
	    Language_unitInitPC = (TLaddressint) 0;
	    TLINCL();
	    Language_unitInitFP = (TLaddressint) 0;
	    TLSETL(100795);
	    Language_Execute_Executor(&((*runStatus)));
	    if (((*runStatus).state) == 0) {
		TLSETL(100796);
		Language_pendingError = 1;
		TLSETL(100798);
		TL_TLI_TLIFS();
	    };
	};
	TLSETL(100803);
	Language_ErrorModule_ReturnErrors(&((*firstErrorMsg)), &((*errorCount)));
	TL_TLE_TLEHX();
    }
}

void Language_EndExecution () {
    TLSTKCHKSLF(100809);
    TLSETF();
    TLSETL(100809);
    Language_Execute_EndExecution();
    Language_pendingError = 1;
    TLRESTORELF();
}

void Language_StopExecution () {
    TLSTKCHKSLF(100815);
    TLSETF();
    TLSETL(100815);
    TL_TLI_TLIFS();
    TLRESTORELF();
}

void Language_DumpThreadList (firstThreadQueue)
struct ThreadQueueDef	**firstThreadQueue;
{
    TLSTKCHKSLF(100821);
    TLSETF();
    TLSETL(100821);
    Language_Execute_DumpThreadList(&((*firstThreadQueue)));
    TLRESTORELF();
}

void Language_DumpUnitList (firstSymbol)
struct DumpSymbolDef	**firstSymbol;
{
    TLSTKCHKSLF(100827);
    TLSETF();
    TLSETL(100827);
    Language_Compile_DumpUnitList(&((*firstSymbol)));
    TLRESTORELF();
}

void Language_DumpScopeInfo (cookie, scopeInfo)
struct Cookie	*cookie;
struct DumpScopeDef	*scopeInfo;
{
    TLSTKCHKSLF(100832);
    TLSETF();
    TLSETL(100832);
    if ((unsigned long) Language_unitInitPC == 0) {
	TLSETL(100834);
	Language_Execute_UnitInitState(&(Language_unitInitPC), &(Language_unitInitFP));
    };
    TLSETL(100836);
    Language_Compile_DumpScopeInfo(&((*cookie)), (TLaddressint) Language_unitInitPC, (TLaddressint) Language_unitInitFP, &((*scopeInfo)));
    TLRESTORELF();
}

void Language_DumpSymbolInfo (cookie, firstSymbol)
struct Cookie	*cookie;
struct DumpSymbolDef	**firstSymbol;
{
    TLSTKCHKSLF(100842);
    TLSETF();
    TLSETL(100842);
    Language_Compile_DumpSymbolInfo(&((*cookie)), &((*firstSymbol)));
    TLRESTORELF();
}

void Language_DumpArrayBounds (cookie, firstIndex)
struct Cookie	*cookie;
struct DumpIndexDef	**firstIndex;
{
    TLSTKCHKSLF(100848);
    TLSETF();
    TLSETL(100848);
    Language_Compile_DumpArrayBounds(&((*cookie)), &((*firstIndex)));
    TLRESTORELF();
}

void Language_DumpArrayValues (cookie, dumpIndices, firstValue)
struct Cookie	*cookie;
struct DumpIndexDef	*dumpIndices;
struct DumpSymbolDef	**firstValue;
{
    TLSTKCHKSLF(100854);
    TLSETF();
    TLSETL(100854);
    Language_Compile_DumpArrayValues(&((*cookie)), dumpIndices, &((*firstValue)));
    TLRESTORELF();
}

extern void Paragrapher_Para ();

extern void Paragrapher_SetKeepCommentColumn ();

void Language_Paragraph (fileNo)
FileManager_FileNoType	fileNo;
{
    TLaddressint	textHandle;
    TLaddressint	sizePtr;
    FileManager_ResultCode	resultCode;
    TLaddressint	buffer;
    TLint4	bufferSize;
    TLSTKCHKSLF(100878);
    TLSETF();
    TLSETL(100878);
    TLPRE (fileNo != 0);
    TLSETL(100885);
    FileManager_OpenFileHandle((FileManager_FileNoType) fileNo, &(textHandle), &(sizePtr), &(resultCode));
    buffer = (TLaddressint) ((* (TLaddressint *) textHandle));
    TLINCL();
    bufferSize = (* (TLint4 *) sizePtr);
    TLSETL(100890);
    Paragrapher_Para(&(buffer), &(bufferSize));
    if ((unsigned long) buffer != 0) {
	TLSETL(100892);
	free((TLaddressint) ((* (TLaddressint *) textHandle)));
	(* (TLaddressint *) textHandle) = (TLaddressint) buffer;
	TLINCL();
	(* (TLint4 *) sizePtr) = bufferSize;
	TLSETL(100895);
	FileManager_SetModified((FileManager_FileNoType) fileNo);
    } else {
	TLSETL(100897);
	FeedBack("Paragraph failed!");
    };
    TLSETL(100900);
    FileManager_CloseFileHandle((FileManager_FileNoType) fileNo);
    TLRESTORELF();
}

void Language () {
    TLSAVELF();
    TLSETF();
    TLSETL(100039);
    Language_debug = 0;
    TLSETL(100080);
    Language_nullSymbolDef.next = (struct DumpSymbolDef *) 0;
    TLINCL();
    Language_nullSymbolDef.symbolName = (TLaddressint) 0;
    TLINCL();
    Language_nullSymbolDef.typeName = (TLaddressint) 0;
    TLINCL();
    TLSTRCTASS(Language_nullSymbolDef.srcPos, Language_nullSrcPosition, struct SrcPosition);
    TLINCL();
    TLSTRASS(255, Language_nullSymbolDef.value, "");
    TLINCL();
    TLSTRCTASS(Language_nullSymbolDef.cookie, Language_nullCookie, struct Cookie);
    TLINCL();
    Language_nullSymbolDef.isPredef = 0;
    TLSETL(100089);
    TLSTRCTASS(Language_nullScopeDef.symbolInfo, Language_nullSymbolDef, struct DumpSymbolDef);
    TLINCL();
    TLSTRCTASS(Language_nullScopeDef.expandCookie, Language_nullCookie, struct Cookie);
    TLINCL();
    Language_nullScopeDef.parameters = (struct DumpSymbolDef *) 0;
    TLINCL();
    Language_nullScopeDef.declarations = (struct DumpSymbolDef *) 0;
    Language_UnitManager();
    Language_ErrorModule();
    TLSETL(1000058);
    Language_codeOprSize =  TLSIMPLEMAX(2, 4);
    TLINCL();
    Language_codeInt1Size =  TLSIMPLEMAX(1, 4);
    TLINCL();
    Language_codeInt2Size =  TLSIMPLEMAX(2, 4);
    TLINCL();
    Language_codeIntSize =  TLSIMPLEMAX(4, 4);
    TLINCL();
    Language_codeRealSize =  TLSIMPLEMAX(8, 4);
    TLINCL();
    Language_codeAddrSize =  TLSIMPLEMAX(4, 4);
    TLINCL();
    Language_codeOffsetSize =  TL_TLA_TLAIMX ((TLint4) sizeof(Language_Offset), (TLint4) 4);
    TLSETL(1000176);
    TLASSERT (28 == sizeof(struct Language_ClassDescriptor));
    TLSETL(1000179);
    {
	typedef	TLaddressint	Address;
	typedef	TLint1	Int1;
	typedef	TLint2	Int2;
	typedef	TLint4	Int4;
	struct	ByteRecord {
    TLint1	fill;
    TLint1	data;
};
	struct	WordRecord {
    TLint1	fill;
    TLint2	data;
};
	struct	LongRecord {
    TLint1	fill;
    TLint4	data;
};
	TLINCL();
	TLASSERT (4 == sizeof(Address));
	TLINCL();
	TLASSERT (4 >= sizeof(Language_Offset));
	TLSETL(1000183);
	TLASSERT (2 == sizeof(Language_Opcode));
	TLSETL(1000186);
	TLASSERT (1 == sizeof(Int1));
	TLSETL(1000188);
	TLASSERT (2 == sizeof(Int2));
	TLSETL(1000190);
	TLASSERT (4 == sizeof(Int4));
	TLSETL(1000197);
	TLASSERT (1 == (sizeof(struct ByteRecord) - 1));
	TLSETL(1000204);
	TLASSERT (2 == (sizeof(struct WordRecord) - 2));
	TLSETL(1000211);
	TLASSERT (4 == (sizeof(struct LongRecord) - 4));
	TLSETL(1000213);
	TLASSERT (8 == sizeof(struct Language_PointerDescriptor));
    };
    Language_DebugModule();
    Language_Compile();
    Language_Execute();
    TLSETL(100189);
    Language_newPreprocs = 0;
    TLSETL(100452);
    Language_lastCompileUnit = (void *) 0;
    TLSETL(100765);
    Language_unitInitPC = (TLaddressint) 0;
    TLINCL();
    Language_unitInitFP = (TLaddressint) 0;
    Paragrapher();
    TLRESTORELF();
}

// TPROLOG additions
//void Language_SetupExecutionFromObjectFile ();

//void Language_GetFileName ();
typedef	TLstring	__x1108[21];
typedef	TLstring	__x869[21];
typedef	TLnat2	Language_LoadObjectFile_FileNoType;
typedef long TLint4;
struct	Language_LoadObjectFile_FileTableNode {
    Language_LoadObjectFile_FileNoType	fileNo;
    TLstring	fileName;
    Language_LoadObjectFile_FileNoType	bodyFileNo;
    Language_LoadObjectFile_FileNoType	stubFileNo;
    TLaddressint	codeTable;
    TLaddressint	manifestTable;
    TLaddressint	globalArea;
            struct Language_LoadObjectFile_FileTableNode	*next;
};
static struct Language_LoadObjectFile_FileTableNode	*Language_LoadObjectFile_fileTableHdr;
static struct Language_LoadObjectFile_FileTableNode	*Language_LoadObjectFile_fileTablePtr;

static struct Language_LoadObjectFile_FileTableNode * Language_LoadObjectFile_GetFile (fileNo)
Language_LoadObjectFile_FileNoType	fileNo;
{
    struct Language_LoadObjectFile_FileTableNode	*ptr;
    TLSTKCHKSLF(1300038);
    TLSETF();
    TLSETL(1300038);
    ptr = Language_LoadObjectFile_fileTableHdr;
    TLSETL(1300040);
    for(;;) {
	TLSETL(1300040);
	if (ptr == ((struct Language_LoadObjectFile_FileTableNode *) 0)) {
	    break;
	};
	TLSETL(1300041);
	if ((ptr->fileNo) == fileNo) {
	    TLSETL(1300042);
	    TLRESTORELF();
	    return (ptr);
	};
	TLSETL(1300044);
	ptr = ptr->next;
    };
    TLSETL(1300046);
    {
	TLstring	__x894;
	TL_TLS_TLSVIS((TLint4) fileNo, (TLint4) 1, (TLint4) 10, __x894);
	{
	    TLstring	__x893;
	    TL_TLS_TLSCAT("<File ", __x894, __x893);
	    {
		TLstring	__x892;
		TL_TLS_TLSCAT(__x893, " Not Found>", __x892);
		TL_TLI_TLISSO ();
		TL_TLI_TLIPS ((TLint4) 0, __x892, (TLint2) -1);
		TL_TLI_TLIPK ((TLint2) -1);
	    };
	};
    };
    TLSETL(1300048);
    TL_TLK_TLKUEXIT((TLint4) 0);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

static void Language_LoadObjectFile_GetFileName (fileNo, __x816)
Language_LoadObjectFile_FileNoType	fileNo;
TLstring	__x816;
{
    struct Language_LoadObjectFile_FileTableNode	*ptr;
    TLSTKCHKSLF(1300051);
    TLSETF();
    TLSETL(1300051);
    ptr = Language_LoadObjectFile_fileTableHdr;
    TLSETL(1300053);
    for(;;) {
	TLSETL(1300053);
	if (ptr == ((struct Language_LoadObjectFile_FileTableNode *) 0)) {
	    break;
	};
	TLSETL(1300054);
	if ((ptr->fileNo) == fileNo) {
	    TLSETL(1300055);
	    {
		TLSTRASS(255, __x816, ptr->fileName);
		TLRESTORELF();
		return;
	    };
	};
	TLSETL(1300057);
	ptr = ptr->next;
    };
    TLSETL(1300059);
    {
	{
	    TLstring	__x898;
	    TL_TLS_TLSVIS((TLint4) fileNo, (TLint4) 1, (TLint4) 10, __x898);
	    {
		TLstring	__x897;
		TL_TLS_TLSCAT("<Unknown file #", __x898, __x897);
		{
		    TLstring	__x896;
		    TL_TLS_TLSCAT(__x897, ">", __x896);
		    TLSTRASS(255, __x816, __x896);
		};
	    };
	};
	TLRESTORELF();
	return;
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

static TLaddressint Language_LoadObjectFile_GetCodeTable (fileNo)
Language_LoadObjectFile_FileNoType	fileNo;
{
    TLSTKCHKSLF(1300063);
    TLSETF();
    TLSETL(1300063);
    TLRESTORELF();
    return ((TLaddressint) Language_LoadObjectFile_GetFile((Language_LoadObjectFile_FileNoType) fileNo)->codeTable);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

static TLaddressint Language_LoadObjectFile_GetManifestTable (fileNo)
Language_LoadObjectFile_FileNoType	fileNo;
{
    TLSTKCHKSLF(1300067);
    TLSETF();
    TLSETL(1300067);
    TLRESTORELF();
    return ((TLaddressint) Language_LoadObjectFile_GetFile((Language_LoadObjectFile_FileNoType) fileNo)->manifestTable);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

static TLaddressint Language_LoadObjectFile_GetGlobalArea (fileNo)
Language_LoadObjectFile_FileNoType	fileNo;
{
    TLSTKCHKSLF(1300071);
    TLSETF();
    TLSETL(1300071);
    TLRESTORELF();
    return ((TLaddressint) Language_LoadObjectFile_GetFile((Language_LoadObjectFile_FileNoType) fileNo)->globalArea);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

static void Language_LoadObjectFile_LoadAndLink (objectFileStream, startPC, debug)
TLint4	objectFileStream;
TLaddressint	*startPC;
TLboolean	debug;
{
    Language_LoadObjectFile_FileNoType	fileNo;
    Language_LoadObjectFile_FileNoType	bodyFileNo;
    Language_LoadObjectFile_FileNoType	stubFileNo;
    TLstring	fileName;
    TLnat4	offset;
    TLnat4	mc;
    TLnat4	codePatch;
    TLnat4	manifestPatch;
    TLnat4	globalPatch;
    TLint4	kind;
    TLint4	globalSize;
    TLaddressint	codeTable;
    TLaddressint	manifestTable;
    TLaddressint	globalArea;
    TLstring	line;
    TLstring	element;
    struct Language_LoadObjectFile_FileTableNode	*ptr;
    TLSTKCHKSLF(1300086);
    TLSETF();
    TLSETL(1300086);
    for(;;) {
	TLint4	tableSize = 0;
	TLSETL(1300086);
	if (TL_TLI_TLIEOF((TLint4) objectFileStream)) {
	    break;
	};
	TLSETL(1300088);
	if (debug) {
	    TLSETL(1300090);
	    puts("******************************************************");
	};
	TLSETL(1300095);
	TL_TLI_TLISS ((TLint4) objectFileStream, (TLint2) 3);
	TL_TLI_TLIRE (&fileNo, (TLint4) sizeof fileNo, (TLaddressint) 0, (TLint2) objectFileStream);
	TL_TLI_TLIRE (fileName, (TLint4) 255, (TLaddressint) 0, (TLint2) objectFileStream);
	TLSETL(1300097);
	if (debug) {
	    TLSETL(1300099);
	    {
		TLstring	__x902;
		TL_TLS_TLSVIS((TLint4) fileNo, (TLint4) 1, (TLint4) 10, __x902);
		{
		    TLstring	__x901;
		    TL_TLS_TLSCAT(fileName, " [", __x901);
		    {
			TLstring	__x900;
			TL_TLS_TLSCAT(__x901, __x902, __x900);
			{
			    TLstring	__x899;
			    TL_TLS_TLSCAT(__x900, "]", __x899);
			    puts(__x899);
			};
		    };
		};
	    };
	};
	TLSETL(1300101);
	if (strcmp(fileName, "***MAIN PROGRAM***") == 0) {
	    break;
	};
	TLSETL(1300106);
	TL_TLI_TLISS ((TLint4) objectFileStream, (TLint2) 3);
	TL_TLI_TLIRE (&bodyFileNo, (TLint4) sizeof bodyFileNo, (TLaddressint) 0, (TLint2) objectFileStream);
	TLINCL();
	if (debug && (bodyFileNo != 0)) {
	    TLSETL(1300109);
	    {
		TLstring	__x905;
		Language_LoadObjectFile_GetFileName((Language_LoadObjectFile_FileNoType) bodyFileNo, __x905);
		{
		    TLstring	__x904;
		    TL_TLS_TLSCAT("Body = \'", __x905, __x904);
		    {
			TLstring	__x903;
			TL_TLS_TLSCAT(__x904, "\'", __x903);
			puts(__x903);
		    };
		};
	    };
	};
	TLSETL(1300111);
	TL_TLI_TLISS ((TLint4) objectFileStream, (TLint2) 3);
	TL_TLI_TLIRE (&stubFileNo, (TLint4) sizeof stubFileNo, (TLaddressint) 0, (TLint2) objectFileStream);
	TLINCL();
	if (debug && (stubFileNo != 0)) {
	    TLSETL(1300114);
	    {
		TLstring	__x908;
		Language_LoadObjectFile_GetFileName((Language_LoadObjectFile_FileNoType) stubFileNo, __x908);
		{
		    TLstring	__x907;
		    TL_TLS_TLSCAT("Stub = \'", __x908, __x907);
		    {
			TLstring	__x906;
			TL_TLS_TLSCAT(__x907, "\'", __x906);
			puts(__x906);
		    };
		};
	    };
	};
	TLSETL(1300121);
	TL_TLI_TLISS ((TLint4) objectFileStream, (TLint2) 3);
	TL_TLI_TLIRE (&tableSize, (TLint4) sizeof tableSize, (TLaddressint) 0, (TLint2) objectFileStream);
	TLINCL();
	if (tableSize == 0) {
	    TLSETL(1300123);
	    codeTable = (TLaddressint) 0;
	    TLINCL();
	    if (debug) {
		TLSETL(1300126);
		puts("No Code table");
	    };
	} else {
	    TLSETL(1300128);
	    codeTable = (TLaddressint) malloc(tableSize);
	    TLINCL();
	    if ((unsigned long) codeTable == 0) {
		TLSETL(1300132);
		{
		    TLstring	__x910;
		    TL_TLS_TLSVIS((TLint4) tableSize, (TLint4) 1, (TLint4) 10, __x910);
		    {
			TLstring	__x909;
			TL_TLS_TLSCAT("Unable to allocate a code table of size ", __x910, __x909);
			puts(__x909);
		    };
		};
		TLINCL();
		TL_TLK_TLKUEXIT((TLint4) 0);
	    };
	    TLSETL(1300134);
	    if (debug) {
		TLSETL(1300137);
		{
		    TLstring	__x915;
		    TL_TLS_TLSVIS((TLaddressint) codeTable, (TLint4) 0, (TLint4) 16, __x915);
		    {
			TLstring	__x914;
			TL_TLS_TLSVIS((TLint4) tableSize, (TLint4) 1, (TLint4) 10, __x914);
			{
			    TLstring	__x913;
			    TL_TLS_TLSCAT("Code table size = ", __x914, __x913);
			    {
				TLstring	__x912;
				TL_TLS_TLSCAT(__x913, "  Code Table = 0x", __x912);
				{
				    TLstring	__x911;
				    TL_TLS_TLSCAT(__x912, __x915, __x911);
				    puts(__x911);
				};
			    };
			};
		    };
		};
	    };
	};
	TLSETL(1300139);
	TL_TLI_TLISS ((TLint4) objectFileStream, (TLint2) 3);
	TL_TLI_TLIRE (&((* (TLnat4 *) codeTable)), (TLint4) tableSize, (TLaddressint) 0, (TLint2) objectFileStream);
	TLSETL(1300142);
	TL_TLI_TLISS ((TLint4) objectFileStream, (TLint2) 3);
	TL_TLI_TLIRE (&tableSize, (TLint4) sizeof tableSize, (TLaddressint) 0, (TLint2) objectFileStream);
	TLINCL();
	if (tableSize == 0) {
	    TLSETL(1300144);
	    manifestTable = (TLaddressint) 0;
	    TLINCL();
	    if (debug) {
		TLSETL(1300147);
		puts("No Manifest table");
	    };
	} else {
	    TLSETL(1300149);
	    manifestTable = (TLaddressint) malloc((TLint4) tableSize);
	    TLINCL();
	    if ((unsigned long) manifestTable == 0) {
		TLSETL(1300153);
		{
		    TLstring	__x918;
		    TL_TLS_TLSVIS((TLint4) tableSize, (TLint4) 1, (TLint4) 10, __x918);
		    {
			TLstring	__x917;
			TL_TLS_TLSCAT("Unable to allocate a manifest table of size ", __x918, __x917);
			puts(__x917);
		    };
		};
		TLINCL();
		TL_TLK_TLKUEXIT((TLint4) 0);
	    };
	    TLSETL(1300155);
	    if (debug) {
		TLSETL(1300159);
		{
		    TLstring	__x923;
		    TL_TLS_TLSVIS((TLaddressint) manifestTable, (TLint4) 0, (TLint4) 16, __x923);
		    {
			TLstring	__x922;
			TL_TLS_TLSVIS((TLint4) tableSize, (TLint4) 1, (TLint4) 10, __x922);
			{
			    TLstring	__x921;
			    TL_TLS_TLSCAT("Manifest table size = ", __x922, __x921);
			    {
				TLstring	__x920;
				TL_TLS_TLSCAT(__x921, "  Manifest Table = 0x", __x920);
				{
				    TLstring	__x919;
				    TL_TLS_TLSCAT(__x920, __x923, __x919);
				    puts(__x919);
				};
			    };
			};
		    };
		};
	    };
	};
	TLSETL(1300161);
	TL_TLI_TLISS ((TLint4) objectFileStream, (TLint2) 3);
	TL_TLI_TLIRE (&((* (TLnat4 *) manifestTable)), (TLint4) tableSize, (TLaddressint) 0, (TLint2) objectFileStream);
	TLSETL(1300163);
	TL_TLI_TLISS ((TLint4) objectFileStream, (TLint2) 3);
	TL_TLI_TLIRE (&globalSize, (TLint4) sizeof globalSize, (TLaddressint) 0, (TLint2) objectFileStream);
	TLINCL();
	if (globalSize == 0) {
	    TLSETL(1300165);
	    globalArea = (TLaddressint) 0;
	    TLINCL();
	    if (debug) {
		TLSETL(1300168);
		puts("No Global area");
	    };
	} else {

	    TLSETL(1300170);
	    globalArea = (TLaddressint) malloc((TLint4) globalSize);
	    TLINCL();
	    if ((unsigned long) globalArea == 0) {
		TLSETL(1300174);
		{
		    TLstring	__x926;
		    TL_TLS_TLSVIS((TLint4) globalSize, (TLint4) 1, (TLint4) 10, __x926);
		    {
			TLstring	__x925;
			TL_TLS_TLSCAT("Unable to allocate a global area of size ", __x926, __x925);
			puts(__x925);
		    };
		};
		TLINCL();
		TL_TLK_TLKUEXIT((TLint4) 0);
	    };
	    TLSETL(1300179);
	    memset((TLaddressint) globalArea, (TLint4) 0, (TLint4) globalSize);
	};
	TLSETL(1300180);
	if (debug) {
	    TLSETL(1300183);
	    {
		TLstring	__x931;
		TL_TLS_TLSVIS((TLaddressint) globalArea, (TLint4) 0, (TLint4) 16, __x931);
		{
		    TLstring	__x930;
		    TL_TLS_TLSVIS((TLint4) globalSize, (TLint4) 1, (TLint4) 10, __x930);
		    {
			TLstring	__x929;
			TL_TLS_TLSCAT("Global table size = ", __x930, __x929);
			{
			    TLstring	__x928;
			    TL_TLS_TLSCAT(__x929, "  Global Area = 0x", __x928);
			    {
				TLstring	__x927;
				TL_TLS_TLSCAT(__x928, __x931, __x927);
				puts(__x927);
			    };
			};
		    };
		};
	    };
	};
	TLSETL(1300189);
	TL_TLB_TLBNWU(& Language_LoadObjectFile_fileTablePtr, (TLint4)  sizeof (	struct Language_LoadObjectFile_FileTableNode));
	TLINCL();
	Language_LoadObjectFile_fileTablePtr->fileNo = fileNo;
	TLINCL();
	TLSTRASS(255, Language_LoadObjectFile_fileTablePtr->fileName, fileName);
	TLINCL();
	Language_LoadObjectFile_fileTablePtr->bodyFileNo = bodyFileNo;
	TLINCL();
	Language_LoadObjectFile_fileTablePtr->stubFileNo = stubFileNo;
	TLINCL();
	Language_LoadObjectFile_fileTablePtr->codeTable = (TLaddressint) codeTable;
	TLINCL();
	Language_LoadObjectFile_fileTablePtr->manifestTable = (TLaddressint) manifestTable;
	TLINCL();
	Language_LoadObjectFile_fileTablePtr->globalArea = (TLaddressint) globalArea;
	TLINCL();
	Language_LoadObjectFile_fileTablePtr->next = Language_LoadObjectFile_fileTableHdr;
	TLINCL();
	Language_LoadObjectFile_fileTableHdr = Language_LoadObjectFile_fileTablePtr;
	TLSETL(1300211);
	for(;;) {
	    TLSETL(1300211);
	    TL_TLI_TLISS ((TLint4) objectFileStream, (TLint2) 3);
	    TL_TLI_TLIRE (&mc, (TLint4) sizeof mc, (TLaddressint) 0, (TLint2) objectFileStream);
	    TLINCL();
	    if (mc == 0xFFFFFFFF) {
		break;
	    };
	    TLSETL(1300213);
	    TL_TLI_TLISS ((TLint4) objectFileStream, (TLint2) 3);
	    TL_TLI_TLIRE (&fileNo, (TLint4) sizeof fileNo, (TLaddressint) 0, (TLint2) objectFileStream);
	    TL_TLI_TLIRE (&kind, (TLint4) sizeof kind, (TLaddressint) 0, (TLint2) objectFileStream);
	    TL_TLI_TLIRE (&offset, (TLint4) sizeof offset, (TLaddressint) 0, (TLint2) objectFileStream);
	    TLINCL();
	    if (debug) {
		TLSETL(1300215);
		{
		    TLstring	__x934;
		    TL_TLS_TLSVIS((TLint4) mc, (TLint4) 1, (TLint4) 10, __x934);
		    {
			TLstring	__x933;
			TL_TLS_TLSCAT("Offset = ", __x934, __x933);
			{
			    TLstring	__x932;
			    TL_TLS_TLSCAT(__x933, "  Kind = ", __x932);
			    TLSTRASS(255, line, __x932);
			};
		    };
		};
		TLINCL();
		if (kind == 0) {
		    TLSETL(1300216);
		    TLSTRCATASS(line, "Manifest", 255);
		} else {
		    TLSETL(1300217);
		    if (kind == 1) {
			TLSETL(1300217);
			TLSTRCATASS(line, "Code", 255);
		    } else {
			TLSETL(1300218);
			if (kind == 2) {
			    TLSETL(1300218);
			    TLSTRCATASS(line, "Global", 255);
			} else {
			    TLSETL(1300220);
			    {
				TLstring	__x937;
				TL_TLS_TLSVIS((TLint4) kind, (TLint4) 1, (TLint4) 10, __x937);
				{
				    TLstring	__x936;
				    TL_TLS_TLSCAT("ERROR! (kind = ", __x937, __x936);
				    {
					TLstring	__x935;
					TL_TLS_TLSCAT(__x936, ")", __x935);
					TLSTRCATASS(line, __x935, 255);
				    };
				};
			    };
			    TLSETL(1300222);
			    puts(line);
			    TLINCL();
			    TL_TLK_TLKUEXIT((TLint4) 0);
			};
		    };
		};
		TLSETL(1300224);
		{
		    TLstring	__x942;
		    TL_TLS_TLSVIS((TLint4) offset, (TLint4) 1, (TLint4) 10, __x942);
		    {
			TLstring	__x941;
			Language_LoadObjectFile_GetFileName((Language_LoadObjectFile_FileNoType) fileNo, __x941);
			{
			    TLstring	__x940;
			    TL_TLS_TLSCAT(" of \'", __x941, __x940);
			    {
				TLstring	__x939;
				TL_TLS_TLSCAT(__x940, "\' at offset ", __x939);
				{
				    TLstring	__x938;
				    TL_TLS_TLSCAT(__x939, __x942, __x938);
				    TLSTRCATASS(line, __x938, 255);
				};
			    };
			};
		    };
		};
		TLSETL(1300227);
		puts(line);
	    };
	    TLSETL(1300228);
	    if (kind == 0) {
		TLSETL(1300229);
		(* (TLnat4 *) ((unsigned long) manifestTable + mc)) = (unsigned long) Language_LoadObjectFile_GetManifestTable((Language_LoadObjectFile_FileNoType) fileNo) + offset;
	    } else {
		TLSETL(1300231);
		if (kind == 1) {
		    TLSETL(1300232);
		    (* (TLnat4 *) ((unsigned long) manifestTable + mc)) = (unsigned long) Language_LoadObjectFile_GetCodeTable((Language_LoadObjectFile_FileNoType) fileNo) + offset;
		} else {
		    TLSETL(1300233);
		    if (kind == 2) {
			TLSETL(1300234);
			(* (TLnat4 *) ((unsigned long) manifestTable + mc)) = (unsigned long) Language_LoadObjectFile_GetGlobalArea((Language_LoadObjectFile_FileNoType) fileNo) + offset;
		    };
		};
	    };
	};
	TLSETL(1300242);
	TL_TLI_TLISS ((TLint4) objectFileStream, (TLint2) 3);
	TL_TLI_TLIRE (&codePatch, (TLint4) sizeof codePatch, (TLaddressint) 0, (TLint2) objectFileStream);
	TLINCL();
	if (codePatch != 0) {
	    TLSETL(1300244);
	    if (debug) {
		TLSETL(1300245);
		{
		    TLstring	__x948;
		    TL_TLS_TLSVIS((TLint4) codePatch, (TLint4) 1, (TLint4) 10, __x948);
		    {
			TLstring	__x947;
			TL_TLS_TLSCAT("Code Patch = ", __x948, __x947);
			{
			    TLstring	__x946;
			    TL_TLS_TLSCAT(__x947, "  [", __x946);
			    TLSTRASS(255, line, __x946);
			};
		    };
		};
	    };
	    TLSETL(1300248);
	    for(;;) {
		TLSETL(1300248);
		if (codePatch == 0) {
		    break;
		};
		TLSETL(1300249);
		if (debug) {
		    TLSETL(1300250);
		    {
			TLstring	__x955;
			TL_TLS_TLSVNS((TLnat4) ((* (TLnat4 *) (((unsigned long) codeTable + codePatch) + 4))), (TLint4) 1, (TLint4) 10, __x955);
			{
			    TLstring	__x953;
			    TL_TLS_TLSVIS((TLint4) codePatch, (TLint4) 1, (TLint4) 10, __x953);
			    {
				TLstring	__x952;
				TL_TLS_TLSCAT("(", __x953, __x952);
				{
				    TLstring	__x951;
				    TL_TLS_TLSCAT(__x952, "-", __x951);
				    {
					TLstring	__x950;
					TL_TLS_TLSCAT(__x951, __x955, __x950);
					{
					    TLstring	__x949;
					    TL_TLS_TLSCAT(__x950, ") ", __x949);
					    TLSTRASS(255, element, __x949);
					};
				    };
				};
			    };
			};
		    };
		    TLSETL(1300252);
		    if ((TL_TLS_TLSLEN(element) + TL_TLS_TLSLEN(line)) > 250) {
			TLSETL(1300254);
			puts(line);
			TLSTRASS(255, line, "             ");
		    };
		    TLSETL(1300256);
		    TLSTRCATASS(line, element, 255);
		};
		TLSETL(1300258);
		(* (TLnat4 *) (((unsigned long) codeTable + codePatch) + 4)) += (unsigned long) codeTable;
		TLINCL();
		codePatch = (* (TLnat4 *) ((unsigned long) codeTable + codePatch));
	    };
	    TLSETL(1300261);
	    if (debug) {
		TLSETL(1300262);
		TLSTRCATASS(line, "]", 255);
		TLSETL(1300264);
		puts(line);
	    };
	};
	TLSETL(1300268);
	TL_TLI_TLISS ((TLint4) objectFileStream, (TLint2) 3);
	TL_TLI_TLIRE (&manifestPatch, (TLint4) sizeof manifestPatch, (TLaddressint) 0, (TLint2) objectFileStream);
	TLINCL();
	if (manifestPatch != 0) {
	    TLSETL(1300270);
	    if (debug) {
		TLSETL(1300271);
		{
		    TLstring	__x960;
		    TL_TLS_TLSVIS((TLint4) manifestPatch, (TLint4) 1, (TLint4) 10, __x960);
		    {
			TLstring	__x959;
			TL_TLS_TLSCAT("Manifest Patch = ", __x960, __x959);
			{
			    TLstring	__x958;
			    TL_TLS_TLSCAT(__x959, "  [", __x958);
			    TLSTRASS(255, line, __x958);
			};
		    };
		};
	    };
	    TLSETL(1300275);
	    for(;;) {
		TLSETL(1300275);
		if (manifestPatch == 0) {
		    break;
		};
		TLSETL(1300276);
		if (debug) {
		    TLSETL(1300277);
		    {
			TLstring	__x967;
			TL_TLS_TLSVNS((TLnat4) ((* (TLnat4 *) (((unsigned long) codeTable + manifestPatch) + 4))), (TLint4) 1, (TLint4) 10, __x967);
			{
			    TLstring	__x965;
			    TL_TLS_TLSVIS((TLint4) manifestPatch, (TLint4) 1, (TLint4) 10, __x965);
			    {
				TLstring	__x964;
				TL_TLS_TLSCAT("(", __x965, __x964);
				{
				    TLstring	__x963;
				    TL_TLS_TLSCAT(__x964, "-", __x963);
				    {
					TLstring	__x962;
					TL_TLS_TLSCAT(__x963, __x967, __x962);
					{
					    TLstring	__x961;
					    TL_TLS_TLSCAT(__x962, ") ", __x961);
					    TLSTRASS(255, element, __x961);
					};
				    };
				};
			    };
			};
		    };
		    TLSETL(1300279);
		    if ((TL_TLS_TLSLEN(element) + TL_TLS_TLSLEN(line)) > 250) {
			TLSETL(1300281);
			puts(line);
			TLSTRASS(255, line, "             ");
		    };
		    TLSETL(1300283);
		    TLSTRCATASS(line, element, 255);
		};
		TLSETL(1300285);
		(* (TLnat4 *) (((unsigned long) codeTable + manifestPatch) + 4)) += (unsigned long) manifestTable;
		TLINCL();
		manifestPatch = (* (TLnat4 *) ((unsigned long) codeTable + manifestPatch));
	    };
	    TLSETL(1300288);
	    if (debug) {
		TLSETL(1300289);
		TLSTRCATASS(line, "]", 255);
		TLSETL(1300291);
		puts(line);
	    };
	};
	TLSETL(1300295);
	TL_TLI_TLISS ((TLint4) objectFileStream, (TLint2) 3);
	TL_TLI_TLIRE (&globalPatch, (TLint4) sizeof globalPatch, (TLaddressint) 0, (TLint2) objectFileStream);
	TLINCL();
	if (globalPatch != 0) {
	    TLSETL(1300297);
	    if (debug) {
		TLSETL(1300298);
		{
		    TLstring	__x972;
		    TL_TLS_TLSVIS((TLint4) globalPatch, (TLint4) 1, (TLint4) 10, __x972);
		    {
			TLstring	__x971;
			TL_TLS_TLSCAT("Global Patch = ", __x972, __x971);
			{
			    TLstring	__x970;
			    TL_TLS_TLSCAT(__x971, "  [", __x970);
			    TLSTRASS(255, line, __x970);
			};
		    };
		};
	    };
	    TLSETL(1300301);
	    for(;;) {
		TLSETL(1300301);
		if (globalPatch == 0) {
		    break;
		};
		TLSETL(1300302);
		if (debug) {
		    TLSETL(1300303);
		    {
			TLstring	__x979;
			TL_TLS_TLSVNS((TLnat4) ((* (TLnat4 *) (((unsigned long) codeTable + globalPatch) + 4))), (TLint4) 1, (TLint4) 10, __x979);
			{
			    TLstring	__x977;
			    TL_TLS_TLSVIS((TLint4) globalPatch, (TLint4) 1, (TLint4) 10, __x977);
			    {
				TLstring	__x976;
				TL_TLS_TLSCAT("(", __x977, __x976);
				{
				    TLstring	__x975;
				    TL_TLS_TLSCAT(__x976, "-", __x975);
				    {
					TLstring	__x974;
					TL_TLS_TLSCAT(__x975, __x979, __x974);
					{
					    TLstring	__x973;
					    TL_TLS_TLSCAT(__x974, ") ", __x973);
					    TLSTRASS(255, element, __x973);
					};
				    };
				};
			    };
			};
		    };
		    TLSETL(1300305);
		    if ((TL_TLS_TLSLEN(element) + TL_TLS_TLSLEN(line)) > 250) {
			TLSETL(1300307);
			puts(line);
			TLSTRASS(255, line, "             ");
		    };
		    TLSETL(1300309);
		    TLSTRCATASS(line, element, 255);
		};
		TLSETL(1300311);
		(* (TLnat4 *) (((unsigned long) codeTable + globalPatch) + 4)) += (unsigned long) globalArea;
		TLINCL();
		globalPatch = (* (TLnat4 *) ((unsigned long) codeTable + globalPatch));
	    };
	    TLSETL(1300314);
	    if (debug) {
		TLSETL(1300315);
		TLSTRCATASS(line, "]", 255);
		TLSETL(1300317);
		puts(line);
	    };
	};
	TLSETL(1300324);
	{
	    register TLint4	table;
	    for (table = 1; table <= 3; table++) {
		TLboolean	title;
		TLSETL(1300325);
		title = 0;
		TLSETL(1300327);
		for(;;) {
		    TLSETL(1300327);
		    TL_TLI_TLISS ((TLint4) objectFileStream, (TLint2) 3);
		    TL_TLI_TLIRE (&fileNo, (TLint4) sizeof fileNo, (TLaddressint) 0, (TLint2) objectFileStream);
		    TLINCL();
		    if (fileNo == 65535) {
			break;
		    };
		    TLSETL(1300329);
		    if (debug && (!title)) {
			TLSETL(1300330);
			switch (table) {
			    case 1:
				{
				    TLSETL(1300332);
				    puts("Code Patches");
				}
				break;
			    case 2:
				{
				    TLSETL(1300333);
				    puts("Manifest Patches");
				}
				break;
			    case 3:
				{
				    TLSETL(1300334);
				    puts("Global Patches");
				}
				break;
			    default:
				TLCASEABORT;
			};
			TLINCL();
			title = 1;
		    };
		    TLSETL(1300337);
		    TL_TLI_TLISS ((TLint4) objectFileStream, (TLint2) 3);
		    TL_TLI_TLIRE (&offset, (TLint4) sizeof offset, (TLaddressint) 0, (TLint2) objectFileStream);
		    TLINCL();
		    if (debug) {
			TLSETL(1300339);
			{
			    TLstring	__x983;
			    Language_LoadObjectFile_GetFileName((Language_LoadObjectFile_FileNoType) fileNo, __x983);
			    {
				TLstring	__x982;
				TL_TLS_TLSCAT(__x983, " [", __x982);
				TLSTRASS(255, line, __x982);
			    };
			};
		    };
		    TLSETL(1300342);
		    for(;;) {
			TLSETL(1300342);
			if (offset == 0) {
			    break;
			};
			TLSETL(1300343);
			if (debug) {
			    TLSETL(1300344);
			    {
				TLstring	__x990;
				TL_TLS_TLSVNS((TLnat4) ((* (TLnat4 *) (((unsigned long) codeTable + offset) + 4))), (TLint4) 1, (TLint4) 10, __x990);
				{
				    TLstring	__x988;
				    TL_TLS_TLSVIS((TLint4) offset, (TLint4) 1, (TLint4) 10, __x988);
				    {
					TLstring	__x987;
					TL_TLS_TLSCAT("(", __x988, __x987);
					{
					    TLstring	__x986;
					    TL_TLS_TLSCAT(__x987, "-", __x986);
					    {
						TLstring	__x985;
						TL_TLS_TLSCAT(__x986, __x990, __x985);
						{
						    TLstring	__x984;
						    TL_TLS_TLSCAT(__x985, ") ", __x984);
						    TLSTRASS(255, element, __x984);
						};
					    };
					};
				    };
				};
			    };
			    TLSETL(1300346);
			    if ((TL_TLS_TLSLEN(element) + TL_TLS_TLSLEN(line)) > 250) {
				TLSETL(1300348);
				puts(line);
				TLSTRASS(255, line, "             ");
			    };
			    TLSETL(1300350);
			    TLSTRCATASS(line, element, 255);
			};
			TLSETL(1300352);
			switch (table) {
			    case 1:
				{
				    TLSETL(1300353);
				    (* (TLnat4 *) (((unsigned long) codeTable + offset) + 4)) += (unsigned long) Language_LoadObjectFile_GetCodeTable((Language_LoadObjectFile_FileNoType) fileNo);
				}
				break;
			    case 2:
				{
				    TLSETL(1300355);
				    (* (TLnat4 *) (((unsigned long) codeTable + offset) + 4)) += (unsigned long) Language_LoadObjectFile_GetManifestTable((Language_LoadObjectFile_FileNoType) fileNo);
				}
				break;
			    case 3:
				{
				    TLSETL(1300357);
				    (* (TLnat4 *) (((unsigned long) codeTable + offset) + 4)) += (unsigned long) Language_LoadObjectFile_GetGlobalArea((Language_LoadObjectFile_FileNoType) fileNo);
				}
				break;
			    default:
				TLCASEABORT;
			};
			TLSETL(1300360);
			offset = (* (TLnat4 *) ((unsigned long) codeTable + offset));
		    };
		    TLSETL(1300362);
		    if (debug) {
			TLSETL(1300363);
			TLSTRCATASS(line, "]", 255);
			TLSETL(1300365);
			puts(line);
		    };
		};
	    };
	};
    };
    TLSETL(1300370);
    if (strcmp(fileName, "***MAIN PROGRAM***") == 0) {
	TLSETL(1300371);
	(*startPC) = (TLaddressint) ((unsigned long) Language_LoadObjectFile_GetCodeTable((Language_LoadObjectFile_FileNoType) fileNo) + 4);
	TLINCL();
	if (debug) {
	    TLSETL(1300374);
	    {
		TLstring	__x997;
		Language_LoadObjectFile_GetFileName((Language_LoadObjectFile_FileNoType) fileNo, __x997);
		{
		    TLstring	__x996;
		    TL_TLS_TLSCAT("Main Program = \'", __x997, __x996);
		    {
			TLstring	__x995;
			TL_TLS_TLSCAT(__x996, "\'", __x995);
			puts(__x995);
		    };
		};
	    };
	    TLINCL();
	    {
		TLstring	__x999;
		TL_TLS_TLSVIS((TLaddressint) (*startPC), (TLint4) 0, (TLint4) 16, __x999);
		{
		    TLstring	__x998;
		    TL_TLS_TLSCAT("Starting PC = 0x", __x999, __x998);
		    puts(__x998);
		};
	    };
	};
    } else {
	TLSETL(1300378);
	(*startPC) = (TLaddressint) ((unsigned long) codeTable + 4);
	TLINCL();
	if (debug) {
	    TLSETL(1300381);
	    puts("No Main Program designated");
	    TLINCL();
	    {
		TLstring	__x1001;
		TL_TLS_TLSVIS((TLaddressint) (*startPC), (TLint4) 0, (TLint4) 16, __x1001);
		{
		    TLstring	__x1000;
		    TL_TLS_TLSCAT("Starting PC = 0x", __x1001, __x1000);
		    puts(__x1000);
		};
	    };
	};
    };
    TLSETL(1300394);
    ptr = Language_LoadObjectFile_fileTableHdr;
    TLSETL(1300396);
    for(;;) {
	TLSETL(1300396);
	if (ptr == ((struct Language_LoadObjectFile_FileTableNode *) 0)) {
	    break;
	};
	TLSETL(1300397);
	if ((unsigned long) (ptr->codeTable) != 0) {
	    TLSETL(1300398);
	    if ((ptr->bodyFileNo) == 0) {
		TLSETL(1300399);
		(* (TLnat4 *) (ptr->codeTable)) = 0;
	    } else {
		struct Language_LoadObjectFile_FileTableNode	*bodyUnit;
		TLSETL(1300402);
		bodyUnit = Language_LoadObjectFile_GetFile((Language_LoadObjectFile_FileNoType) (ptr->bodyFileNo));
		TLSETL(1300404);
		for(;;) {
		    TLSETL(1300404);
		    stubFileNo = bodyUnit->stubFileNo;
		    TLINCL();
		    if (stubFileNo == (ptr->fileNo)) {
			break;
		    };
		    TLSETL(1300406);
		    bodyUnit = Language_LoadObjectFile_GetFile((Language_LoadObjectFile_FileNoType) stubFileNo);
		};
		TLSETL(1300408);
		(* (TLnat4 *) (ptr->codeTable)) = (unsigned long) (bodyUnit->codeTable) + 4;
	    };
	};
	TLSETL(1300412);
	ptr = ptr->next;
    };
    TLRESTORELF();
}

static void LoadObjectFile () {
    TLSAVELF();
    TLSETF();
    TLSETL(1300034);
    Language_LoadObjectFile_fileTableHdr = (struct Language_LoadObjectFile_FileTableNode *) 0;
    TLRESTORELF();
}
static TLboolean	Language_pendingError;

void Language_SetupExecutionFromObjectFile (objectFileStream, debug, maxStackSize, inName, outName, args, numArgs)
TLint4	objectFileStream;
TLboolean	debug;
TLnat4	maxStackSize;
TLstring	inName;
TLstring	outName;
__x869	args;
TLint4	numArgs;
{
    struct TLHAREA	quitCode;
    TLSTKCHKSLF(100651);
    if (TLHANDENTER(quitCode)) {
	TLSETF();
	TLSETL(100651);
	Language_pendingError = 1;
	TLSETL(100653);
	if (quitCode.quitCode != 1) {
	    TLSETL(100654);
	    TL_TLE_TLEQUIT ((TLint4) quitCode.quitCode, (char *) 0, 1);
	};
    } else {
	TLaddressint	startPC;
	TLSETF();
	TLSETL(100659);
	Language_pendingError = 0;
	TLSETL(100662);
	Language_ErrorModule_Initialize();
	TLSETL(100665);
	Language_LoadObjectFile_LoadAndLink((TLint4) objectFileStream, &(startPC), (TLboolean) debug);
	TLSETL(100667);
	Language_Execute_Initialize((TLaddressint) startPC, (TLnat4) maxStackSize, inName, outName, args, (TLint4) numArgs);
	TL_TLE_TLEHX();
    }
}

void Language_GetFileName (fileNo, __x189)
TLnat2	fileNo;
TLstring	__x189;
{
    TLSTKCHKSLF(100671);
    TLSETF();
    TLSETL(100671);
    {
	{
	    TLstring	__x1004;
	    Language_LoadObjectFile_GetFileName((Language_LoadObjectFile_FileNoType) fileNo, __x1004);
	    TLSTRASS(255, __x189, __x1004);
	};
	TLRESTORELF();
	return;
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}
