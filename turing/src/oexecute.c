#include "cinterface"
static struct {
    TLint4	dummy;
    char	dummy2[2023];
} TLFTAB =
    { 35,
    {'/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'e', 'x', 'e', 'c', 'u', 't', 'e', '.', 'b', 'd', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'e', 'x', 'e', 'c', 'u', 't', 'e', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', '.', '.', '/', '.', '.', '/', 'f', 'i', 'l', 'e', 'm', 'a', 'n', '/', 'f', 'i', 'l', 'e', 'm', 'a', 'n', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', '.', '.', '/', 'd', 'u', 'm', 'm', 'y', '.', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', '.', '.', '/', 'e', 'n', 'v', 'i', 'r', 'o', 'n', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', '.', '.', '/', 'm', 's', 'g', 's', '.', 'd', 'e', 'f', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', '.', '.', '/', 'd', 'e', 'b', 'u', 'g', '.', 'd', 'e', 'f', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', '.', '.', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', '.', '.', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '.', 'b', 'd', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', '.', '.', '/', 'u', 'n', 'i', 't', 'm', 'a', 'n', '/', 'u', 'n', 'i', 't', 'm', 'a', 'n', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', '.', '.', '/', 'e', 'r', 'r', 'o', 'r', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', '.', '.', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'p', 's', 'e', 'u', 'd', 'o', '.', 'd', 'e', 'f', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', '.', '.', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'o', 'p', 'c', 'o', 'd', 'e', '.', 'i', 'n', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', '.', '.', '/', 'd', 'e', 'b', 'u', 'g', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', '.', '.', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'E', 'x', 'e', 'c', 'E', 'r', 'r', 'B', 'o', 'd', 'y', '\0',
    '/', 'l', 'o', 'c', 'a', 'l', '/', 'i', 'n', 'c', 'l', 'u', 'd', 'e', '/', 't', 'p', 'l', 'u', 's', '/', 'D', 'O', 'S', '3', '2', '/', 'k', 'e', 'r', 'n', 'e', 'l', 'T', 'y', 'p', 'e', 's', '\0',
    '/', 'l', 'o', 'c', 'a', 'l', '/', 'i', 'n', 'c', 'l', 'u', 'd', 'e', '/', 't', 'p', 'l', 'u', 's', '/', 'c', 'o', 'm', 'm', 'o', 'n', '/', 'h', 'a', 'n', 'd', 'l', 'e', 'r', '\0',
    '/', 'l', 'o', 'c', 'a', 'l', '/', 'i', 'n', 'c', 'l', 'u', 'd', 'e', '/', 't', 'p', 'l', 'u', 's', '/', 'c', 'o', 'm', 'm', 'o', 'n', '/', 'm', 'o', 'n', 'i', 't', 'o', 'r', '\0',
    '/', 'l', 'o', 'c', 'a', 'l', '/', 'i', 'n', 'c', 'l', 'u', 'd', 'e', '/', 't', 'p', 'l', 'u', 's', '/', 'c', 'o', 'm', 'm', 'o', 'n', '/', 'k', 'e', 'r', 'n', 'e', 'l', '\0',
    '/', 'l', 'o', 'c', 'a', 'l', '/', 'i', 'n', 'c', 'l', 'u', 'd', 'e', '/', 't', 'p', 'l', 'u', 's', '/', 'c', 'o', 'm', 'm', 'o', 'n', '/', 'e', 'x', 'c', 'e', 'p', 't', 'i', 'o', 'n', 's', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'h', 'e', 'a', 'p', '.', 'c', 'h', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'M', 'I', 'O', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'k', 'e', 'r', 'n', 'e', 'l', '.', 'i', 'n', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'k', 'e', 'r', 'n', 'e', 'l', '.', 'c', 'h', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'p', 'c', '_', 'e', 'x', 't', 'e', 'r', 'n', 'a', 'l', '/', 'M', 'a', 't', 'h', '.', 'c', 'h', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'p', 'c', '_', 'e', 'x', 't', 'e', 'r', 'n', 'a', 'l', '/', 'S', 't', 'r', 'i', 'n', 'g', '.', 'c', 'h', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'p', 'c', '_', 'e', 'x', 't', 'e', 'r', 'n', 'a', 'l', '/', 'S', 'y', 's', 't', 'e', 'm', '.', 'c', 'h', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'p', 'c', '_', 'e', 'x', 't', 'e', 'r', 'n', 'a', 'l', '/', 'L', 'i', 'm', 'i', 't', 's', '.', 'c', 'h', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'p', 'c', '_', 'e', 'x', 't', 'e', 'r', 'n', 'a', 'l', '/', 'G', 'r', 'a', 'p', 'h', 'i', 'c', 's', '.', 'c', 'h', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'p', 'c', '_', 'e', 'x', 't', 'e', 'r', 'n', 'a', 'l', '/', 'E', 'v', 'e', 'n', 't', '.', 'c', 'h', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'p', 'c', '_', 'e', 'x', 't', 'e', 'r', 'n', 'a', 'l', '/', 'M', 'T', '.', 'c', 'h', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'p', 'c', '_', 'e', 'x', 't', 'e', 'r', 'n', 'a', 'l', '/', 's', 't', 'a', 'r', '/', 'S', 't', 'a', 'r', '.', 'c', 'h', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'r', 'u', 'n', '.', 's', 't', '\0',
    '/', 'l', 'o', 'c', 'a', 'l', '/', 'i', 'n', 'c', 'l', 'u', 'd', 'e', '/', 't', 'p', 'l', 'u', 's', '/', 'c', 'o', 'm', 'm', 'o', 'n', '/', 's', 'y', 's', 't', 'e', 'm', '\0'
    }};
typedef	TLnat2	FileManager_FileNoType;
typedef	TLnat4	FileManager_FileTimeStamp;
typedef	TLint2	FileManager_ResultCode;

extern void FileManager_OpenNamedHandle ();

extern void FileManager_OpenUnnamedHandle ();

extern void FileManager_OpenFileHandle ();

extern void FileManager_SetModified ();

extern void FileManager_WriteFile ();

extern void FileManager_WriteBackup ();

extern void FileManager_WriteTemp ();

extern void FileManager_RmTemp ();

extern void FileManager_CloseFileHandle ();

extern void FileManager_OpenNamedText ();

extern void FileManager_OpenFileText ();

extern void FileManager_CloseFileText ();

extern void FileManager_CloseAllText ();

extern void FileManager_ChangeDirectory ();

extern void FileManager_GetDirectory ();

extern void FileManager_ChangeExecDirectory ();

extern void FileManager_GetExecDirectory ();

extern void FileManager_ShortName ();

extern void FileManager_RelativeName ();

extern void FileManager_PathName ();

extern void FileManager_ExecPathName ();

extern void FileManager_ExtendName ();

extern void FileManager_FileName ();

extern TLboolean FileManager_IsUnnamed ();

extern TLboolean FileManager_IsOnDisk ();

extern TLboolean FileManager_IsSameFile ();

extern TLboolean FileManager_IsReadOK ();

extern TLboolean FileManager_IsWriteOK ();

extern TLboolean FileManager_IsOlder ();

extern TLboolean FileManager_FileExists ();

extern void FileManager_AddReference ();

extern void FileManager_DeleteReference ();

extern void FileManager_ReadTimeStamp ();

extern void FileManager_FlushUnreferencedFiles ();

extern void FileManager_CheckReferencedFiles ();

extern void FileManager_RmFile ();

extern void FileManager_SetDefaultInclude ();

extern void FileManager_AssertTextClosed ();

extern void FileManager_Dump ();

extern TLboolean AbortCheck ();

extern void FeedBack ();
struct	SrcPosition {
    TLnat2	lineNo;
    FileManager_FileNoType	fileNo;
    TLnat2	linePos;
    TLnat2	tokLen;
};
typedef	TLchar	__x1894[256];
struct	ErrMsgDef {
    struct ErrMsgDef	*next;
    struct SrcPosition	srcPos;
    __x1894	text;
};
typedef	TLint4	CookieKind;
struct	Cookie {
    CookieKind	kind;
    TLaddressint	item;
    TLaddressint	fp;
    TLaddressint	data;
};
struct	CallDef {
    struct CallDef	*next;
    TLstring	routineName;
    struct SrcPosition	srcPos;
    struct Cookie	cookie;
};
struct	ThreadDef {
    struct ThreadDef	*next;
    TLaddressint	threadId;
    TLaddressint	threadName;
    struct CallDef	*traceback;
};
struct	ThreadQueueDef {
    struct ThreadQueueDef	*next;
    TLaddressint	queueId;
    TLstring	queueName;
    struct ThreadDef	*threadList;
};
struct	DumpIndexDef {
    struct DumpIndexDef	*next;
    TLint4	lowerBound;
    TLint4	upperBound;
};
struct	DumpSymbolDef {
    struct DumpSymbolDef	*next;
    TLaddressint	symbolName;
    TLaddressint	typeName;
    struct SrcPosition	srcPos;
    TLstring	value;
    struct Cookie	cookie;
    TLboolean	isPredef;
};
struct	DumpScopeDef {
    struct DumpSymbolDef	symbolInfo;
    struct Cookie	expandCookie;
    struct DumpSymbolDef	*parameters;
    struct DumpSymbolDef	*declarations;
};

extern void Language_Debugging ();

extern void Language_Paragraph ();

extern void Language_Reset ();

extern void Language_SetMaxErrorCount ();
typedef	TLstring	__x1895[20];

extern void Language_EnterPreprocSymbols ();

extern void Language_CompileUnit ();

extern void Language_CompileProgram ();

extern void Language_WriteObjectFile ();
typedef	TLstring	__x1898[21];
typedef	TLstring	__x1902[21];

extern void Language_SetupExecution ();
typedef	TLint1	Language_Step;

extern void Language_SetStep ();
typedef	TLint1	Language_ReturnState;
struct	Language_RunStatus {
    Language_ReturnState	state;
    struct SrcPosition	srcPos;
    TLaddressint	threadId;
};

extern void Language_ExecuteProgram ();

extern void Language_EndExecution ();

extern void Language_StopExecution ();

extern void Language_DumpThreadList ();

extern void Language_DumpUnitList ();

extern void Language_DumpScopeInfo ();

extern void Language_DumpSymbolInfo ();

extern void Language_DumpArrayBounds ();

extern void Language_DumpArrayValues ();
extern TLboolean	Language_debug;
extern struct SrcPosition	Language_nullSrcPosition;
extern struct Cookie	Language_nullCookie;
extern struct DumpSymbolDef	Language_nullSymbolDef;
extern struct DumpScopeDef	Language_nullScopeDef;
typedef	TLint1	Language_UnitManager_UnitKind;
typedef	TLint1	Language_UnitManager_UnitStatus;

extern void Language_UnitManager_AddDepend ();

extern void Language_UnitManager_AddIncludeFile ();

extern void Language_UnitManager_AllocateCompileChunk ();

extern void * Language_UnitManager_BodyUnit ();

extern void Language_UnitManager_ClearAllMarks ();

extern void Language_UnitManager_ClearConfiguration ();

extern TLaddressint Language_UnitManager_CodeTable ();

extern FileManager_FileNoType Language_UnitManager_FileNo ();

extern void Language_UnitManager_FlushOldUnits ();

extern void Language_UnitManager_GetNextDepend ();

extern void Language_UnitManager_GetNextUnit ();

extern void Language_UnitManager_GetUnitPtr ();

extern TLaddressint Language_UnitManager_GlobalArea ();

extern TLint4 Language_UnitManager_GlobalSize ();

extern TLboolean Language_UnitManager_IsCompiled ();

extern TLboolean Language_UnitManager_IsMarked ();

extern TLboolean Language_UnitManager_IsPredef ();

extern Language_UnitManager_UnitKind Language_UnitManager_Kind ();

extern TLaddressint Language_UnitManager_ManifestTable ();

extern void * Language_UnitManager_OverrideBody ();

extern void Language_UnitManager_PrepareForCompile ();

extern void Language_UnitManager_PrepareForDepends ();

extern void Language_UnitManager_PrepareForScan ();

extern void Language_UnitManager_Reset ();

extern void Language_UnitManager_RewindDependList ();

extern void Language_UnitManager_RewindUnitList ();

extern void Language_UnitManager_SetCodeTable ();

extern void Language_UnitManager_SetDefaultBody ();

extern void Language_UnitManager_SetGlobalArea ();

extern void Language_UnitManager_SetKind ();

extern void Language_UnitManager_SetManifestTable ();

extern void Language_UnitManager_SetMark ();

extern void Language_UnitManager_SetOverrideBody ();

extern void Language_UnitManager_SetPredef ();

extern void Language_UnitManager_SetStub ();

extern void Language_UnitManager_SetSymbolTable ();

extern void Language_UnitManager_StartNewProgram ();

extern void * Language_UnitManager_StubUnit ();

extern void Language_UnitManager_SuccessfulCompile ();

extern TLaddressint Language_UnitManager_SymbolTable ();
typedef	TLint1	Language_ErrorModule_Severity;

extern void Language_ErrorModule_Initialize ();

extern void Language_ErrorModule_SetMaxErrors ();

extern void Language_ErrorModule_Message ();

extern void Language_ErrorModule_AbortIfErrors ();

extern void Language_ErrorModule_ReturnErrors ();
typedef	Language_ErrorModule_Severity	Language_ErrorSeverity;
typedef	TLstring	Language_StringDef;
typedef	TLnat4	Language_Offset;
extern TLint4	Language_codeOprSize;
extern TLint4	Language_codeInt1Size;
extern TLint4	Language_codeInt2Size;
extern TLint4	Language_codeIntSize;
extern TLint4	Language_codeRealSize;
extern TLint4	Language_codeAddrSize;
extern TLint4	Language_codeOffsetSize;
typedef	TLchar	Language_string1[2];
typedef	TLnat1	Language_set8;
typedef	TLnat2	Language_set16;
typedef	TLnat4	Language_set32;
typedef	TLint2	Language_Opcode;
typedef	TLchar	Language___x1906[22];
typedef	Language___x1906	Language___x1905[255];
extern Language___x1905	Language_OpcodeName;
struct	Language_CodeHeader {
    TLaddressint	bodyCode;
};
struct	Language___x1908 {
    TLint4	lower, range;
};
typedef	struct Language___x1908	Language___x1907[255];
struct	Language_ArrayDescriptor {
    TLnat4	sizeArray;
    TLnat4	sizeElement;
    TLnat4	elementCount;
    TLnat4	numDimensions;
    Language___x1907	dim;
};
struct	Language_ForDescriptor {
    TLint4	counter;
    TLint4	right;
    TLint4	step;
    TLaddressint	savedSP;
};
typedef	Language_Offset	Language___x1909[1001];
struct	Language_CaseDescriptor {
    TLint4	lower, upper;
    Language_Offset	otherwise;
    Language___x1909	caseVector;
};
struct	Language_PointerDescriptor {
    TLaddressint	dataPtr;
    TLint4	timestamp;
};
typedef	TLnat2	Language___x1910[301];
struct	Language_UnionMapDescriptor {
    TLint4	lower, upper;
    Language___x1910	map;
};
typedef	TLnat4	Language_ClassAttr;
struct	Language_ClassDescriptor {
    TLaddressint	baseClass;
    TLaddressint	expandClass;
    Language_ClassAttr	attributes;
    TLnat4	objSize;
    TLaddressint	classId;
    TLaddressint	initRoutine;
    TLnat4	numOperations;
};
typedef	TLint1	Language_OpenKind;
typedef	TLint1	Language_PutKind;
typedef	TLint1	Language_GetKind;
typedef	TLint1	Language_SetStreamKind;
typedef	TLnat1	Language_StreamModeSet;
typedef	TLint1	Language_SubstringKind;
typedef	TLint1	Language_RangeCheckKind;
typedef	TLint1	Language_ConditionKind;

extern void Language_DebugModule_Initialize ();

extern void Language_DebugModule_NewQueue ();

extern void Language_DebugModule_NewThread ();

extern void Language_DebugModule_NewCall ();

extern void Language_DebugModule_ReturnThreadDump ();

extern void Language_DebugModule_NewSymbolList ();

extern void Language_DebugModule_NewSymbol ();

extern void Language_DebugModule_ReturnSymbolDump ();

extern void Language_DebugModule_NewIndexList ();

extern void Language_DebugModule_NewIndex ();

extern void Language_DebugModule_ReturnIndexDump ();

extern void Language_Compile_Reset ();

extern void Language_Compile_Initialize ();
typedef	TLstring	__x1913[20];

extern void Language_Compile_EnterPreprocSymbols ();

extern void Language_Compile_ScanUnit ();

extern void Language_Compile_CompileUnit ();

extern void Language_Compile_InstallUnit ();

extern void Language_Compile_CallInfo ();

extern void Language_Compile_DumpUnitList ();

extern void Language_Compile_DumpScopeInfo ();

extern void Language_Compile_DumpSymbolInfo ();

extern void Language_Compile_DumpArrayBounds ();

extern void Language_Compile_DumpArrayValues ();

extern void Language_Compile_SetObjectFileStream ();
typedef	TLstring	__x1916[21];

void Language_Execute_Initialize ();

TLint4 Language_Execute_GetStackAllocated ();

void Language_Execute_Executor ();

void Language_Execute_EndExecution ();

void Language_Execute_RecoverAllMemory ();

void Language_Execute_SetStep ();

void Language_Execute_DumpThreadList ();

void Language_Execute_UnitInitState ();
TLint2	Language_Execute_executionTimeout;
TLint4	Language_Execute_stackAllocated;
TLboolean	Language_Execute_allWaitingForKeyboard;

extern void TL_TLB_TLBUUN ();

extern void TL_TLB_TLBUNI ();

extern void strcpy ();
typedef	TLint2	Language_Execute_ExecutionError_OverflowKind;
static TLint4	Language_Execute_ExecutionError_savedQuitCode;
static TLstring	Language_Execute_ExecutionError_savedMessage;

void Language_Execute_ExecutionError_Abort (quitCode, message)
TLint4	quitCode;
TLstring	message;
{
    TLSTKCHKSLF(1600018);
    TLSETF();
    TLSETL(1600018);
    Language_Execute_ExecutionError_savedQuitCode = quitCode;
    TLINCL();
    TLSTRASS(255, Language_Execute_ExecutionError_savedMessage, message);
    TLINCL();
    TL_TLE_TLEQUIT ((TLint4) 2, (char *) 0, 0);
    TLRESTORELF();
}
static Language_Execute_ExecutionError_OverflowKind	Language_Execute_ExecutionError_overflowKind;

void Language_Execute_ExecutionError_SetOverflowKind (kind)
Language_Execute_ExecutionError_OverflowKind	kind;
{
    TLSTKCHKSLF(1600029);
    TLSETF();
    TLSETL(1600029);
    Language_Execute_ExecutionError_overflowKind = kind;
    TLRESTORELF();
}
typedef	TLnat4	Language_Execute_ExecutionError_TL_priority_t;
struct	Language_Execute_ExecutionError_TL_ExceptionInfo {
    TLint4	quitCode;
    TLint4	libraryQuitCode;
    TLstring	errorMsg;
};
typedef	TLnat1	Language_Execute_ExecutionError___x1919[1];
struct	Language_Execute_ExecutionError_TL_HandlerArea {
    TLint4	quitCode;
    TLnat4	lineAndFile;
    TLaddressint	fileTable;
    struct Language_Execute_ExecutionError_TL_HandlerArea	*nextHandler;
    Language_Execute_ExecutionError___x1919	savedState;
};
typedef	TLnat4	Language_Execute_ExecutionError_TL_hardwarePriority_t;
typedef	Language_Execute_ExecutionError_TL_hardwarePriority_t	Language_Execute_ExecutionError_TL_lockStatus_t;
typedef	TLnat4	Language_Execute_ExecutionError_TL_lock_t;
struct	Language_Execute_ExecutionError_TL_link_t {
    struct Language_Execute_ExecutionError_TL_ProcessDescriptor	*flink;
    struct Language_Execute_ExecutionError_TL_ProcessDescriptor	*blink;
};
struct	Language_Execute_ExecutionError_TL_ProcessDescriptor {
    TLnat4	lineAndFile;
    TLaddressint	fileTable;
    TLaddressint	stackLimit;
    TLaddressint	stackPointer;
    struct Language_Execute_ExecutionError_TL_HandlerArea	*handlerQhead;
    struct Language_Execute_ExecutionError_TL_HandlerArea	*currentHandler;
    TLaddressint	name;
    struct Language_Execute_ExecutionError_TL_ExceptionInfo	exception;
    TLnat4	waitParameter;
    struct Language_Execute_ExecutionError_TL_ProcessDescriptor	*monitorQlink;
    TLnat4	timeOutStatus;
    TLnat4	pid;
    TLaddressint	memoryBase;
    TLnat4	timeoutTime;
    TLnat4	timeoutEpoch;
    struct Language_Execute_ExecutionError_TL_link_t	timeoutQ;
    TLboolean	timedOut;
    TLboolean	pausing;
    Language_Execute_ExecutionError_TL_priority_t	dispatchPriority;
    struct Language_Execute_ExecutionError_TL_ProcessDescriptor	*runQlink;
    TLboolean	ready;
    struct Language_Execute_ExecutionError_TL_ProcessDescriptor	*tsyncWaiter;
    TLnat4	quantum;
    TLnat4	quantumCntr;
    TLnat4	devmonLevel;
    TLaddressint	otherInfo;
};
struct	Language_Execute_ExecutionError_TL_queue_t {
    struct Language_Execute_ExecutionError_TL_ProcessDescriptor	*head;
    struct Language_Execute_ExecutionError_TL_ProcessDescriptor	*tail;
};
struct	Language_Execute_ExecutionError_TL_MonitorDescriptor {
    Language_Execute_ExecutionError_TL_lock_t	mQLock;
    TLint4	entryParameter;
    TLint4	monitorPriority;
    TLboolean	deviceMonitor;
    struct Language_Execute_ExecutionError_TL_queue_t	entryQ;
    struct Language_Execute_ExecutionError_TL_queue_t	reEntryQ;
    TLaddressint	name;
    struct Language_Execute_ExecutionError_TL_ConditionDescriptor	*firstCondition;
    struct Language_Execute_ExecutionError_TL_MonitorDescriptor	*nextMonitor;
    struct Language_Execute_ExecutionError_TL_MonitorDescriptor	*prevMonitor;
    TLaddressint	otherInfo;
};
struct	Language_Execute_ExecutionError_TL_ConditionDescriptor {
    struct Language_Execute_ExecutionError_TL_queue_t	signalQ;
    struct Language_Execute_ExecutionError_TL_MonitorDescriptor	*md;
    TLaddressint	name;
    TLnat4	index;
    struct Language_Execute_ExecutionError_TL_ConditionDescriptor	*nextCondition;
    struct Language_Execute_ExecutionError_TL_ConditionDescriptor	*prevCondition;
    TLaddressint	otherInfo;
};
typedef	struct Language_Execute_ExecutionError_TL_ConditionDescriptor	Language_Execute_ExecutionError___x1922[65535];
extern struct Language_Execute_ExecutionError_TL_ProcessDescriptor	*TL_TLKPD;
extern struct Language_Execute_ExecutionError_TL_ProcessDescriptor	*TL_TLK_TLKTQH;
extern struct Language_Execute_ExecutionError_TL_MonitorDescriptor	*TL_TLM_TLMMLH;

void Language_Execute_ExecutionError_GetAbort (quitCode, message)
TLint4	*quitCode;
TLstring	message;
{
    TLSTKCHKSLF(1600043);
    TLSETF();
    TLSETL(1600043);
    if ((*quitCode) == 2) {
	TLSETL(1600044);
	(*quitCode) = Language_Execute_ExecutionError_savedQuitCode;
	TLINCL();
	TLSTRASS(255, message, Language_Execute_ExecutionError_savedMessage);
    } else {
	TLSETL(1600046);
	if ((*quitCode) == 51) {
	    TLSETL(1600047);
	    if (Language_Execute_ExecutionError_overflowKind == 1) {
		TLSETL(1600048);
		TLSTRASS(255, message, "Overflow in real \'mod\' operation");
	    } else {
		TLSETL(1600049);
		if (Language_Execute_ExecutionError_overflowKind == 2) {
		    TLSETL(1600050);
		    TLSTRASS(255, message, "Overflow in real \'div\' operation");
		} else {
		    TLSETL(1600055);
		    TLSTRASS(255, message, TL_TLKPD->exception.errorMsg);
		};
	    };
	} else {
	    TLSETL(1600063);
	    TLSTRASS(255, message, TL_TLKPD->exception.errorMsg);
	};
    };
    TLRESTORELF();
}

void Language_Execute_ExecutionError_Initialize () {
    TLSTKCHKSLF(1600072);
    TLSETF();
    TLSETL(1600072);
    Language_Execute_ExecutionError_savedQuitCode = 0;
    TLINCL();
    TLSTRASS(255, Language_Execute_ExecutionError_savedMessage, "");
    TLINCL();
    Language_Execute_ExecutionError_overflowKind = 0;
    TLRESTORELF();
}

void ExecutionError () {
    TLSAVELF();
    TLSETF();
    TLRESTORELF();
}

extern void Language_Execute_Heap_Alloc ();

extern void Language_Execute_Heap_CleanUp ();

extern void Language_Execute_Heap_Dealloc ();

extern void Language_Execute_Heap_Free ();

extern void Language_Execute_Heap_New ();

extern void Language_Execute_Heap_Realloc ();
typedef	TLint1	MIO_EventMode;
struct	MIO_EventDescriptor {
    MIO_EventMode	mode;
    TLint4	count;
};

extern TLboolean MIO_HasEvent ();

extern TLboolean MIO_SetActive ();

extern void MIO_NextEvent ();

extern void MIO_SetEvents ();

extern void MIO_GetEvent ();
typedef	TLchar	__x1923[4];

extern void MIO_KeyTranslate ();

extern TLchar MIO_Getch ();

extern TLboolean MIO_Hasch ();

extern void MIO_Clip ();

extern void MIO_ClipOff ();

extern void MIO_Clear ();

extern TLint4 MIO_ColourNum ();

extern void MIO_DrawArc ();

extern void MIO_DrawBox ();

extern void MIO_DrawDot ();

extern void MIO_DrawFill ();

extern void MIO_DrawFillArc ();

extern void MIO_DrawFillBox ();

extern void MIO_DrawFillOval ();

extern void MIO_DrawFillPolygon ();

extern void MIO_DrawLine ();

extern void MIO_DrawOval ();

extern void MIO_DrawPic ();

extern void MIO_DrawPolygon ();

extern void MIO_DrawText ();

extern void MIO_DrawTextSize ();

extern TLint4 MIO_FontNum ();

extern void MIO_GetColour ();

extern TLint4 MIO_GetDotColour ();

extern void MIO_GetGraphMax ();

extern TLint4 MIO_GetMaxColour ();

extern TLint4 MIO_GetMaxFont ();

extern TLint4 MIO_GetPalette ();

extern void MIO_GetPos ();

extern void MIO_GetRgb ();

extern void MIO_GetScreenSize ();

extern void MIO_GetTextChar ();

extern TLint4 MIO_GetTextFont ();

extern void MIO_GetTextMax ();

extern void MIO_NumColour ();

extern void MIO_NumFont ();

extern void MIO_SetBackgroundColour ();

extern void MIO_SetPalette ();

extern void MIO_SetPos ();

extern void MIO_SetPosXY ();

extern void MIO_SetRgb ();

extern void MIO_SetTextBackgroundColour ();

extern void MIO_SetTextColour ();

extern void MIO_SetTextFont ();

extern TLint4 MIO_SizePic ();

extern void MIO_TakePic ();

extern void MIO_Init ();

extern void MIO_End ();

extern void MIO_Mode ();

extern void MIO_Delay ();

extern void MIO_PlaySound ();

extern void MIO_Play ();

extern TLboolean MIO_PlayDone ();

extern void MIO_RegisterOpen ();

extern void MIO_RegisterClose ();
TLnat2	Language_Execute_numArguments;
typedef	TLint1	Language_Execute___x1924[23];
Language_Execute___x1924	Language_Execute_fileMap;
typedef	Language_StringDef	*Language_Execute___x1927[21];
Language_Execute___x1927	Language_Execute_argumentNames;
static TLnat2	Language_Execute_numFilesOpen;
extern TLboolean	TL_TLI_TLIUXS;
extern TLint4	TL_TLI_TLIXSN;

extern void TL_TLI_TLIOF ();

extern void TL_TLI_TLISS ();

extern void TL_TLI_TLIPC ();

extern void TL_TLI_TLIGC ();

extern TLaddressint TL_TLI_TLIGF ();

static void Language_Execute_OpenFile (openMode, fileName, streamNo)
TLint2	openMode;
TLstring	fileName;
TLint4	*streamNo;
{
    TLstring	fullName;
    TLSTKCHKSLF(100214);
    TLSETF();
    TLSETL(100214);
    {
	TLchar	__x1930[6];
	{
	    TLchar	__x1929[10];
	    {
		TLchar	__x1928[9];
		if ((((TL_TLS_TLSLEN(fileName) >= 7) && ((TL_TLS_TLSBXX(__x1928, (TLint4) 7, (TLint4) 1, fileName), strcmp(__x1928, "%window") == 0))) || ((TL_TLS_TLSLEN(fileName) >= 8) && ((TL_TLS_TLSBXX(__x1929, (TLint4) 8, (TLint4) 1, fileName), strcmp(__x1929, "%printer") == 0)))) || ((TL_TLS_TLSLEN(fileName) >= 4) && ((TL_TLS_TLSBXX(__x1930, (TLint4) 4, (TLint4) 1, fileName), strcmp(__x1930, "%net") == 0)))) {
		    TLSETL(100217);
		    TLSTRASS(255, fullName, fileName);
		} else {
		    TLSETL(100219);
		    {
			TLstring	__x1931;
			FileManager_ExecPathName(fileName, __x1931);
			TLSTRASS(255, fullName, __x1931);
		    };
		};
	    };
	};
    };
    TLSETL(100226);
    TL_TLI_TLIOF((TLint2) openMode, fullName, &((*streamNo)));
    TLRESTORELF();
}

TLint4 Language_Execute_GetStackAllocated () {
    TLSTKCHKSLF(100230);
    TLSETF();
    TLSETL(100230);
    TLRESTORELF();
    return (Language_Execute_stackAllocated);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

void Language_Execute_AddFile (fnum, mode)
TLint4	*fnum;
TLint4	mode;
{
    TLSTKCHKSLF(100235);
    TLSETF();
    TLSETL(100235);
    if ((*fnum) == 0) {
	TLSETL(100237);
	TLRESTORELF();
	return;
    };
    TLSETL(100239);
    if ((Language_Execute_numArguments + Language_Execute_numFilesOpen) == 20) {
	TLSETL(100240);
	TL_TLI_TLICL ((TLint4) (*fnum));
	TLINCL();
	(*fnum) = 0;
	TLSETL(100243);
	TLRESTORELF();
	return;
    };
    TLSETL(100245);
    {
	register TLint4	i;
	for (i = Language_Execute_numArguments + 1; i <= 20; i++) {
	    TLSETL(100246);
	    if ((Language_Execute_fileMap[TLINRANGELOW(i, -2, 20, 1)]) == -3) {
		TLSETL(100247);
		Language_Execute_fileMap[TLINRANGELOW(i, -2, 20, 1)] = (*fnum);
		TLINCL();
		(*fnum) = i;
		TLINCL();
		Language_Execute_numFilesOpen += 1;
		TLSETL(100254);
		MIO_RegisterOpen((TLint4) (*fnum), (TLint4) mode);
		TLINCL();
		TLRESTORELF();
		return;
	    };
	};
    };
    TLSETL(100257);
    TLASSERT (0);
    TLRESTORELF();
}

static void Language_Execute_CloseArguments () {
    TLSTKCHKSLF(100262);
    TLSETF();
    TLSETL(100262);
    {
	register TLint4	i;
	TLint4	__x1932;
	__x1932 = Language_Execute_numArguments;
	i = 1;
	if (i <= __x1932) {
	    for(;;) {
		TLSETL(100263);
		if ((Language_Execute_argumentNames[TLINRANGELOW(i, 0, 20, 1)]) != ((Language_StringDef *) 0)) {
		    TLSETL(100264);
		    TL_TLB_TLBFRU(& Language_Execute_argumentNames[TLINRANGELOW(i, 0, 20, 1)], (TLint4)  sizeof (		    Language_StringDef));
		    TLINCL();
		    Language_Execute_argumentNames[TLINRANGELOW(i, 0, 20, 1)] = (Language_StringDef *) 0;
		};
		if (i == __x1932) break;
		i++;
	    }
	};
    };
    TLSETL(100268);
    Language_Execute_numArguments = 0;
    TLRESTORELF();
}

void Language_Execute_CloseFile (fnum)
register TLint4	fnum;
{
    TLSTKCHKSLF(100273);
    TLSETF();
    TLSETL(100273);
    TL_TLI_TLIXSN = fnum;
    TLINCL();
    if ((fnum < 1) || (fnum > 20)) {
	TLSETL(100277);
	{
	    TLstring	__x1934;
	    TL_TLS_TLSVIS((TLint4) fnum, (TLint4) 1, (TLint4) 10, __x1934);
	    {
		TLstring	__x1933;
		TL_TLS_TLSCAT("Close of illegal stream number ", __x1934, __x1933);
		Language_Execute_ExecutionError_Abort((TLint4) 10000, __x1933);
	    };
	};
    } else {
	TLSETL(100277);
	if ((Language_Execute_fileMap[TLINRANGELOW(fnum, -2, 20, 1)]) == -3) {
	    TLSETL(100280);
	    {
		TLstring	__x1936;
		TL_TLS_TLSVIS((TLint4) fnum, (TLint4) 1, (TLint4) 10, __x1936);
		{
		    TLstring	__x1935;
		    TL_TLS_TLSCAT("Close of closed stream number ", __x1936, __x1935);
		    Language_Execute_ExecutionError_Abort((TLint4) 10000, __x1935);
		};
	    };
	};
    };
    TLSETL(100282);
    TL_TLI_TLICL ((TLint4) (Language_Execute_fileMap[TLINRANGELOW(fnum, -2, 20, 1)]));
    TLSETL(100287);
    MIO_RegisterClose((TLint4) fnum);
    Language_Execute_fileMap[TLINRANGELOW(fnum, -2, 20, 1)] = -3;
    TLSETL(100289);
    if (fnum > Language_Execute_numArguments) {
	TLSETL(100290);
	Language_Execute_numFilesOpen -= 1;
    };
    TLRESTORELF();
}

static void Language_Execute_CloseAllFiles () {
    TLSTKCHKSLF(100296);
    TLSETF();
    TLSETL(100296);
    if ((Language_Execute_fileMap[0]) != -2) {
	TLSETL(100297);
	TL_TLI_TLICL ((TLint4) (Language_Execute_fileMap[0]));
	TLINCL();
	Language_Execute_fileMap[0] = -2;
    };
    TLSETL(100300);
    if ((Language_Execute_fileMap[1]) != -1) {
	TLSETL(100301);
	TL_TLI_TLICL ((TLint4) (Language_Execute_fileMap[1]));
	TLINCL();
	Language_Execute_fileMap[1] = -1;
	TLINCL();
	Language_Execute_fileMap[2] = -1;
    };
    TLSETL(100305);
    {
	register TLint4	i;
	for (i = 1; i <= 20; i++) {
	    TLSETL(100306);
	    if ((Language_Execute_fileMap[TLINRANGELOW(i, -2, 20, 1)]) != -3) {
		TLSETL(100307);
		TL_TLI_TLICL ((TLint4) (Language_Execute_fileMap[TLINRANGELOW(i, -2, 20, 1)]));
		TLSETL(100312);
		MIO_RegisterClose((TLint4) i);
		Language_Execute_fileMap[TLINRANGELOW(i, -2, 20, 1)] = -3;
	    };
	};
    };
    TLSETL(100315);
    Language_Execute_numFilesOpen = 0;
    TLRESTORELF();
}

static void Language_Execute_OpenArgumentFile (mode, abort)
Language_StreamModeSet	mode;
TLboolean	abort;
{
    TLint4	f;
    TLSTKCHKSLF(100320);
    TLSETF();
    TLSETL(100320);
    TLPRE (((TL_TLI_TLIXSN > 0) && (TL_TLI_TLIXSN <= Language_Execute_numArguments)) && ((Language_Execute_fileMap[TLINRANGELOW(TL_TLI_TLIXSN, -2, 20, 1)]) == -3));
    TLSETL(100324);
    if ((Language_Execute_argumentNames[TLINRANGELOW(TL_TLI_TLIXSN, 0, 20, 1)]) == ((Language_StringDef *) 0)) {
	TLSETL(100327);
	{
	    TLstring	__x1939;
	    TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x1939);
	    {
		TLstring	__x1938;
		TL_TLS_TLSCAT("Open argument ", __x1939, __x1938);
		{
		    TLstring	__x1937;
		    TL_TLS_TLSCAT(__x1938, " does not exist", __x1937);
		    Language_Execute_ExecutionError_Abort((TLint4) 10000, __x1937);
		};
	    };
	};
    };
    TLSETL(100332);
    Language_Execute_OpenFile((TLint2) (* (TLnat1 *) &mode), (*(Language_Execute_argumentNames[TLINRANGELOW(TL_TLI_TLIXSN, 0, 20, 1)])), &(f));
    if (f == 0) {
	TLSETL(100333);
	if (abort) {
	    TLSETL(100337);
	    {
		TLstring	__x1941;
		TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x1941);
		{
		    TLstring	__x1940;
		    TL_TLS_TLSCAT("Cannot open argument file number ", __x1941, __x1940);
		    Language_Execute_ExecutionError_Abort((TLint4) 10000, __x1940);
		};
	    };
	} else {
	    TLSETL(100338);
	    TL_TLI_TLIXSN = 0;
	};
    } else {
	TLSETL(100341);
	Language_Execute_fileMap[TLINRANGELOW(TL_TLI_TLIXSN, -2, 20, 1)] = f;
    };
    TLRESTORELF();
}

void Language_Execute_SetActive (stream)
TLint4	*stream;
{
    TLint4	fd;
    TLSTKCHKSLF(100349);
    TLSETF();
    TLSETL(100349);
    fd = -1;
    TLINCL();
    if ((*stream) != 0) {
	TLSETL(100351);
	if ((Language_Execute_fileMap[TLINRANGELOW((*stream), -2, 20, 1)]) != -3) {
	    TLSETL(100352);
	    fd = Language_Execute_fileMap[TLINRANGELOW((*stream), -2, 20, 1)];
	} else {
	    TLSETL(100354);
	    (*stream) = 0;
	};
    };
    TLSETL(100357);
    if (MIO_SetActive((TLaddressint) TL_TLI_TLIGF((TLint4) fd))) {
	TLboolean	dummy;
	TLSETL(100359);
	dummy = MIO_SetActive((TLaddressint) TL_TLI_TLIGF((TLint4) -1));
    };
    TLRESTORELF();
}
struct	Language_Execute_LibraryAbort {
    TLint4	quitCode;
    TLstring	errorMsg;
};
struct	Language_Execute_SavedRegisters {
    TLaddressint	fp;
    TLaddressint	sp;
};
struct	Language_Execute_HandlerArea {
    TLint4	quitCode;
    struct SrcPosition	srcPos;
    struct Language_Execute_HandlerArea	*nextHandler;
    TLaddressint	handlerRoutine;
    struct Language_Execute_SavedRegisters	savedRegisters;
};
struct	Language_Execute_PendingEvent {
    TLint4	stream;
    struct MIO_EventDescriptor	event;
};
struct	Language_Execute_ProcessDescriptor {
    TLaddressint	pc;
    TLaddressint	fp;
    TLaddressint	sp;
    TLaddressint	minimumSP;
    TLaddressint	stackBase;
    struct SrcPosition	srcPos;
    TLint4	activeStream;
    struct Language_Execute_PendingEvent	pendingEvent;
    struct Language_Execute_LibraryAbort	abort;
    TLint4	errno;
    TLstring	errMessage;
    TLint4	prevErrno;
    TLstring	prevErrMessage;
    TLaddressint	name;
    struct Language_Execute_ProcessDescriptor	*nextProcess;
    TLint4	dispatchPriority;
    TLnat4	waitParameter;
    struct Language_Execute_ConditionDescriptor	*waitCondition;
    struct Language_Execute_ProcessDescriptor	*nextTimeout;
    TLnat4	totalPause;
    struct Language_Execute_HandlerArea	*activeHandler;
    struct Language_Execute_HandlerArea	*runningHandler;
    Language_Step	stepSpec;
    TLaddressint	stepFP;
};
struct	Language_Execute_MonitorDescriptor {
    TLint2	entryParameter;
    TLint2	monitorPriority;
    struct Language_Execute_ProcessDescriptor	*entryHead;
    struct Language_Execute_ProcessDescriptor	*entryTail;
    TLaddressint	name;
    struct Language_Execute_ConditionDefinition	*firstCondition;
    struct Language_Execute_MonitorDescriptor	*nextMonitor;
    struct Language_Execute_MonitorDescriptor	*prevMonitor;
};
struct	Language_Execute_ConditionDescriptor {
    struct Language_Execute_ProcessDescriptor	*signalHead;
    struct Language_Execute_ProcessDescriptor	*signalTail;
    struct Language_Execute_MonitorDescriptor	*md;
};
typedef	struct Language_Execute_ConditionDescriptor	Language_Execute___x1942[65535];
struct	Language_Execute_ConditionDefinition {
    TLnat2	cdArraySize;
    Language_Execute___x1942	*cdArray;
    TLaddressint	name;
    struct Language_Execute_ConditionDefinition	*nextVariable;
};
struct Language_Execute_ProcessDescriptor	*Language_Execute_RQHead;
struct Language_Execute_ProcessDescriptor	*Language_Execute_EQHead;
TLnat4	Language_Execute_Chrono;
TLint4	Language_Execute_processCount;
TLaddressint	Language_Execute_globalPC;
TLaddressint	Language_Execute_globalSP;
typedef	Language_Opcode	Language_Execute___x1943[1];
Language_Execute___x1943	Language_Execute_nullRoutine = 
    {206};
TLaddressint	Language_Execute_savedInitPC;
TLaddressint	Language_Execute_savedInitFP;

void Language_Execute_UnitInitState (pc, fp)
TLaddressint	*pc;
TLaddressint	*fp;
{
    TLSTKCHKSLF(100385);
    TLSETF();
    TLSETL(100385);
    if ((unsigned long) Language_Execute_savedInitPC == 0) {
	TLSETL(100386);
	(*pc) = (TLaddressint) Language_Execute_globalPC;
	TLINCL();
	if (Language_Execute_RQHead == ((struct Language_Execute_ProcessDescriptor *) 0)) {
	    TLSETL(100388);
	    (*fp) = (TLaddressint) 0;
	} else {
	    TLSETL(100390);
	    (*fp) = (TLaddressint) (Language_Execute_RQHead->fp);
	};
    } else {
	TLSETL(100393);
	(*pc) = (TLaddressint) Language_Execute_savedInitPC;
	TLINCL();
	(*fp) = (TLaddressint) Language_Execute_savedInitFP;
    };
    TLRESTORELF();
}

void Language_Execute_DumpStack (pd)
register struct Language_Execute_ProcessDescriptor	*pd;
{
    TLaddressint	pc;
    register TLaddressint	fp;
    TLstring	routineName;
    struct SrcPosition	srcPos;
    struct Cookie	cookie;
    TLSTKCHKSLF(100404);
    TLSETF();
    TLSETL(100404);
    TLASSERT (pd != ((struct Language_Execute_ProcessDescriptor *) 0));
    TLINCL();
    pc = (TLaddressint) (pd->pc);
    TLINCL();
    fp = (TLaddressint) (pd->fp);
    TLSETL(100408);
    TLSTRCTASS(srcPos, Language_nullSrcPosition, struct SrcPosition);
    TLSETL(100413);
    Language_DebugModule_NewThread((TLaddressint) ((TLnat4) pd), (TLaddressint) (pd->name));
    TLINCL();
    Language_Compile_CallInfo((TLaddressint) pc, (TLaddressint) fp, routineName, &(cookie));
    TLSETL(100416);
    Language_DebugModule_NewCall(routineName, &(pd->srcPos), &(cookie));
    if (((cookie.kind) == 0) || ((unsigned long) fp == 0)) {
	TLSETL(100418);
	TLRESTORELF();
	return;
    };
    TLSETL(100421);
    for(;;) {
	TLSETL(100421);
	if ((unsigned long) ((* (TLaddressint *) fp)) == 0) {
	    break;
	};
	TLSETL(100422);
	srcPos.lineNo = (* (TLnat2 *) (((unsigned long) fp + 4) + 2));
	TLINCL();
	srcPos.fileNo = (* (TLnat2 *) ((unsigned long) fp + 4));
	TLINCL();
	pc = (TLaddressint) ((* (TLaddressint *) (((unsigned long) fp + 4) + (2 * 2))));
	TLINCL();
	fp = (TLaddressint) ((* (TLaddressint *) fp));
	TLSETL(100427);
	Language_Compile_CallInfo((TLaddressint) pc, (TLaddressint) fp, routineName, &(cookie));
	TLINCL();
	Language_DebugModule_NewCall(routineName, &(srcPos), &(cookie));
	if ((cookie.kind) == 0) {
	    TLSETL(100430);
	    TLRESTORELF();
	    return;
	};
    };
    TLSETL(100432);
    if (((* (TLnat2 *) (((unsigned long) fp + 4) + 2))) != 0) {
	TLSETL(100434);
	srcPos.lineNo = (* (TLnat2 *) (((unsigned long) fp + 4) + 2));
	TLINCL();
	srcPos.fileNo = (* (TLnat2 *) ((unsigned long) fp + 4));
	TLINCL();
	pc = (TLaddressint) ((* (TLaddressint *) (((unsigned long) fp + 4) + (2 * 2))));
	TLSETL(100438);
	Language_Compile_CallInfo((TLaddressint) pc, (TLaddressint) 0, routineName, &(cookie));
	TLINCL();
	Language_DebugModule_NewCall(routineName, &(srcPos), &(cookie));
    };
    TLRESTORELF();
}

extern TLboolean Language_Execute_Kernel_ConditionEmpty ();

extern TLnat4 Language_Execute_Kernel_GetProcessPriority ();

extern void Language_Execute_Kernel_Initialize ();

extern void Language_Execute_Kernel_InitializeCondition ();

extern void Language_Execute_Kernel_MonitorEnter ();

extern void Language_Execute_Kernel_MonitorExit ();

extern void Language_Execute_Kernel_MonitorFree ();

extern void Language_Execute_Kernel_MonitorInitialize ();

extern void Language_Execute_Kernel_Pause ();

extern void Language_Execute_Kernel_RunQueueDispatch ();

extern void Language_Execute_Kernel_RunQueueInsert ();

extern void Language_Execute_Kernel_SetProcessPriority ();

extern void Language_Execute_Kernel_SignalDeferredCondition ();

extern void Language_Execute_Kernel_SignalPriorityCondition ();

extern void Language_Execute_Kernel_SignalRegularCondition ();

extern void Language_Execute_Kernel_SignalTimeoutCondition ();

extern void Language_Execute_Kernel_TimeSlice ();

extern void Language_Execute_Kernel_WaitDeferredCondition ();

extern void Language_Execute_Kernel_WaitPriorityCondition ();

extern void Language_Execute_Kernel_WaitRegularCondition ();

extern void Language_Execute_Kernel_WaitTimeoutCondition ();

extern void Language_Execute_Kernel_DumpThreadList ();

void Language_Execute_DumpThreadList (firstThreadQueue)
struct ThreadQueueDef	**firstThreadQueue;
{
    TLSTKCHKSLF(100453);
    TLSETF();
    TLSETL(100453);
    Language_DebugModule_Initialize();
    TLINCL();
    Language_Execute_Kernel_DumpThreadList();
    TLINCL();
    Language_DebugModule_ReturnThreadDump(&((*firstThreadQueue)));
    TLRESTORELF();
}

void Language_Execute_RunSrcPosition (srcPos)
struct SrcPosition	*srcPos;
{
    TLSTKCHKSLF(100463);
    TLSETF();
    TLSETL(100463);
    if (Language_Execute_RQHead == ((struct Language_Execute_ProcessDescriptor *) 0)) {
	TLSETL(100464);
	TLSTRCTASS((*srcPos), Language_nullSrcPosition, struct SrcPosition);
    } else {
	TLSETL(100466);
	TLSTRCTASS((*srcPos), Language_Execute_RQHead->srcPos, struct SrcPosition);
    };
    TLRESTORELF();
}

void Language_Execute_SetErrno (errno, errMessage)
TLint4	errno;
TLaddressint	errMessage;
{
    TLBINDREG((*pd), struct Language_Execute_ProcessDescriptor);
    TLSTKCHKSLF(100475);
    TLSETF();
    TLSETL(100475);
    pd = &((*(Language_Execute_RQHead)));
    TLSETL(100477);
    (*pd).prevErrno = (*pd).errno;
    TLINCL();
    TLSTRASS(255, (*pd).prevErrMessage, (*pd).errMessage);
    TLINCL();
    (*pd).errno = errno;
    TLINCL();
    if ((unsigned long) errMessage == 0) {
	TLSETL(100481);
	TLSTRASS(255, (*pd).errMessage, "");
    } else {
	TLSETL(100483);
	TLSTRASS(255, (*pd).errMessage, (* (TLstring *) errMessage));
    };
    TLRESTORELF();
}

void Language_Execute_GetErrno (errno, prevErrno, errMessage, prevErrMessage)
TLint4	*errno;
TLint4	*prevErrno;
TLaddressint	*errMessage;
TLaddressint	*prevErrMessage;
{
    TLBINDREG((*pd), struct Language_Execute_ProcessDescriptor);
    TLSTKCHKSLF(100493);
    TLSETF();
    TLSETL(100493);
    pd = &((*(Language_Execute_RQHead)));
    TLINCL();
    (*errno) = (*pd).errno;
    TLINCL();
    (*errMessage) = (TLaddressint) ((unsigned long)(*pd).errMessage);
    TLINCL();
    (*prevErrno) = (*pd).prevErrno;
    TLINCL();
    (*prevErrMessage) = (TLaddressint) ((unsigned long)(*pd).prevErrMessage);
    TLRESTORELF();
}

TLboolean Language_Execute_HasEvent (stream, event)
TLint4	stream;
struct MIO_EventDescriptor	*event;
{
    TLint4	fileStream;
    TLSTKCHKSLF(100505);
    TLSETF();
    TLSETL(100505);
    fileStream = Language_Execute_fileMap[TLINRANGELOW(stream, -2, 20, 1)];
    TLINCL();
    if (fileStream == -3) {
	TLSETL(100508);
	TLRESTORELF();
	return (1);
    } else {
	TLSETL(100510);
	TLRESTORELF();
	return (MIO_HasEvent((TLaddressint) TL_TLI_TLIGF((TLint4) fileStream), &((*event))));
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

void Language_Execute_EventQueueInsert (stream, event)
TLint4	stream;
struct MIO_EventDescriptor	*event;
{
    register struct Language_Execute_ProcessDescriptor	*pd;
    TLSTKCHKSLF(100518);
    TLSETF();
    TLSETL(100518);
    pd = Language_Execute_RQHead;
    TLINCL();
    pd->pendingEvent.stream = stream;
    TLINCL();
    TLSTRCTASS(pd->pendingEvent.event, (*event), struct MIO_EventDescriptor);
    TLINCL();
    Language_Execute_RQHead = pd->nextProcess;
    TLINCL();
    pd->nextProcess = Language_Execute_EQHead;
    TLINCL();
    Language_Execute_EQHead = pd;
    TLSETL(100525);
    Language_Execute_Kernel_RunQueueDispatch();
    TLRESTORELF();
}

static void Language_Execute_EventQueueDispatch () {
    struct Language_Execute_ProcessDescriptor	*pd;
    struct Language_Execute_ProcessDescriptor	*lastPD;
    TLSTKCHKSLF(100529);
    TLSETF();
    TLSETL(100529);
    pd = Language_Execute_EQHead;
    TLINCL();
    lastPD = (struct Language_Execute_ProcessDescriptor *) 0;
    TLINCL();
    Language_Execute_allWaitingForKeyboard = 1;
    TLSETL(100533);
    for(;;) {
	TLSETL(100533);
	if (pd == ((struct Language_Execute_ProcessDescriptor *) 0)) {
	    break;
	};
	TLSETL(100534);
	if (Language_Execute_HasEvent((TLint4) (pd->pendingEvent.stream), &(pd->pendingEvent.event))) {
	    TLSETL(100536);
	    if (lastPD == ((struct Language_Execute_ProcessDescriptor *) 0)) {
		TLSETL(100537);
		Language_Execute_EQHead = pd->nextProcess;
		TLSETL(100539);
		Language_Execute_Kernel_RunQueueInsert(pd);
		pd = Language_Execute_EQHead;
	    } else {
		TLSETL(100541);
		lastPD->nextProcess = pd->nextProcess;
		TLSETL(100543);
		Language_Execute_Kernel_RunQueueInsert(pd);
		pd = lastPD->nextProcess;
	    };
	} else {
	    TLnat1	mode;
	    TLSETL(100546);
	    mode = pd->pendingEvent.event.mode;
	    TLSETL(100549);
	    if ((((mode != 0) && (mode != 1)) && (mode != 2)) && (mode != 3)) {
		TLSETL(100553);
		Language_Execute_allWaitingForKeyboard = 0;
	    };
	    TLSETL(100555);
	    lastPD = pd;
	    TLINCL();
	    pd = pd->nextProcess;
	};
    };
    TLRESTORELF();
}

TLboolean Language_Execute_Strintok (str, base)
TLstring	str;
TLint4	base;
{
    TLboolean	__x1649;
    struct TLHAREA	quitCode;
    TLSTKCHKSLF(100563);
    if (TLHANDENTER(quitCode)) {
	TLSETF();
	TLSETL(100563);
	{
	    __x1649 = 0;
	    TLRESTORELF();
	    return (__x1649);
	};
    } else {
	TLint4	dummy;
	TLSETF();
	TLSETL(100567);
	dummy = TL_TLS_TLSVSI(str, (TLint4) base);
	TLINCL();
	{
	    __x1649 = 1;
	    TL_TLE_TLEHX();
	    TLRESTORELF();
	    return (__x1649);
	};
	TL_TLE_TLEHX();
    }
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

TLboolean Language_Execute_Strnatok (str, base)
TLstring	str;
TLint4	base;
{
    TLboolean	__x1654;
    struct TLHAREA	quitCode;
    TLSTKCHKSLF(100574);
    if (TLHANDENTER(quitCode)) {
	TLSETF();
	TLSETL(100574);
	{
	    __x1654 = 0;
	    TLRESTORELF();
	    return (__x1654);
	};
    } else {
	TLnat4	dummy;
	TLSETF();
	TLSETL(100578);
	dummy = TL_TLS_TLSVSN(str, (TLint4) base);
	TLINCL();
	{
	    __x1654 = 1;
	    TL_TLE_TLEHX();
	    TLRESTORELF();
	    return (__x1654);
	};
	TL_TLE_TLEHX();
    }
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

void Language_Execute_Open () {
    Language_OpenKind	oKind;
    Language_StreamModeSet	oMode;
    TLSTKCHKSLF(100584);
    TLSETF();
    TLSETL(100584);
    TLASSERT (sizeof(Language_OpenKind) == 1);
    TLINCL();
    oKind = (* (Language_OpenKind *) Language_Execute_globalPC);
    TLINCL();
    Language_Execute_globalPC += Language_codeInt1Size;
    TLINCL();
    TLASSERT (sizeof(Language_StreamModeSet) == 1);
    TLINCL();
    oMode = (* (Language_StreamModeSet *) Language_Execute_globalPC);
    TLINCL();
    Language_Execute_globalPC += Language_codeInt1Size;
    TLSETL(100595);
    switch (oKind) {
	case 0:
	    {
		TLSETL(100599);
		TL_TLI_TLIOP (((* (TLstring *) ((* (TLaddressint *) Language_Execute_globalSP)))), ((* (TLstring *) ((* (TLaddressint *) ((unsigned long) Language_Execute_globalSP + 4))))), &((* (TLint4 *) ((* (TLaddressint *) ((unsigned long) Language_Execute_globalSP + (2 * 4)))))));
		TLSETL(100603);
		Language_Execute_AddFile(&((* (TLint4 *) ((* (TLaddressint *) ((unsigned long) Language_Execute_globalSP + (2 * 4)))))), (TLint4) 0);
		Language_Execute_globalSP += 12;
	    }
	    break;
	case 1:
	    {
		TLSETL(100610);
		Language_Execute_OpenFile((TLint2) (* (TLnat1 *) &oMode), (* (TLstring *) ((* (TLaddressint *) Language_Execute_globalSP))), &((* (TLint4 *) ((* (TLaddressint *) ((unsigned long) Language_Execute_globalSP + 4))))));
		TLINCL();
		Language_Execute_AddFile(&((* (TLint4 *) ((* (TLaddressint *) ((unsigned long) Language_Execute_globalSP + 4))))), (TLint4) (* (TLnat1 *) &oMode));
		Language_Execute_globalSP += 8;
	    }
	    break;
	case 2:
	    {
		TLSETL(100615);
		TL_TLI_TLIXSN = (* (TLint4 *) Language_Execute_globalSP);
		TLINCL();
		if ((TL_TLI_TLIXSN <= 0) || (TL_TLI_TLIXSN > Language_Execute_numArguments)) {
		    TLSETL(100620);
		    {
			TLstring	__x1973;
			TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x1973);
			{
			    TLstring	__x1972;
			    TL_TLS_TLSCAT("Open argument ", __x1973, __x1972);
			    {
				TLstring	__x1971;
				TL_TLS_TLSCAT(__x1972, " does not exist", __x1971);
				Language_Execute_ExecutionError_Abort((TLint4) 10000, __x1971);
			    };
			};
		    };
		};
		TLSETL(100621);
		if ((Language_Execute_fileMap[TLINRANGELOW(TL_TLI_TLIXSN, -2, 20, 1)]) != -3) {
		    TLSETL(100624);
		    {
			TLstring	__x1976;
			TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x1976);
			{
			    TLstring	__x1975;
			    TL_TLS_TLSCAT("Open argument ", __x1976, __x1975);
			    {
				TLstring	__x1974;
				TL_TLS_TLSCAT(__x1975, " is already open", __x1974);
				Language_Execute_ExecutionError_Abort((TLint4) 10000, __x1974);
			    };
			};
		    };
		};
		TLSETL(100626);
		Language_Execute_OpenArgumentFile((Language_StreamModeSet) oMode, (TLboolean) 0);
		(* (TLint4 *) ((* (TLaddressint *) ((unsigned long) Language_Execute_globalSP + 4)))) = TL_TLI_TLIXSN;
		TLINCL();
		Language_Execute_globalSP += 8;
	    }
	    break;
	default:
	    TLCASEABORT;
    };
    TLRESTORELF();
}

void Language_Execute_Put () {
    Language_PutKind	pKind;
    TLint4	stream;
    TLSTKCHKSLF(100633);
    TLSETF();
    TLSETL(100633);
    TLASSERT (sizeof(Language_PutKind) == 1);
    TLINCL();
    pKind = (* (Language_PutKind *) Language_Execute_globalPC);
    TLINCL();
    Language_Execute_globalPC += Language_codeInt1Size;
    TLSETL(100637);
    TL_TLI_TLIXSN = (* (TLint4 *) ((* (TLaddressint *) Language_Execute_globalSP)));
    TLINCL();
    Language_Execute_globalSP += 4;
    TLINCL();
    stream = Language_Execute_fileMap[TLINRANGELOW(TL_TLI_TLIXSN, -2, 20, 1)];
    TLINCL();
    if (stream == -3) {
	TLSETL(100644);
	{
	    TLstring	__x1983;
	    TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x1983);
	    {
		TLstring	__x1982;
		TL_TLS_TLSCAT("I/O attempted on closed stream ", __x1983, __x1982);
		Language_Execute_ExecutionError_Abort((TLint4) 10000, __x1982);
	    };
	};
    };
    TLSETL(100646);
    switch (pKind) {
	case 0:
	    {
		TLSETL(100648);
		if (((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4))) != 0) {
		    TLSETL(100649);
		    TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		    TL_TLI_TLIPS ((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), "true", (TLint2) stream);
		} else {
		    TLSETL(100651);
		    TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		    TL_TLI_TLIPS ((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), "false", (TLint2) stream);
		};
		TLSETL(100653);
		Language_Execute_globalSP += 8;
	    }
	    break;
	case 1:
	    {
		TLSETL(100656);
		{
		    TLchar	__x1988[1];
		    TLCHRTOCHARS(((TLchar) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4)))), __x1988);
		    TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		    TL_TLI_TLIPC ((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), __x1988, (TLint4) 1, (TLint2) stream);
		};
		TLINCL();
		Language_Execute_globalSP += 8;
	    }
	    break;
	case 2:
	    {
		TLSETL(100666);
		TL_TLI_TLISS((TLint4) stream, (TLint2) 2);
		TLSETL(100669);
		TL_TLI_TLIPC((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), (TLaddressint) ((* (TLaddressint *) ((unsigned long) Language_Execute_globalSP + (2 * 4)))), (TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4))), (TLint2) stream);
		Language_Execute_globalSP += 12;
	    }
	    break;
	case 3:
	    {
		TLint4	value;
		register TLaddressint	ptr;
		TLSETL(100673);
		value = (* (TLint4 *) (((unsigned long) Language_Execute_globalSP + 4) + 4));
		TLINCL();
		ptr = (TLaddressint) ((* (TLaddressint *) Language_Execute_globalSP));
		TLINCL();
		if ((value >= 0) && (value < ((* (TLint4 *) ptr)))) {
		    TLSETL(100676);
		    ptr += 4;
		    TLINCL();
		    {
			register TLint4	__x1663;
			TLint4	__x1996;
			__x1996 = value;
			__x1663 = 1;
			if (__x1663 <= __x1996) {
			    for(;;) {
				TLSETL(100679);
				for(;;) {
				    TLSETL(100679);
				    ptr += 1;
				    TLINCL();
				    if (((* (TLchar *) ptr)) == '\0') {
					break;
				    };
				};
				TLSETL(100683);
				for(;;) {
				    TLSETL(100683);
				    ptr += 1;
				    TLINCL();
				    if (((* (TLchar *) ptr)) != '\0') {
					break;
				    };
				};
				if (__x1663 == __x1996) break;
				__x1663++;
			    }
			};
		    };
		    TLSETL(100687);
		    TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		    TL_TLI_TLIPS ((TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4))), ((* (TLstring *) ptr)), (TLint2) stream);
		} else {
		    TLSETL(100689);
		    TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		    TL_TLI_TLIPI ((TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4))), (TLint4) value, (TLint2) stream);
		};
		TLSETL(100691);
		Language_Execute_globalSP += 12;
	    }
	    break;
	case 4:
	    {
		TLSETL(100694);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		TL_TLI_TLIPI ((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), (TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4))), (TLint2) stream);
		TLINCL();
		Language_Execute_globalSP += 8;
	    }
	    break;
	case 5:
	    {
		TLSETL(100698);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		TL_TLI_TLIPF ((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), (TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4))), ((TLreal8) (TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + (2 * 4))))), (TLint2) stream);
		TLSETL(100700);
		Language_Execute_globalSP += 12;
	    }
	    break;
	case 6:
	    {
		TLSETL(100703);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		TL_TLI_TLIPE ((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), (TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4))), (TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + (2 * 4)))), ((TLreal8) (TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + (3 * 4))))), (TLint2) stream);
		TLSETL(100706);
		Language_Execute_globalSP += 16;
	    }
	    break;
	case 7:
	    {
		TLSETL(100709);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		TL_TLI_TLIPN ((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), (TLnat4) ((* (TLnat4 *) ((unsigned long) Language_Execute_globalSP + 4))), (TLint2) stream);
		TLINCL();
		Language_Execute_globalSP += 8;
	    }
	    break;
	case 8:
	    {
		TLSETL(100713);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		TL_TLI_TLIPN ((TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4))), (TLnat4) ((* (TLnat4 *) ((unsigned long) Language_Execute_globalSP + (2 * 4)))), (TLint2) stream);
		TLSETL(100715);
		Language_Execute_globalSP += 12;
	    }
	    break;
	case 9:
	    {
		TLSETL(100718);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		TL_TLI_TLIPN ((TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + (2 * 4)))), (TLnat4) ((* (TLnat4 *) ((unsigned long) Language_Execute_globalSP + (3 * 4)))), (TLint2) stream);
		TLSETL(100721);
		Language_Execute_globalSP += 16;
	    }
	    break;
	case 10:
	    {
		TLSETL(100724);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		TL_TLI_TLIPR ((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), (TLreal8) ((* (TLreal8 *) ((unsigned long) Language_Execute_globalSP + 4))), (TLint2) stream);
		TLINCL();
		Language_Execute_globalSP += 12;
	    }
	    break;
	case 11:
	    {
		TLSETL(100728);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		TL_TLI_TLIPF ((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), (TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4))), (TLreal8) ((* (TLreal8 *) ((unsigned long) Language_Execute_globalSP + (2 * 4)))), (TLint2) stream);
		TLSETL(100730);
		Language_Execute_globalSP += 16;
	    }
	    break;
	case 12:
	    {
		TLSETL(100733);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		TL_TLI_TLIPE ((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), (TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4))), (TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + (2 * 4)))), (TLreal8) ((* (TLreal8 *) ((unsigned long) Language_Execute_globalSP + (3 * 4)))), (TLint2) stream);
		TLSETL(100736);
		Language_Execute_globalSP += 20;
	    }
	    break;
	case 13:
	    {
		TLSETL(100739);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		TL_TLI_TLIPS ((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), ((* (TLstring *) ((* (TLaddressint *) ((unsigned long) Language_Execute_globalSP + 4))))), (TLint2) stream);
		TLSETL(100741);
		Language_Execute_globalSP += 8;
	    }
	    break;
	case 14:
	    {
		TLSETL(100744);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		TL_TLI_TLIPS ((TLint4) 0, "", (TLint2) stream);
		TL_TLI_TLIPK ((TLint2) stream);
	    }
	    break;
	default:
	    TLCASEABORT;
    };
    TLSETL(100747);
    Language_Execute_executionTimeout -= 500;
    TLRESTORELF();
}

void Language_Execute_Get () {
    TLaddressint	startPC;
    TLaddressint	startSP;
    Language_GetKind	gKind;
    Language_Offset	sz;
    TLint4	stream;
    struct MIO_EventDescriptor	event;
    TLSTKCHKSLF(100752);
    TLSETF();
    TLSETL(100752);
    startPC = (TLaddressint) ((unsigned long) Language_Execute_globalPC - Language_codeOprSize);
    TLINCL();
    startSP = (TLaddressint) Language_Execute_globalSP;
    TLSETL(100755);
    TLASSERT (sizeof(Language_GetKind) == 1);
    TLINCL();
    gKind = (* (Language_GetKind *) Language_Execute_globalPC);
    TLINCL();
    Language_Execute_globalPC += Language_codeInt1Size;
    TLSETL(100760);
    if (gKind == 13) {
	TLSETL(100761);
	sz = 0;
    } else {
	TLSETL(100763);
	TLASSERT (((unsigned long) Language_Execute_globalPC & (3)) == 0);
	TLINCL();
	sz = (* (Language_Offset *) Language_Execute_globalPC);
	TLINCL();
	Language_Execute_globalPC += Language_codeOffsetSize;
    };
    TLSETL(100768);
    TL_TLI_TLIXSN = (* (TLint4 *) ((* (TLaddressint *) Language_Execute_globalSP)));
    TLINCL();
    Language_Execute_globalSP += 4;
    TLINCL();
    stream = Language_Execute_fileMap[TLINRANGELOW(TL_TLI_TLIXSN, -2, 20, 1)];
    TLINCL();
    if (stream == -3) {
	TLSETL(100775);
	{
	    TLstring	__x2037;
	    TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x2037);
	    {
		TLstring	__x2036;
		TL_TLS_TLSCAT("I/O attempted on closed stream ", __x2037, __x2036);
		Language_Execute_ExecutionError_Abort((TLint4) 10000, __x2036);
	    };
	};
    };
    TLSETL(100778);
    switch (gKind) {
	case 1:
	case 2:
	    {
		TLSETL(100780);
		event.mode = 2;
		TLINCL();
		event.count = 1;
	    }
	    break;
	case 3:
	    {
		TLint4	width;
		TLSETL(100783);
		width = (* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4));
		TLINCL();
		if (width < 0) {
		    TLSETL(100787);
		    {
			TLstring	__x2041;
			TL_TLS_TLSVIS((TLint4) width, (TLint4) 1, (TLint4) 10, __x2041);
			{
			    TLstring	__x2040;
			    TL_TLS_TLSCAT("Negative get width of ", __x2041, __x2040);
			    {
				TLstring	__x2039;
				TL_TLS_TLSCAT(__x2040, " specified", __x2039);
				Language_Execute_ExecutionError_Abort((TLint4) 10000, __x2039);
			    };
			};
		    };
		};
		TLSETL(100788);
		if (width > ((* (TLint4 *) Language_Execute_globalSP))) {
		    TLSETL(100793);
		    {
			TLstring	__x2048;
			TL_TLS_TLSVIS((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), (TLint4) 1, (TLint4) 10, __x2048);
			{
			    TLstring	__x2046;
			    TL_TLS_TLSVIS((TLint4) width, (TLint4) 1, (TLint4) 10, __x2046);
			    {
				TLstring	__x2045;
				TL_TLS_TLSCAT("Get width of ", __x2046, __x2045);
				{
				    TLstring	__x2044;
				    TL_TLS_TLSCAT(__x2045, " is longer than char string variable size of ", __x2044);
				    {
					TLstring	__x2043;
					TL_TLS_TLSCAT(__x2044, __x2048, __x2043);
					Language_Execute_ExecutionError_Abort((TLint4) 10000, __x2043);
				    };
				};
			    };
			};
		    };
		};
		TLSETL(100794);
		event.mode = 2;
		TLINCL();
		event.count = width;
	    }
	    break;
	case 11:
	    {
		TLSETL(100797);
		event.mode = 1;
		TLINCL();
		event.count = 0;
	    }
	    break;
	case 10:
	    {
		TLint4	width;
		TLSETL(100800);
		width = (* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4));
		TLINCL();
		if (width < 0) {
		    TLSETL(100804);
		    {
			TLstring	__x2052;
			TL_TLS_TLSVIS((TLint4) width, (TLint4) 1, (TLint4) 10, __x2052);
			{
			    TLstring	__x2051;
			    TL_TLS_TLSCAT("Negative get width of ", __x2052, __x2051);
			    {
				TLstring	__x2050;
				TL_TLS_TLSCAT(__x2051, " specified", __x2050);
				Language_Execute_ExecutionError_Abort((TLint4) 10000, __x2050);
			    };
			};
		    };
		};
		TLSETL(100805);
		if (width > ((* (TLint4 *) Language_Execute_globalSP))) {
		    TLSETL(100810);
		    {
			TLstring	__x2059;
			TL_TLS_TLSVIS((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), (TLint4) 1, (TLint4) 10, __x2059);
			{
			    TLstring	__x2057;
			    TL_TLS_TLSVIS((TLint4) width, (TLint4) 1, (TLint4) 10, __x2057);
			    {
				TLstring	__x2056;
				TL_TLS_TLSCAT("Get width of ", __x2057, __x2056);
				{
				    TLstring	__x2055;
				    TL_TLS_TLSCAT(__x2056, " is longer than string variable size of ", __x2055);
				    {
					TLstring	__x2054;
					TL_TLS_TLSCAT(__x2055, __x2059, __x2054);
					Language_Execute_ExecutionError_Abort((TLint4) 10000, __x2054);
				    };
				};
			    };
			};
		    };
		};
		TLSETL(100811);
		event.mode = 1;
		TLINCL();
		event.count = 0;
	    }
	    break;
	default :
	    {
		TLSETL(100814);
		event.mode = 0;
		TLINCL();
		event.count = 0;
	    }
	    break;
    };
    TLSETL(100818);
    if (!Language_Execute_HasEvent((TLint4) TL_TLI_TLIXSN, &(event))) {
	TLSETL(100819);
	Language_Execute_globalPC = (TLaddressint) startPC;
	TLINCL();
	Language_Execute_globalSP = (TLaddressint) startSP;
	TLSETL(100822);
	Language_Execute_EventQueueInsert((TLint4) TL_TLI_TLIXSN, &(event));
	TLINCL();
	TLRESTORELF();
	return;
    };
    TLSETL(100825);
    switch (gKind) {
	case 0:
	    {
		TLstring	tstring;
		TLSETL(100828);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
		TL_TLI_TLIGS ((TLint4) 255, tstring, (TLint2) stream);
		TLINCL();
		if (strcmp(tstring, "true") == 0) {
		    TLSETL(100830);
		    (* (TLboolean *) ((* (TLaddressint *) Language_Execute_globalSP))) = 1;
		} else {
		    TLSETL(100831);
		    if (strcmp(tstring, "false") == 0) {
			TLSETL(100832);
			(* (TLboolean *) ((* (TLaddressint *) Language_Execute_globalSP))) = 0;
		    } else {
			TLSETL(100836);
			{
			    TLstring	__x2065;
			    TL_TLS_TLSCAT("Value of \'", tstring, __x2065);
			    {
				TLstring	__x2064;
				TL_TLS_TLSCAT(__x2065, "\' is invalid for boolean input", __x2064);
				Language_Execute_ExecutionError_Abort((TLint4) 10000, __x2064);
			    };
			};
		    };
		};
	    }
	    break;
	case 1:
	    {
		TLSETL(100839);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
		TL_TLI_TLIGC ((TLint4) sizeof ((* (TLchar *) ((* (TLaddressint *) Language_Execute_globalSP)))), &((* (TLchar *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint4) sizeof ((* (TLchar *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint2) stream);
		TLINCL();
		Language_Execute_globalSP += 4;
	    }
	    break;
	case 3:
	    {
		TLSETL(100849);
		TL_TLI_TLISS((TLint4) stream, (TLint2) 1);
		TLSETL(100852);
		TL_TLI_TLIGC((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), (TLaddressint) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4))), (TLint4) ((* (TLaddressint *) ((unsigned long) Language_Execute_globalSP + (2 * 4)))), (TLint2) stream);
		Language_Execute_globalSP += 12;
	    }
	    break;
	case 2:
	    {
		TLchar	c;
		TLSETL(100856);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
		TL_TLI_TLIGC ((TLint4) sizeof c, &c, (TLint4) sizeof c, (TLint2) stream);
		TLINCL();
		TLASSERT (((unsigned long) Language_Execute_globalPC & (3)) == 0);
		TLINCL();
		if (((* (TLnat1 *) &c) < ((* (TLint4 *) Language_Execute_globalPC))) || ((* (TLnat1 *) &c) > ((* (TLint4 *) ((unsigned long) Language_Execute_globalPC + Language_codeIntSize))))) {
		    TLSETL(100860);
		    Language_Execute_ExecutionError_Abort((TLint4) 10000, "Input value is out of range");
		};
		TLSETL(100861);
		Language_Execute_globalPC += 2 * Language_codeIntSize;
		TLINCL();
		(* (TLchar *) ((* (TLaddressint *) Language_Execute_globalSP))) = c;
		TLINCL();
		Language_Execute_globalSP += 4;
	    }
	    break;
	case 4:
	    {
		TLstring	tstring;
		register TLaddressint	ptr;
		TLint4	count;
		TLSETL(100867);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
		TL_TLI_TLIGS ((TLint4) 255, tstring, (TLint2) stream);
		TLSETL(100869);
		ptr = (TLaddressint) ((* (TLaddressint *) Language_Execute_globalSP));
		TLINCL();
		Language_Execute_globalSP += 4;
		TLSETL(100872);
		count = (* (TLint4 *) ptr);
		TLINCL();
		ptr += 4;
		TLSETL(100875);
		{
		    register TLint4	i;
		    TLint4	__x2077;
		    __x2077 = count - 1;
		    i = 0;
		    if (i <= __x2077) {
			for(;;) {
			    TLSETL(100877);
			    for(;;) {
				TLSETL(100877);
				if (((* (TLchar *) ptr)) != '\0') {
				    break;
				};
				TLSETL(100878);
				ptr += 1;
			    };
			    TLSETL(100880);
			    if (strcmp(tstring, (* (TLstring *) ptr)) == 0) {
				TLSETL(100881);
				switch (sz) {
				    case 1:
					{
					    TLSETL(100883);
					    (* (TLint1 *) ((* (TLaddressint *) Language_Execute_globalSP))) = i;
					}
					break;
				    case 2:
					{
					    TLSETL(100885);
					    (* (TLint2 *) ((* (TLaddressint *) Language_Execute_globalSP))) = i;
					}
					break;
				    case 4:
					{
					    TLSETL(100887);
					    (* (TLint4 *) ((* (TLaddressint *) Language_Execute_globalSP))) = i;
					}
					break;
				    default:
					TLCASEABORT;
				};
				TLSETL(100890);
				break;
			    };
			    TLSETL(100892);
			    for(;;) {
				TLSETL(100892);
				ptr += 1;
				TLINCL();
				if (((* (TLchar *) ptr)) == '\0') {
				    break;
				};
			    };
			    if (i == __x2077) break;
			    i++;
			}
		    };
		};
		TLSETL(100896);
		if (((* (TLchar *) ptr)) == '\0') {
		    TLSETL(100899);
		    {
			TLstring	__x2089;
			TL_TLS_TLSCAT("Value of \'", tstring, __x2089);
			{
			    TLstring	__x2088;
			    TL_TLS_TLSCAT(__x2089, "\' is not a valid enum member", __x2088);
			    Language_Execute_ExecutionError_Abort((TLint4) 10000, __x2088);
			};
		    };
		};
		TLSETL(100900);
		Language_Execute_globalSP += 4;
	    }
	    break;
	case 6:
	    {
		TLSETL(100903);
		switch (sz) {
		    case 1:
			{
			    TLSETL(100905);
			    TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
			    TL_TLI_TLIGI (&((* (TLint1 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint4) sizeof ((* (TLint1 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint2) stream);
			}
			break;
		    case 2:
			{
			    TLSETL(100907);
			    TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
			    TL_TLI_TLIGI (&((* (TLint2 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint4) sizeof ((* (TLint2 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint2) stream);
			}
			break;
		    case 4:
			{
			    TLSETL(100909);
			    TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
			    TL_TLI_TLIGI (&((* (TLint4 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint4) sizeof ((* (TLint4 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint2) stream);
			}
			break;
		    default:
			TLCASEABORT;
		};
		TLSETL(100911);
		Language_Execute_globalSP += 4;
	    }
	    break;
	case 8:
	    {
		TLSETL(100914);
		switch (sz) {
		    case 1:
			{
			    TLSETL(100916);
			    TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
			    TL_TLI_TLIGN (&((* (TLnat1 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint4) sizeof ((* (TLnat1 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint2) stream);
			}
			break;
		    case 2:
			{
			    TLSETL(100918);
			    TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
			    TL_TLI_TLIGN (&((* (TLnat2 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint4) sizeof ((* (TLnat2 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint2) stream);
			}
			break;
		    case 4:
			{
			    TLSETL(100920);
			    TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
			    TL_TLI_TLIGN (&((* (TLnat4 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint4) sizeof ((* (TLnat4 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint2) stream);
			}
			break;
		    default:
			TLCASEABORT;
		};
		TLSETL(100922);
		Language_Execute_globalSP += 4;
	    }
	    break;
	case 9:
	    {
		TLSETL(100925);
		if (sz == 8) {
		    TLSETL(100926);
		    TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
		    TL_TLI_TLIGR (&((* (TLreal8 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint4) sizeof ((* (TLreal8 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint2) stream);
		} else {
		    TLSETL(100928);
		    TLASSERT (sz == 4);
		    TLINCL();
		    TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
		    TL_TLI_TLIGR (&((* (TLreal4 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint4) sizeof ((* (TLreal4 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint2) stream);
		};
		TLSETL(100931);
		Language_Execute_globalSP += 4;
	    }
	    break;
	case 13:
	    {
		TLSETL(100934);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
		TL_TLI_TLIGK ((TLint2) stream);
	    }
	    break;
	case 11:
	    {
		TLstring	tstring;
		TLSETL(100938);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
		TL_TLI_TLIGSS((TLint4) 255, tstring, (TLint2) stream);
		TLINCL();
		if (TL_TLS_TLSLEN(tstring) > ((* (TLint4 *) Language_Execute_globalSP))) {
		    TLSETL(100942);
		    Language_Execute_ExecutionError_Abort((TLint4) 10000, "Input string is too large for string variable");
		};
		TLSETL(100943);
		Language_Execute_globalSP += 4;
		TLINCL();
		(* (TLint1 *) ((* (TLaddressint *) Language_Execute_globalSP))) = 0;
		TLSETL(100946);
		strcpy((* (TLstring *) ((* (TLaddressint *) Language_Execute_globalSP))), tstring);
		Language_Execute_globalSP += 4;
	    }
	    break;
	case 10:
	    {
		register TLint4	width;
		TLSETL(100949);
		width = (* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4));
		TLINCL();
		Language_Execute_globalSP += 8;
		TLINCL();
		(* (TLint1 *) ((* (TLaddressint *) Language_Execute_globalSP))) = 0;
		TLINCL();
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
		TL_TLI_TLIGSW ((TLint4) 255, (TLint4) width, (* (TLstring *) ((* (TLaddressint *) Language_Execute_globalSP))), (TLint2) stream);
		TLINCL();
		Language_Execute_globalSP += 4;
	    }
	    break;
	case 12:
	    {
		TLstring	tstring;
		TLSETL(100957);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
		TL_TLI_TLIGS ((TLint4) 255, tstring, (TLint2) stream);
		TLINCL();
		if (TL_TLS_TLSLEN(tstring) > ((* (TLint4 *) Language_Execute_globalSP))) {
		    TLSETL(100961);
		    Language_Execute_ExecutionError_Abort((TLint4) 10000, "Input string is too large for string variable");
		};
		TLSETL(100962);
		Language_Execute_globalSP += 4;
		TLINCL();
		(* (TLint1 *) ((* (TLaddressint *) Language_Execute_globalSP))) = 0;
		TLSETL(100965);
		strcpy((* (TLstring *) ((* (TLaddressint *) Language_Execute_globalSP))), tstring);
		Language_Execute_globalSP += 4;
	    }
	    break;
	case 7:
	    {
		TLint4	i;
		TLSETL(100969);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
		TL_TLI_TLIGI (&i, (TLint4) sizeof i, (TLint2) stream);
		TLINCL();
		TLASSERT (((unsigned long) Language_Execute_globalPC & (3)) == 0);
		TLINCL();
		if ((i < ((* (TLint4 *) Language_Execute_globalPC))) || (i > ((* (TLint4 *) ((unsigned long) Language_Execute_globalPC + Language_codeIntSize))))) {
		    TLSETL(100974);
		    Language_Execute_ExecutionError_Abort((TLint4) 10000, "Input value is out of range");
		};
		TLSETL(100975);
		Language_Execute_globalPC += 2 * Language_codeIntSize;
		TLINCL();
		switch (sz) {
		    case 1:
			{
			    TLSETL(100978);
			    (* (TLint1 *) ((* (TLaddressint *) Language_Execute_globalSP))) = i;
			}
			break;
		    case 2:
			{
			    TLSETL(100980);
			    (* (TLint2 *) ((* (TLaddressint *) Language_Execute_globalSP))) = i;
			}
			break;
		    case 4:
			{
			    TLSETL(100982);
			    (* (TLint4 *) ((* (TLaddressint *) Language_Execute_globalSP))) = i;
			}
			break;
		    default:
			TLCASEABORT;
		};
		TLSETL(100984);
		Language_Execute_globalSP += 4;
	    }
	    break;
	default:
	    TLCASEABORT;
    };
    TLRESTORELF();
}

void Language_Execute_DispatchHandler (quitCode)
TLint4	quitCode;
{
    TLBINDREG((*pd), struct Language_Execute_ProcessDescriptor);
    register struct Language_Execute_HandlerArea	*ha;
    TLSTKCHKSLF(100990);
    TLSETF();
    TLSETL(100990);
    pd = &((*(Language_Execute_RQHead)));
    TLSETL(100992);
    ha = (*pd).activeHandler;
    TLINCL();
    (*pd).runningHandler = ha;
    TLSETL(100995);
    if (ha != ((struct Language_Execute_HandlerArea *) 0)) {
	TLSETL(100999);
	TLSTRCTASS(ha->srcPos, (*pd).srcPos, struct SrcPosition);
	TLINCL();
	ha->quitCode = quitCode;
	TLSETL(101003);
	(*pd).activeHandler = ha->nextHandler;
	TLSETL(101006);
	Language_Execute_globalPC = (TLaddressint) (ha->handlerRoutine);
	TLINCL();
	Language_Execute_globalSP = (TLaddressint) (ha->savedRegisters.sp);
	TLINCL();
	(*pd).fp = (TLaddressint) (ha->savedRegisters.fp);
    } else {
	TLstring	message;
	TLSETL(101013);
	TLSTRASS(255, message, "");
	TLSETL(101015);
	if ((unsigned long) ((*pd).name) != 0) {
	    TLSETL(101016);
	    {
		TLstring	__x2130;
		TL_TLS_TLSCAT("Process \"", (* (TLstring *) ((*pd).name)), __x2130);
		{
		    TLstring	__x2129;
		    TL_TLS_TLSCAT(__x2130, "\": ", __x2129);
		    TLSTRASS(255, message, __x2129);
		};
	    };
	};
	TLSETL(101018);
	if ((((*pd).abort.quitCode) != 0) && (quitCode == ((*pd).abort.quitCode))) {
	    TLSETL(101020);
	    TLSTRCATASS(message, (*pd).abort.errorMsg, 255);
	} else {
	    TLSETL(101023);
	    {
		TLstring	__x2133;
		TL_TLS_TLSVIS((TLint4) quitCode, (TLint4) 1, (TLint4) 10, __x2133);
		{
		    TLstring	__x2132;
		    TL_TLS_TLSCAT("Quit #", __x2133, __x2132);
		    TLSTRCATASS(message, __x2132, 255);
		};
	    };
	};
	TLSETL(101028);
	Language_ErrorModule_Message(&((*pd).srcPos), (Language_ErrorModule_Severity) 3, message);
    };
    TLRESTORELF();
}

extern void TLEABT ();

void Language_Execute_ExtraRoutines (op)
Language_Opcode	op;
{
    TLSTKCHKSLF(101045);
    TLSETF();
    TLSETL(101045);
    switch (op) {
	case 77:
	    {
		TLint4	stream;
		struct MIO_EventDescriptor	event;
		TLSETL(101049);
		TL_TLI_TLIXSN = (* (TLint4 *) ((* (TLaddressint *) Language_Execute_globalSP)));
		TLINCL();
		stream = Language_Execute_fileMap[TLINRANGELOW(TL_TLI_TLIXSN, -2, 20, 1)];
		TLINCL();
		if (stream == -3) {
		    TLSETL(101056);
		    {
			TLstring	__x2137;
			TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x2137);
			{
			    TLstring	__x2136;
			    TL_TLS_TLSCAT("I/O attempted on closed stream ", __x2137, __x2136);
			    Language_Execute_ExecutionError_Abort((TLint4) 10000, __x2136);
			};
		    };
		};
		TLSETL(101058);
		event.mode = 2;
		TLINCL();
		event.count = 1;
		TLINCL();
		if (Language_Execute_HasEvent((TLint4) TL_TLI_TLIXSN, &(event))) {
		    TLSETL(101061);
		    Language_Execute_globalSP -= 0;
		    TLINCL();
		    if (TL_TLI_TLIEOF((TLint4) stream)) {
			TLSETL(101063);
			(* (TLnat4 *) Language_Execute_globalSP) = 1;
		    } else {
			TLSETL(101065);
			(* (TLnat4 *) Language_Execute_globalSP) = 0;
		    };
		} else {
		    TLSETL(101068);
		    Language_Execute_globalPC -= Language_codeOprSize;
		    TLSETL(101070);
		    Language_Execute_EventQueueInsert((TLint4) TL_TLI_TLIXSN, &(event));
		};
	    }
	    break;
	case 120:
	    {
		TLSETL(101075);
		Language_Execute_Get();
	    }
	    break;
	case 181:
	    {
		TLSETL(101078);
		Language_Execute_Open();
	    }
	    break;
	case 196:
	    {
		TLSETL(101081);
		Language_Execute_Put();
	    }
	    break;
	case 198:
	    {
		TLaddressint	startPC;
		TLaddressint	startSP;
		register TLaddressint	statusAddr;
		TLint4	stream;
		register TLaddressint	resultAddr;
		struct MIO_EventDescriptor	event;
		TLSETL(101086);
		startPC = (TLaddressint) ((unsigned long) Language_Execute_globalPC - Language_codeOprSize);
		TLINCL();
		startSP = (TLaddressint) Language_Execute_globalSP;
		TLSETL(101089);
		statusAddr = (TLaddressint) ((* (TLaddressint *) ((* (TLaddressint *) Language_Execute_globalSP))));
		TLSETL(101091);
		Language_Execute_globalSP += 4;
		TLSETL(101093);
		TL_TLI_TLIXSN = (* (TLint4 *) ((* (TLaddressint *) Language_Execute_globalSP)));
		TLINCL();
		Language_Execute_globalSP += 4;
		TLINCL();
		stream = Language_Execute_fileMap[TLINRANGELOW(TL_TLI_TLIXSN, -2, 20, 1)];
		TLINCL();
		if (stream == -3) {
		    TLSETL(101101);
		    {
			TLstring	__x2145;
			TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x2145);
			{
			    TLstring	__x2144;
			    TL_TLS_TLSCAT("I/O attempted on closed stream ", __x2145, __x2144);
			    Language_Execute_ExecutionError_Abort((TLint4) 10000, __x2144);
			};
		    };
		};
		TLSETL(101103);
		resultAddr = (TLaddressint) ((* (TLaddressint *) Language_Execute_globalSP));
		TLINCL();
		Language_Execute_globalSP += 4;
		TLSETL(101112);
		event.mode = 1;
		TLINCL();
		event.count = 0;
		TLSETL(101115);
		if (Language_Execute_HasEvent((TLint4) TL_TLI_TLIXSN, &(event))) {
		    TLint4	status;
		    TLint4	sizeRead;
		    TLSETL(101119);
		    TL_TLI_TLISSS (&status, (TLint4) stream, (TLint2) 3);
		    TL_TLI_TLIRER (&sizeRead, &((* (TLint4 *) ((* (TLaddressint *) ((unsigned long) Language_Execute_globalSP + 4))))), (TLint4) ((* (TLint4 *) Language_Execute_globalSP)), &status, (TLint2) stream);
		    TLSETL(101122);
		    if ((unsigned long) statusAddr != 0) {
			TLSETL(101123);
			(* (TLint4 *) statusAddr) = status;
		    };
		    TLSETL(101125);
		    if ((unsigned long) resultAddr != 0) {
			TLSETL(101126);
			(* (TLint4 *) resultAddr) = sizeRead;
		    };
		    TLSETL(101128);
		    Language_Execute_globalSP += 8;
		} else {
		    TLSETL(101130);
		    Language_Execute_globalPC = (TLaddressint) startPC;
		    TLINCL();
		    Language_Execute_globalSP = (TLaddressint) startSP;
		    TLSETL(101133);
		    Language_Execute_EventQueueInsert((TLint4) TL_TLI_TLIXSN, &(event));
		};
	    }
	    break;
	case 216:
	    {
		Language_SetStreamKind	streamMode;
		TLSETL(101139);
		streamMode = (* (Language_SetStreamKind *) Language_Execute_globalPC);
		TLINCL();
		Language_Execute_globalPC += Language_codeInt1Size;
		TLSETL(101142);
		if ((Language_Execute_RQHead->activeStream) == 0) {
		    TLSETL(101143);
		    if (streamMode == 1) {
			TLSETL(101144);
			(* (TLint4 *) ((* (TLaddressint *) Language_Execute_globalSP))) = -2;
		    } else {
			TLSETL(101146);
			TLASSERT (streamMode == 2);
			TLINCL();
			(* (TLint4 *) ((* (TLaddressint *) Language_Execute_globalSP))) = -1;
		    };
		} else {
		    TLSETL(101150);
		    (* (TLint4 *) ((* (TLaddressint *) Language_Execute_globalSP))) = Language_Execute_RQHead->activeStream;
		};
		TLSETL(101152);
		Language_Execute_globalSP += 4;
	    }
	    break;
	case 217:
	    {
		Language_SetStreamKind	streamMode;
		TLSETL(101158);
		streamMode = (* (Language_SetStreamKind *) Language_Execute_globalPC);
		TLINCL();
		Language_Execute_globalPC += Language_codeInt1Size;
		TLSETL(101161);
		(* (TLaddressint *) ((* (TLaddressint *) Language_Execute_globalSP))) = (TLaddressint) ((* (TLaddressint *) ((unsigned long) Language_Execute_globalSP + (2 * 4))));
		TLSETL(101163);
		Language_Execute_globalSP += 4;
		TLINCL();
		TL_TLI_TLIXSN = (* (TLint4 *) ((unsigned long) Language_Execute_globalSP + (2 * 4)));
		TLINCL();
		(* (TLint4 *) ((* (TLaddressint *) Language_Execute_globalSP))) = TL_TLI_TLIXSN;
		TLINCL();
		Language_Execute_globalSP += 12;
		TLSETL(101168);
		if ((TL_TLI_TLIXSN < (- 2)) || (TL_TLI_TLIXSN > 20)) {
		    TLSETL(101173);
		    {
			TLstring	__x2167;
			TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x2167);
			{
			    TLstring	__x2166;
			    TL_TLS_TLSCAT("I/O attempted on illegal stream number ", __x2167, __x2166);
			    Language_Execute_ExecutionError_Abort((TLint4) 10000, __x2166);
			};
		    };
		};
		TLSETL(101174);
		if ((Language_Execute_fileMap[TLINRANGELOW(TL_TLI_TLIXSN, -2, 20, 1)]) == -3) {
		    Language_StreamModeSet	openMode;
		    TLSETL(101175);
		    if (TL_TLI_TLIXSN > Language_Execute_numArguments) {
			TLSETL(101179);
			{
			    TLstring	__x2169;
			    TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x2169);
			    {
				TLstring	__x2168;
				TL_TLS_TLSCAT("I/O attempted on unopened or closed stream ", __x2169, __x2168);
				Language_Execute_ExecutionError_Abort((TLint4) 10000, __x2168);
			    };
			};
		    };
		    TLSETL(101181);
		    openMode = (TLSMLSMLSETCONST(TLINRANGELOW(streamMode, 0, 5, 19)));
		    TLINCL();
		    if (streamMode == 0) {
			TLSETL(101183);
			openMode |= 0x2;
		    };
		    TLSETL(101186);
		    Language_Execute_OpenArgumentFile((Language_StreamModeSet) openMode, (TLboolean) 1);
		};
	    }
	    break;
	case 55:
	    {
		register TLint4	Index;
		TLSETL(101193);
		if (((* (Language_SubstringKind *) Language_Execute_globalPC)) == 0) {
		    TLSETL(101194);
		    Index = (* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4));
		} else {
		    TLSETL(101196);
		    TLASSERT (((* (Language_SubstringKind *) Language_Execute_globalPC)) == 1);
		    TLINCL();
		    Index = ((* (TLint4 *) Language_Execute_globalSP)) - ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4)));
		};
		TLSETL(101200);
		if (Index <= 0) {
		    TLSETL(101203);
		    Language_Execute_ExecutionError_Abort((TLint4) 10000, "Char substring index is less than 1");
		} else {
		    TLSETL(101203);
		    if (Index > ((* (TLint4 *) Language_Execute_globalSP))) {
			TLSETL(101206);
			Language_Execute_ExecutionError_Abort((TLint4) 10000, "Char substring index is greater than length of char(n)");
		    };
		};
		TLSETL(101208);
		(* (TLaddressint *) ((unsigned long) Language_Execute_globalSP + (2 * 4))) += Index - 1;
		TLINCL();
		Language_Execute_globalSP += 8;
		TLINCL();
		Language_Execute_globalPC += Language_codeInt1Size;
	    }
	    break;
	case 56:
	    {
		register TLint4	startIndex;
		register TLint4	endIndex;
		register TLint4	slen;
		register TLaddressint	tAddr;
		register TLaddressint	sAddr;
		TLSETL(101216);
		slen = (* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4));
		TLSETL(101218);
		switch ((* (Language_SubstringKind *) Language_Execute_globalPC)) {
		    case 2:
			{
			    TLSETL(101220);
			    startIndex = (* (TLint4 *) (((unsigned long) Language_Execute_globalSP + 4) + (2 * 4)));
			    TLINCL();
			    endIndex = (* (TLint4 *) (((unsigned long) Language_Execute_globalSP + 4) + 4));
			}
			break;
		    case 3:
			{
			    TLSETL(101224);
			    startIndex = (* (TLint4 *) (((unsigned long) Language_Execute_globalSP + 4) + (2 * 4)));
			    TLINCL();
			    endIndex = slen - ((* (TLint4 *) (((unsigned long) Language_Execute_globalSP + 4) + 4)));
			}
			break;
		    case 4:
			{
			    TLSETL(101228);
			    startIndex = slen - ((* (TLint4 *) (((unsigned long) Language_Execute_globalSP + 4) + (2 * 4))));
			    TLINCL();
			    endIndex = (* (TLint4 *) (((unsigned long) Language_Execute_globalSP + 4) + 4));
			}
			break;
		    case 5:
			{
			    TLSETL(101232);
			    startIndex = slen - ((* (TLint4 *) (((unsigned long) Language_Execute_globalSP + 4) + (2 * 4))));
			    TLINCL();
			    endIndex = slen - ((* (TLint4 *) (((unsigned long) Language_Execute_globalSP + 4) + 4)));
			}
			break;
		    default:
			TLCASEABORT;
		};
		TLSETL(101236);
		if (startIndex <= 0) {
		    TLSETL(101239);
		    Language_Execute_ExecutionError_Abort((TLint4) 10000, "Left bound of char substring is less than 1");
		} else {
		    TLSETL(101239);
		    if ((startIndex - endIndex) > 1) {
			TLSETL(101242);
			Language_Execute_ExecutionError_Abort((TLint4) 10000, "Left bound of char substring exceeds right bound by more than 1");
		    } else {
			TLSETL(101242);
			if (endIndex > slen) {
			    TLSETL(101245);
			    Language_Execute_ExecutionError_Abort((TLint4) 10000, "Right bound of char substring is greater than size of char(n)");
			} else {
			    TLSETL(101245);
			    if ((endIndex - startIndex) >= 256) {
				TLSETL(101248);
				Language_Execute_ExecutionError_Abort((TLint4) 10000, "Char substring too large to fit into \'string\'");
			    };
			};
		    };
		};
		TLSETL(101251);
		(* (TLint1 *) ((* (TLaddressint *) Language_Execute_globalSP))) = 0;
		TLSETL(101254);
		tAddr = (TLaddressint) ((* (TLaddressint *) Language_Execute_globalSP));
		TLINCL();
		sAddr = (TLaddressint) (((unsigned long) ((* (TLaddressint *) (((unsigned long) Language_Execute_globalSP + 4) + (3 * 4)))) + startIndex) - 1);
		TLSETL(101258);
		{
		    register TLint4	__x1707;
		    TLint4	__x2191;
		    __x2191 = endIndex;
		    __x1707 = startIndex;
		    if (__x1707 <= __x2191) {
			for(;;) {
			    register TLnat4	val;
			    TLSETL(101259);
			    val = (* (TLnat1 *) sAddr);
			    TLINCL();
			    sAddr += 1;
			    TLSETL(101262);
			    if ((val & 127) == 0) {
				TLSETL(101265);
				Language_Execute_ExecutionError_Abort((TLint4) 10000, "char(n) converted to string contains EOS or uninitchar");
			    };
			    TLSETL(101266);
			    (* (TLnat1 *) tAddr) = val;
			    TLINCL();
			    tAddr += 1;
			    if (__x1707 == __x2191) break;
			    __x1707++;
			}
		    };
		};
		TLSETL(101269);
		(* (TLnat1 *) tAddr) = 0;
		TLSETL(101271);
		(* (TLaddressint *) (((unsigned long) Language_Execute_globalSP + 4) + (3 * 4))) = (TLaddressint) ((* (TLaddressint *) Language_Execute_globalSP));
		TLSETL(101273);
		Language_Execute_globalSP += 16;
		TLINCL();
		Language_Execute_globalPC += Language_codeInt1Size;
	    }
	    break;
	default :
	    {
		TLSETL(101277);
		if (op > 254) {
		    TLSETL(101280);
		    {
			TLstring	__x2198;
			TL_TLS_TLSVIS((TLint4) (* (TLnat2 *) &op), (TLint4) 1, (TLint4) 10, __x2198);
			{
			    TLstring	__x2197;
			    TL_TLS_TLSCAT("Undecodeable opcode #", __x2198, __x2197);
			    Language_Execute_ExecutionError_Abort((TLint4) 10000, __x2197);
			};
		    };
		} else {
		    TLSETL(101288);
		    {
			TLstring	__x2199;
			TL_TLS_TLSCAT("Unimplemented opcode ", Language_OpcodeName[TLINRANGELOW(op, 0, 254, 1)], __x2199);
			Language_Execute_ExecutionError_Abort((TLint4) 10000, __x2199);
		    };
		};
	    }
	    break;
    };
    TLRESTORELF();
}

void Language_Execute_EndExecution () {
    TLSTKCHKSLF(101295);
    TLSETF();
    TLSETL(101295);
    Language_Execute_CloseArguments();
    TLINCL();
    Language_Execute_CloseAllFiles();
    TLRESTORELF();
}

void Language_Execute_RecoverAllMemory () {
    TLSTKCHKSLF(101301);
    TLSETF();
    TLSETL(101301);
    Language_Execute_EndExecution();
    TLINCL();
    Language_Execute_Heap_CleanUp();
    Language_Execute_RQHead = (struct Language_Execute_ProcessDescriptor *) 0;
    TLINCL();
    Language_Execute_EQHead = (struct Language_Execute_ProcessDescriptor *) 0;
    TLRESTORELF();
}
TLint4	Language_Execute_quantaCount;

void Language_Execute_Initialize (startPC, maxStackSize, inName, outName, args, numArgs)
TLaddressint	startPC;
TLnat4	maxStackSize;
TLstring	inName;
TLstring	outName;
__x1916	args;
TLint4	numArgs;
{
    TLnat4	stackSize;
    TLaddressint	stackBase;

    extern void TL_TLA_TLARZ ();
    TLSTKCHKSLF(101317);
    TLSETF();
    TLSETL(101317);
    if (strcmp(inName, "") == 0) {
	TLSETL(101318);
	Language_Execute_fileMap[0] = -2;
    } else {
	TLint4	inStream;
	TLSETL(101321);
	TL_TLI_TLIOF ((TLnat2) 2, inName, &inStream);
	TLINCL();
	if (inStream == 0) {
	    TLSETL(101326);
	    {
		TLstring	__x2201;
		TL_TLS_TLSCAT("Unable to open file \'", inName, __x2201);
		{
		    TLstring	__x2200;
		    TL_TLS_TLSCAT(__x2201, "\' for input", __x2200);
		    Language_ErrorModule_Message(&(Language_nullSrcPosition), (Language_ErrorModule_Severity) 3, __x2200);
		};
	    };
	};
	TLSETL(101327);
	Language_Execute_fileMap[0] = inStream;
    };
    TLSETL(101330);
    if (strcmp(outName, "") == 0) {
	TLSETL(101331);
	Language_Execute_fileMap[1] = -1;
	TLINCL();
	Language_Execute_fileMap[2] = -1;
    } else {
	TLint4	outStream;
	TLSETL(101335);
	TL_TLI_TLIOF ((TLnat2) 4, outName, &outStream);
	TLINCL();
	if (outStream == 0) {
	    TLSETL(101340);
	    {
		TLstring	__x2203;
		TL_TLS_TLSCAT("Unable to open file \'", outName, __x2203);
		{
		    TLstring	__x2202;
		    TL_TLS_TLSCAT(__x2203, "\' for output", __x2202);
		    Language_ErrorModule_Message(&(Language_nullSrcPosition), (Language_ErrorModule_Severity) 3, __x2202);
		};
	    };
	};
	TLSETL(101341);
	Language_Execute_fileMap[1] = outStream;
	TLINCL();
	Language_Execute_fileMap[2] = outStream;
    };
    TLSETL(101345);
    Language_Execute_numArguments =  TLSIMPLEMIN(numArgs, 20);
    TLSETL(101347);
    {
	register TLint4	i;
	TLint4	__x2204;
	__x2204 = Language_Execute_numArguments;
	i = 0;
	if (i <= __x2204) {
	    for(;;) {
		TLSETL(101348);
		TL_TLB_TLBNWU(& Language_Execute_argumentNames[TLINRANGELOW(i, 0, 20, 1)], (TLint4)  sizeof (		Language_StringDef));
		TLINCL();
		if ((Language_Execute_argumentNames[TLINRANGELOW(i, 0, 20, 1)]) == ((Language_StringDef *) 0)) {
		    TLSETL(101353);
		    Language_ErrorModule_Message(&(Language_nullSrcPosition), (Language_ErrorModule_Severity) 3, "Unable to allocate memory for arguments");
		};
		TLSETL(101354);
		TLSTRASS(255, (*(Language_Execute_argumentNames[TLINRANGELOW(i, 0, 20, 1)])), args[TLINRANGELOW(i, 0, 20, 1)]);
		if (i == __x2204) break;
		i++;
	    }
	};
    };
    TLSETL(101358);
    stackSize = maxStackSize * 1024;
    TLINCL();
    if (stackSize < 0x1000) {
	TLSETL(101360);
	stackSize = 4096;
    };
    TLSETL(101364);
    for(;;) {
	TLSETL(101366);
	Language_Execute_Heap_Alloc(&(stackBase), (TLnat4) ((256 + stackSize) + sizeof(struct Language_Execute_ProcessDescriptor)));
	if ((unsigned long) stackBase != 0) {
	    break;
	};
	TLSETL(101367);
	if (stackSize > (64 * 1024)) {
	    TLSETL(101368);
	    stackSize /= 2;
	} else {
	    TLSETL(101370);
	    stackSize -= 2048;
	};
	TLSETL(101372);
	if (stackSize < 0x1000) {
	    TLSETL(101376);
	    Language_ErrorModule_Message(&(Language_nullSrcPosition), (Language_ErrorModule_Severity) 3, "Unable to allocate memory for stack");
	};
    };
    TLSETL(101378);
    Language_Execute_stackAllocated = stackSize;
    TLSETL(101380);
    * (TLnat4 *) &Language_Execute_RQHead = ((unsigned long) stackBase + 256) + stackSize;
    TLINCL();
    Language_Execute_RQHead->pc = (TLaddressint) startPC;
    TLINCL();
    Language_Execute_RQHead->fp = (TLaddressint) 0;
    TLINCL();
    Language_Execute_RQHead->sp = (TLaddressint) ((* (TLnat4 *) &Language_Execute_RQHead) - 4);
    TLINCL();
    (* (TLaddressint *) (Language_Execute_RQHead->sp)) = (TLaddressint) 0;
    TLINCL();
    Language_Execute_RQHead->minimumSP = (TLaddressint) ((unsigned long) stackBase + 256);
    TLINCL();
    Language_Execute_RQHead->stackBase = (TLaddressint) stackBase;
    TLINCL();
    TLSTRCTASS(Language_Execute_RQHead->srcPos, Language_nullSrcPosition, struct SrcPosition);
    TLINCL();
    Language_Execute_RQHead->activeStream = 0;
    TLINCL();
    TLSTRASS(255, Language_Execute_RQHead->errMessage, "");
    TLINCL();
    TLSTRASS(255, Language_Execute_RQHead->prevErrMessage, "");
    TLINCL();
    Language_Execute_RQHead->name = (TLaddressint) 0;
    TLINCL();
    Language_Execute_RQHead->nextProcess = (struct Language_Execute_ProcessDescriptor *) 0;
    TLINCL();
    Language_Execute_RQHead->dispatchPriority = 1000;
    TLINCL();
    Language_Execute_RQHead->totalPause = 0;
    TLINCL();
    Language_Execute_RQHead->activeHandler = (struct Language_Execute_HandlerArea *) 0;
    TLINCL();
    Language_Execute_RQHead->runningHandler = (struct Language_Execute_HandlerArea *) 0;
    TLSETL(101398);
    Language_Execute_RQHead->stepSpec = 0;
    TLINCL();
    Language_Execute_RQHead->stepFP = (TLaddressint) 0;
    TLSETL(101403);
    Language_Execute_savedInitPC = (TLaddressint) 0;
    TLINCL();
    Language_Execute_savedInitFP = (TLaddressint) 0;
    TLSETL(101407);
    Language_Execute_EQHead = (struct Language_Execute_ProcessDescriptor *) 0;
    TLSETL(101410);
    Language_Execute_ExecutionError_Initialize();
    Language_Execute_Chrono = 0;
    TLINCL();
    Language_Execute_quantaCount = 20;
    TLINCL();
    Language_Execute_processCount = 0;
    TLSETL(101418);
    Language_Execute_Kernel_Initialize();
    TLSETL(101422);
    TL_TLA_TLARZ();
    TLINCL();
    MIO_Init();
    TLRESTORELF();
}

void Language_Execute_SetStep (step)
Language_Step	step;
{
    register struct Language_Execute_ProcessDescriptor	*pd;
    TLSTKCHKSLF(101429);
    TLSETF();
    TLSETL(101429);
    pd = Language_Execute_RQHead;
    TLINCL();
    if (pd == ((struct Language_Execute_ProcessDescriptor *) 0)) {
	TLSETL(101431);
	pd = Language_Execute_EQHead;
    };
    TLSETL(101433);
    if (pd != ((struct Language_Execute_ProcessDescriptor *) 0)) {
	TLSETL(101434);
	pd->stepSpec = step;
	TLINCL();
	if (step == 3) {
	    TLSETL(101436);
	    if ((unsigned long) (pd->fp) == 0) {
		TLSETL(101437);
		pd->stepSpec = 0;
		TLINCL();
		pd->stepFP = (TLaddressint) 0;
	    } else {
		TLSETL(101440);
		pd->stepFP = (TLaddressint) ((* (TLaddressint *) (pd->fp)));
	    };
	} else {
	    TLSETL(101443);
	    pd->stepFP = (TLaddressint) 0;
	};
    };
    TLRESTORELF();
}

extern void Math_Arctan ();

extern void Math_Arctand ();

extern void Math_Ceil ();

extern void Math_Cos ();

extern void Math_Cosd ();

extern void Math_Exp ();

extern void Math_Floor ();

extern void Math_Intreal ();

extern void Math_Ln ();

extern void Math_Natreal ();

extern void Math_Rand ();

extern void Math_Randint ();

extern void Math_Randnext ();

extern void Math_Randomize ();

extern void Math_Randseed ();

extern void Math_Round ();

extern void Math_Sign ();

extern void Math_Sin ();

extern void Math_Sind ();

extern void Math_Sqrt ();

extern void String_Erealstr ();

extern void String_Frealstr ();

extern void String_Index ();

extern void String_Length ();

extern void String_Realstr ();

extern void String_Repeat ();

extern void String_Strreal ();

extern void Language_Execute_System_Clock ();

extern void Language_Execute_System_Date ();

extern void Language_Execute_System_Fetcharg ();

extern void Language_Execute_System_Flushstreams ();

extern void Language_Execute_System_Getenv ();

extern void Language_Execute_System_Getpid ();

extern void Language_Execute_System_Nargs ();

extern void Language_Execute_System_Setactive ();

extern void Language_Execute_System_Simutime ();

extern void Language_Execute_System_Sysclock ();

extern void Language_Execute_System_System ();

extern void Language_Execute_System_Time ();

extern void Language_Execute_System_Wallclock ();

extern void Limits_Getexp ();

extern void Limits_Rreb ();

extern void Limits_Setexp ();

extern void Language_Execute_Graphics_Drawpic ();

extern void Language_Execute_Graphics_Getch ();

extern void Language_Execute_Graphics_Hasch ();

extern void Language_Execute_Graphics_Sizepic ();

extern void Language_Execute_Graphics_Takepic ();

extern void Language_Execute_Event_Getevent ();

extern void Language_Execute_Event_Hasevent ();

extern void MT_InterpretIfc ();

extern void Star_initialize ();

extern void Star_getToken ();

extern void Star_finalize ();
struct	Language_Execute_RunDescriptor {
    Language_ReturnState	state;
    TLboolean	doQuit;
};

extern void Language_Execute_Run ();
extern TLint4	TL_TLI_TLIARC;

extern void TL_TLI_TLIFA ();

extern void TL_TLX_TLXGE ();

extern void TL_TLX_TLXDT ();

extern void TL_TLX_TLXTM ();

extern void TL_TLX_TLXCL ();

extern void TL_TLX_TLXSC ();

extern void time ();

extern void TL_TLX_TLXSYS ();

extern TLint4 getpid ();

extern void TL_TLI_TLIFS ();

extern void TL_TLK_TLKUEXIT ();
extern TLnat4	TL_TLK_TLKTIME;
extern TLnat4	TL_TLK_TLKEPOCH;

extern void TL_TLK_TLKUDMPA ();

extern void TL_TLK_TLKCINI ();
extern TLboolean	TL_TLK_TLKCLKON;
extern TLnat4	TL_TLK_TLKHZ;
extern TLnat4	TL_TLK_TLKCRESO;
extern TLnat4	TL_TLK_TLKTIME;
extern TLnat4	TL_TLK_TLKEPOCH;

extern void TL_TLK_TLKPSID ();

extern TLnat4 TL_TLK_TLKPGID ();

extern void TL_TLK_TLKRSETP ();

void Language_Execute_Executor (runStatus)
struct Language_RunStatus	*runStatus;
{
    struct TLHAREA	quitCode;
    TLSTKCHKSLF(101496);
    if (TLHANDENTER(quitCode)) {
	TLSETF();
	TLSETL(101496);
	(*runStatus).state = 0;
	TLSETL(101498);
	if (Language_Execute_RQHead != ((struct Language_Execute_ProcessDescriptor *) 0)) {
	    TLSETL(101499);
	    Language_Execute_RQHead->pc = (TLaddressint) Language_Execute_globalPC;
	    TLINCL();
	    Language_Execute_RQHead->sp = (TLaddressint) Language_Execute_globalSP;
	    TLINCL();
	    TLSTRCTASS((*runStatus).srcPos, Language_Execute_RQHead->srcPos, struct SrcPosition);
	} else {
	    TLSETL(101503);
	    TLSTRCTASS((*runStatus).srcPos, Language_nullSrcPosition, struct SrcPosition);
	};
	TLSETL(101505);
	(*runStatus).threadId = (TLaddressint) (* (TLnat4 *) &Language_Execute_RQHead);
	TLSETL(101507);
	TL_TLI_TLIFS();
	if (quitCode.quitCode != 1) {
	    TLSETL(101508);
	    TL_TLE_TLEQUIT ((TLint4) quitCode.quitCode, (char *) 0, 1);
	};
    } else {
	struct Language_Execute_ProcessDescriptor	*oldRQHead;
	struct Language_Execute_RunDescriptor	runDesc;
	TLSETF();
	TLSETL(101514);
	oldRQHead = Language_Execute_RQHead;
	TLSETL(101517);
	Language_Execute_EventQueueDispatch();
	TLINCL();
	Language_Execute_Kernel_RunQueueDispatch();
	if (Language_Execute_RQHead == ((struct Language_Execute_ProcessDescriptor *) 0)) {
	    TLSETL(101519);
	    if (Language_Execute_EQHead == ((struct Language_Execute_ProcessDescriptor *) 0)) {
		TLSETL(101520);
		(*runStatus).state = 0;
	    } else {
		TLSETL(101522);
		if (Language_Execute_allWaitingForKeyboard) {
		    TLSETL(101523);
		    (*runStatus).state = 6;
		} else {
		    TLSETL(101525);
		    (*runStatus).state = 2;
		};
	    };
	    TLSETL(101528);
	    TLSTRCTASS((*runStatus).srcPos, Language_nullSrcPosition, struct SrcPosition);
	    TLINCL();
	    (*runStatus).threadId = (TLaddressint) 0;
	    TLSETL(101532);
	    TL_TLE_TLEHX();
	    TLRESTORELF();
	    return;
	} else {
	    TLSETL(101532);
	    if (Language_Execute_RQHead != oldRQHead) {
		TLSETL(101533);
		Language_Execute_quantaCount = 20;
		TLINCL();
		if ((oldRQHead == ((struct Language_Execute_ProcessDescriptor *) 0)) || ((oldRQHead->stepSpec) != 0)) {
		    TLSETL(101536);
		    (*runStatus).state = 5;
		    TLINCL();
		    TLSTRCTASS((*runStatus).srcPos, Language_Execute_RQHead->srcPos, struct SrcPosition);
		    TLINCL();
		    (*runStatus).threadId = (TLaddressint) (* (TLnat4 *) &Language_Execute_RQHead);
		    TLSETL(101541);
		    TL_TLE_TLEHX();
		    TLRESTORELF();
		    return;
		};
	    };
	};
	TLSETL(101544);
	Language_Execute_globalPC = (TLaddressint) (Language_Execute_RQHead->pc);
	TLINCL();
	Language_Execute_globalSP = (TLaddressint) (Language_Execute_RQHead->sp);
	TLSETL(101547);
	if ((unsigned long) Language_Execute_savedInitPC == (unsigned long) Language_Execute_globalPC) {
	    TLSETL(101548);
	    Language_Execute_savedInitPC = (TLaddressint) 0;
	    TLINCL();
	    Language_Execute_savedInitFP = (TLaddressint) 0;
	};
	TLSETL(101554);
	Language_Execute_SetActive(&(Language_Execute_RQHead->activeStream));
	TLSETL(101556);
	for(;;) {
	    TLSETL(101557);
	    Language_Execute_Run(&(runDesc));
	    if (!(runDesc.doQuit)) {
		break;
	    };
	    TLSETL(101560);
	    Language_Execute_ExecutionError_GetAbort(&(Language_Execute_RQHead->abort.quitCode), Language_Execute_RQHead->abort.errorMsg);
	    TLINCL();
	    Language_Execute_DispatchHandler((TLint4) (Language_Execute_RQHead->abort.quitCode));
	};
	TLSETL(101562);
	(*runStatus).state = runDesc.state;
	TLSETL(101564);
	if (Language_Execute_RQHead != ((struct Language_Execute_ProcessDescriptor *) 0)) {
	    TLSETL(101565);
	    Language_Execute_RQHead->pc = (TLaddressint) Language_Execute_globalPC;
	    TLINCL();
	    Language_Execute_RQHead->sp = (TLaddressint) Language_Execute_globalSP;
	    TLINCL();
	    TLSTRCTASS((*runStatus).srcPos, Language_Execute_RQHead->srcPos, struct SrcPosition);
	} else {
	    TLSETL(101569);
	    TLSTRCTASS((*runStatus).srcPos, Language_nullSrcPosition, struct SrcPosition);
	};
	TLSETL(101571);
	(*runStatus).threadId = (TLaddressint) (* (TLnat4 *) &Language_Execute_RQHead);
	TL_TLE_TLEHX();
    }
}

void Language_Execute () {
    TLSAVELF();
    TLSETF();
    TLSETL(100118);
    Language_Execute_stackAllocated = 0;
    ExecutionError();
    Language_Execute_Heap();
    MIO();
    TLSETL(100163);
    Language_Execute_numArguments = 0;
    TLSETL(100168);
    Language_Execute_numFilesOpen = 0;
    TLSETL(100173);
    Language_Execute_fileMap[0] = -2;
    TLINCL();
    Language_Execute_fileMap[1] = -1;
    TLINCL();
    Language_Execute_fileMap[2] = -1;
    TLINCL();
    {
	register TLint4	i;
	for (i = 1; i <= 20; i++) {
	    TLSETL(100177);
	    Language_Execute_fileMap[TLINRANGELOW(i, -2, 20, 1)] = -3;
	    TLINCL();
	    Language_Execute_argumentNames[TLINRANGELOW(i, 0, 20, 1)] = (Language_StringDef *) 0;
	};
    };
    TLSETL(100196);
    TL_TLI_TLIUXS = 1;
    TLSETL(100367);
    Language_Execute_RQHead = (struct Language_Execute_ProcessDescriptor *) 0;
    TLINCL();
    Language_Execute_EQHead = (struct Language_Execute_ProcessDescriptor *) 0;
    TLINCL();
    Language_Execute_Chrono = 0;
    TLINCL();
    Language_Execute_processCount = 0;
    Language_Execute_Kernel();
    Math();
    String();
    Language_Execute_System();
    Limits();
    Language_Execute_Graphics();
    Language_Execute_Event();
    MT();
    Star();
    TLRESTORELF();
}
