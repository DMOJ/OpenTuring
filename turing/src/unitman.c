#include "cinterface"
static struct {
    TLint4	dummy;
    char	dummy2[566];
} TLFTAB =
    { 10,
    {'/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'u', 'n', 'i', 't', 'm', 'a', 'n', '/', 'u', 'n', 'i', 't', 'm', 'a', 'n', '.', 'b', 'd', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'u', 'n', 'i', 't', 'm', 'a', 'n', '/', 'u', 'n', 'i', 't', 'm', 'a', 'n', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'u', 'n', 'i', 't', 'm', 'a', 'n', '/', '.', '.', '/', '.', '.', '/', 'f', 'i', 'l', 'e', 'm', 'a', 'n', '/', 'f', 'i', 'l', 'e', 'm', 'a', 'n', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'u', 'n', 'i', 't', 'm', 'a', 'n', '/', '.', '.', '/', 'd', 'u', 'm', 'm', 'y', '.', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'u', 'n', 'i', 't', 'm', 'a', 'n', '/', '.', '.', '/', 'e', 'n', 'v', 'i', 'r', 'o', 'n', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'u', 'n', 'i', 't', 'm', 'a', 'n', '/', '.', '.', '/', 'm', 's', 'g', 's', '.', 'd', 'e', 'f', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'u', 'n', 'i', 't', 'm', 'a', 'n', '/', '.', '.', '/', 'd', 'e', 'b', 'u', 'g', '.', 'd', 'e', 'f', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'u', 'n', 'i', 't', 'm', 'a', 'n', '/', '.', '.', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'u', 'n', 'i', 't', 'm', 'a', 'n', '/', '.', '.', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '.', 'b', 'd', '\0',
    '/', 'l', 'o', 'c', 'a', 'l', '/', 'i', 'n', 'c', 'l', 'u', 'd', 'e', '/', 't', 'p', 'l', 'u', 's', '/', 'D', 'O', 'S', '3', '2', '/', 'm', 'e', 'm', 'o', 'r', 'y', '\0'
    }};
typedef	TLnat2	FileManager_FileNoType;
typedef	TLnat4	FileManager_FileTimeStamp;
typedef	TLint2	FileManager_ResultCode;

extern void FileManager_OpenNamedHandle ();

extern void FileManager_OpenUnnamedHandle ();

extern void FileManager_OpenFileHandle ();

extern void FileManager_SetModified ();

extern void FileManager_WriteFile ();

extern void FileManager_WriteBackup ();

extern void FileManager_WriteTemp ();

extern void FileManager_RmTemp ();

extern void FileManager_CloseFileHandle ();

extern void FileManager_OpenNamedText ();

extern void FileManager_OpenFileText ();

extern void FileManager_CloseFileText ();

extern void FileManager_CloseAllText ();

extern void FileManager_ChangeDirectory ();

extern void FileManager_GetDirectory ();

extern void FileManager_ChangeExecDirectory ();

extern void FileManager_GetExecDirectory ();

extern void FileManager_ShortName ();

extern void FileManager_RelativeName ();

extern void FileManager_PathName ();

extern void FileManager_ExecPathName ();

extern void FileManager_ExtendName ();

extern void FileManager_FileName ();

extern TLboolean FileManager_IsUnnamed ();

extern TLboolean FileManager_IsOnDisk ();

extern TLboolean FileManager_IsSameFile ();

extern TLboolean FileManager_IsReadOK ();

extern TLboolean FileManager_IsWriteOK ();

extern TLboolean FileManager_IsOlder ();

extern TLboolean FileManager_FileExists ();

extern void FileManager_AddReference ();

extern void FileManager_DeleteReference ();

extern void FileManager_ReadTimeStamp ();

extern void FileManager_FlushUnreferencedFiles ();

extern void FileManager_CheckReferencedFiles ();

extern void FileManager_RmFile ();

extern void FileManager_SetDefaultInclude ();

extern void FileManager_AssertTextClosed ();

extern void FileManager_Dump ();

extern TLboolean AbortCheck ();

extern void FeedBack ();
struct	SrcPosition {
    TLnat2	lineNo;
    FileManager_FileNoType	fileNo;
    TLnat2	linePos;
    TLnat2	tokLen;
};
typedef	TLchar	__x565[256];
struct	ErrMsgDef {
    struct ErrMsgDef	*next;
    struct SrcPosition	srcPos;
    __x565	text;
};
typedef	TLint4	CookieKind;
struct	Cookie {
    CookieKind	kind;
    TLaddressint	item;
    TLaddressint	fp;
    TLaddressint	data;
};
struct	CallDef {
    struct CallDef	*next;
    TLstring	routineName;
    struct SrcPosition	srcPos;
    struct Cookie	cookie;
};
struct	ThreadDef {
    struct ThreadDef	*next;
    TLaddressint	threadId;
    TLaddressint	threadName;
    struct CallDef	*traceback;
};
struct	ThreadQueueDef {
    struct ThreadQueueDef	*next;
    TLaddressint	queueId;
    TLstring	queueName;
    struct ThreadDef	*threadList;
};
struct	DumpIndexDef {
    struct DumpIndexDef	*next;
    TLint4	lowerBound;
    TLint4	upperBound;
};
struct	DumpSymbolDef {
    struct DumpSymbolDef	*next;
    TLaddressint	symbolName;
    TLaddressint	typeName;
    struct SrcPosition	srcPos;
    TLstring	value;
    struct Cookie	cookie;
    TLboolean	isPredef;
};
struct	DumpScopeDef {
    struct DumpSymbolDef	symbolInfo;
    struct Cookie	expandCookie;
    struct DumpSymbolDef	*parameters;
    struct DumpSymbolDef	*declarations;
};

extern void Language_Debugging ();

extern void Language_Paragraph ();

extern void Language_Reset ();

extern void Language_SetMaxErrorCount ();
typedef	TLstring	__x566[20];

extern void Language_EnterPreprocSymbols ();

extern void Language_CompileUnit ();

extern void Language_CompileProgram ();

extern void Language_WriteObjectFile ();
typedef	TLstring	__x569[21];
typedef	TLstring	__x573[21];

extern void Language_SetupExecution ();
typedef	TLint1	Language_Step;

extern void Language_SetStep ();
typedef	TLint1	Language_ReturnState;
struct	Language_RunStatus {
    Language_ReturnState	state;
    struct SrcPosition	srcPos;
    TLaddressint	threadId;
};

extern void Language_ExecuteProgram ();

extern void Language_EndExecution ();

extern void Language_StopExecution ();

extern void Language_DumpThreadList ();

extern void Language_DumpUnitList ();

extern void Language_DumpScopeInfo ();

extern void Language_DumpSymbolInfo ();

extern void Language_DumpArrayBounds ();

extern void Language_DumpArrayValues ();
extern TLboolean	Language_debug;
extern struct SrcPosition	Language_nullSrcPosition;
extern struct Cookie	Language_nullCookie;
extern struct DumpSymbolDef	Language_nullSymbolDef;
extern struct DumpScopeDef	Language_nullScopeDef;
typedef	TLint1	Language_UnitManager_UnitKind;
typedef	TLint1	Language_UnitManager_UnitStatus;

void Language_UnitManager_AddDepend ();

void Language_UnitManager_AddIncludeFile ();

void Language_UnitManager_AllocateCompileChunk ();

struct Language_UnitManager_UnitDef * Language_UnitManager_BodyUnit ();

void Language_UnitManager_ClearAllMarks ();

void Language_UnitManager_ClearConfiguration ();

TLaddressint Language_UnitManager_CodeTable ();

FileManager_FileNoType Language_UnitManager_FileNo ();

void Language_UnitManager_FlushOldUnits ();

void Language_UnitManager_GetNextDepend ();

void Language_UnitManager_GetNextUnit ();

void Language_UnitManager_GetUnitPtr ();

TLaddressint Language_UnitManager_GlobalArea ();

TLint4 Language_UnitManager_GlobalSize ();

TLboolean Language_UnitManager_IsCompiled ();

TLboolean Language_UnitManager_IsMarked ();

TLboolean Language_UnitManager_IsPredef ();

Language_UnitManager_UnitKind Language_UnitManager_Kind ();

TLaddressint Language_UnitManager_ManifestTable ();

struct Language_UnitManager_UnitDef * Language_UnitManager_OverrideBody ();

void Language_UnitManager_PrepareForCompile ();

void Language_UnitManager_PrepareForDepends ();

void Language_UnitManager_PrepareForScan ();

void Language_UnitManager_Reset ();

void Language_UnitManager_RewindDependList ();

void Language_UnitManager_RewindUnitList ();

void Language_UnitManager_SetCodeTable ();

void Language_UnitManager_SetDefaultBody ();

void Language_UnitManager_SetGlobalArea ();

void Language_UnitManager_SetKind ();

void Language_UnitManager_SetManifestTable ();

void Language_UnitManager_SetMark ();

void Language_UnitManager_SetOverrideBody ();

void Language_UnitManager_SetPredef ();

void Language_UnitManager_SetStub ();

void Language_UnitManager_SetSymbolTable ();

void Language_UnitManager_StartNewProgram ();

struct Language_UnitManager_UnitDef * Language_UnitManager_StubUnit ();

void Language_UnitManager_SuccessfulCompile ();

TLaddressint Language_UnitManager_SymbolTable ();

extern TLaddressint malloc ();

extern TLaddressint realloc ();

extern void free ();
struct	Language_UnitManager_DependDef {
    struct Language_UnitManager_DependDef	*next;
    struct Language_UnitManager_UnitDef	*unitPtr;
    TLnat4	compileStamp;
};
struct	Language_UnitManager_IncludeDef {
    struct Language_UnitManager_IncludeDef	*next;
    FileManager_FileNoType	fileNo;
    FileManager_FileTimeStamp	timeStamp;
    struct Language_UnitManager_IncludeDef	*firstInclude;
    struct Language_UnitManager_IncludeDef	*lastInclude;
};
typedef	TLchar	Language_UnitManager___x576[4084];
struct	Language_UnitManager_ChunkDef {
    struct Language_UnitManager_ChunkDef	*next;
    Language_UnitManager___x576	memory;
};
typedef	TLint1	Language_UnitManager_CompileState;
struct	Language_UnitManager_UnitDef {
    struct Language_UnitManager_UnitDef	*next;
    FileManager_FileNoType	fileNo;
    Language_UnitManager_CompileState	compileState;
    Language_UnitManager_UnitKind	kind;
    TLboolean	isMarked;
    TLboolean	isPredef;
    FileManager_FileTimeStamp	timeStamp;
    TLnat4	compileStamp;
    struct Language_UnitManager_IncludeDef	*firstInclude;
    struct Language_UnitManager_IncludeDef	*lastInclude;
    struct Language_UnitManager_DependDef	*firstDepend;
    struct Language_UnitManager_DependDef	*currentDepend;
    struct Language_UnitManager_UnitDef	*stubUnit;
    struct Language_UnitManager_UnitDef	*defaultBody;
    struct Language_UnitManager_UnitDef	*overrideBody;
    struct Language_UnitManager_ChunkDef	*compilerMemory;
    TLaddressint	symbolTable;
    TLaddressint	codeTable;
    TLaddressint	manifestTable;
    TLint4	globalSize;
    TLaddressint	globalArea;
};
static struct Language_UnitManager_UnitDef	*Language_UnitManager_freeUnitPtr;

static void Language_UnitManager_AllocateUnitPtr (unitPtr)
struct Language_UnitManager_UnitDef	**unitPtr;
{
    TLBINDREG((*UNIT), struct Language_UnitManager_UnitDef);
    TLSTKCHKSLF(100089);
    TLSETF();
    TLSETL(100089);
    if (Language_UnitManager_freeUnitPtr != ((struct Language_UnitManager_UnitDef *) 0)) {
	TLSETL(100090);
	(*unitPtr) = Language_UnitManager_freeUnitPtr;
	TLINCL();
	Language_UnitManager_freeUnitPtr = Language_UnitManager_freeUnitPtr->next;
    } else {
	TLSETL(100093);
	TL_TLB_TLBNWU(& (*unitPtr), (TLint4)  sizeof (	struct Language_UnitManager_UnitDef));
	TLINCL();
	if ((*unitPtr) == ((struct Language_UnitManager_UnitDef *) 0)) {
	    TLSETL(100096);
	    TLRESTORELF();
	    return;
	};
    };
    TLSETL(100099);
    UNIT = &((*((*unitPtr))));
    TLINCL();
    (*UNIT).next = (struct Language_UnitManager_UnitDef *) 0;
    TLINCL();
    (*UNIT).compileState = 0;
    TLINCL();
    (*UNIT).kind = 0;
    TLINCL();
    (*UNIT).isMarked = 0;
    TLINCL();
    (*UNIT).isPredef = 0;
    TLINCL();
    (*UNIT).timeStamp = 0;
    TLINCL();
    (*UNIT).compileStamp = 0;
    TLINCL();
    (*UNIT).firstInclude = (struct Language_UnitManager_IncludeDef *) 0;
    TLINCL();
    (*UNIT).lastInclude = (struct Language_UnitManager_IncludeDef *) 0;
    TLINCL();
    (*UNIT).firstDepend = (struct Language_UnitManager_DependDef *) 0;
    TLINCL();
    (*UNIT).currentDepend = (struct Language_UnitManager_DependDef *) 0;
    TLINCL();
    (*UNIT).stubUnit = (struct Language_UnitManager_UnitDef *) 0;
    TLINCL();
    (*UNIT).defaultBody = (struct Language_UnitManager_UnitDef *) 0;
    TLINCL();
    (*UNIT).overrideBody = (struct Language_UnitManager_UnitDef *) 0;
    TLINCL();
    (*UNIT).compilerMemory = (struct Language_UnitManager_ChunkDef *) 0;
    TLINCL();
    (*UNIT).symbolTable = (TLaddressint) 0;
    TLINCL();
    (*UNIT).codeTable = (TLaddressint) 0;
    TLINCL();
    (*UNIT).manifestTable = (TLaddressint) 0;
    TLINCL();
    (*UNIT).globalSize = 0;
    TLINCL();
    (*UNIT).globalArea = (TLaddressint) 0;
    TLRESTORELF();
}

static void Language_UnitManager_FreeUnitPtr (unitPtr)
struct Language_UnitManager_UnitDef	**unitPtr;
{
    TLSTKCHKSLF(100128);
    TLSETF();
    TLSETL(100128);
    (*unitPtr)->next = Language_UnitManager_freeUnitPtr;
    TLINCL();
    Language_UnitManager_freeUnitPtr = (*unitPtr);
    TLINCL();
    (*unitPtr) = (struct Language_UnitManager_UnitDef *) 0;
    TLRESTORELF();
}
static struct Language_UnitManager_DependDef	*Language_UnitManager_freeDependPtr;

static void Language_UnitManager_AllocateDependPtr (dependPtr)
struct Language_UnitManager_DependDef	**dependPtr;
{
    TLSTKCHKSLF(100137);
    TLSETF();
    TLSETL(100137);
    if (Language_UnitManager_freeDependPtr != ((struct Language_UnitManager_DependDef *) 0)) {
	TLSETL(100138);
	(*dependPtr) = Language_UnitManager_freeDependPtr;
	TLINCL();
	Language_UnitManager_freeDependPtr = Language_UnitManager_freeDependPtr->next;
    } else {
	TLSETL(100141);
	TL_TLB_TLBNWU(& (*dependPtr), (TLint4)  sizeof (	struct Language_UnitManager_DependDef));
	TLINCL();
	if ((*dependPtr) == ((struct Language_UnitManager_DependDef *) 0)) {
	    TLSETL(100144);
	    TLRESTORELF();
	    return;
	};
    };
    TLSETL(100147);
    (*dependPtr)->next = (struct Language_UnitManager_DependDef *) 0;
    TLINCL();
    (*dependPtr)->compileStamp = 0;
    TLRESTORELF();
}

static void Language_UnitManager_FreeDependPtr (dependPtr)
struct Language_UnitManager_DependDef	**dependPtr;
{
    TLSTKCHKSLF(100152);
    TLSETF();
    TLSETL(100152);
    (*dependPtr)->next = Language_UnitManager_freeDependPtr;
    TLINCL();
    Language_UnitManager_freeDependPtr = (*dependPtr);
    TLINCL();
    (*dependPtr) = (struct Language_UnitManager_DependDef *) 0;
    TLRESTORELF();
}
static struct Language_UnitManager_IncludeDef	*Language_UnitManager_freeIncludePtr;

static void Language_UnitManager_AllocateIncludePtr (includePtr)
struct Language_UnitManager_IncludeDef	**includePtr;
{
    TLBINDREG((*INCLUDE), struct Language_UnitManager_IncludeDef);
    TLSTKCHKSLF(100161);
    TLSETF();
    TLSETL(100161);
    if (Language_UnitManager_freeIncludePtr != ((struct Language_UnitManager_IncludeDef *) 0)) {
	TLSETL(100162);
	(*includePtr) = Language_UnitManager_freeIncludePtr;
	TLINCL();
	Language_UnitManager_freeIncludePtr = Language_UnitManager_freeIncludePtr->next;
    } else {
	TLSETL(100165);
	TL_TLB_TLBNWU(& (*includePtr), (TLint4)  sizeof (	struct Language_UnitManager_IncludeDef));
	TLINCL();
	if ((*includePtr) == ((struct Language_UnitManager_IncludeDef *) 0)) {
	    TLSETL(100168);
	    TLRESTORELF();
	    return;
	};
    };
    TLSETL(100171);
    INCLUDE = &((*((*includePtr))));
    TLINCL();
    (*INCLUDE).next = (struct Language_UnitManager_IncludeDef *) 0;
    TLINCL();
    (*INCLUDE).timeStamp = 0;
    TLINCL();
    (*INCLUDE).firstInclude = (struct Language_UnitManager_IncludeDef *) 0;
    TLINCL();
    (*INCLUDE).lastInclude = (struct Language_UnitManager_IncludeDef *) 0;
    TLRESTORELF();
}

static void Language_UnitManager_FreeIncludePtr (includePtr)
struct Language_UnitManager_IncludeDef	**includePtr;
{
    TLSTKCHKSLF(100179);
    TLSETF();
    TLSETL(100179);
    (*includePtr)->next = Language_UnitManager_freeIncludePtr;
    TLINCL();
    Language_UnitManager_freeIncludePtr = (*includePtr);
    TLINCL();
    (*includePtr) = (struct Language_UnitManager_IncludeDef *) 0;
    TLRESTORELF();
}
static struct Language_UnitManager_UnitDef	*Language_UnitManager_firstUnit;

void Language_UnitManager_GetUnitPtr (fileNo, unitPtr)
FileManager_FileNoType	fileNo;
struct Language_UnitManager_UnitDef	**unitPtr;
{
    register struct Language_UnitManager_UnitDef	*lastUnit;
    TLSTKCHKSLF(100195);
    TLSETF();
    TLSETL(100195);
    lastUnit = Language_UnitManager_firstUnit;
    TLSETL(100199);
    if (lastUnit != ((struct Language_UnitManager_UnitDef *) 0)) {
	TLSETL(100201);
	for(;;) {
	    TLSETL(100201);
	    if ((lastUnit->fileNo) == fileNo) {
		TLSETL(100202);
		(*unitPtr) = lastUnit;
		TLSETL(100204);
		TLRESTORELF();
		return;
	    };
	    TLSETL(100205);
	    if ((lastUnit->next) == ((struct Language_UnitManager_UnitDef *) 0)) {
		break;
	    };
	    TLSETL(100206);
	    lastUnit = lastUnit->next;
	};
    };
    TLSETL(100214);
    Language_UnitManager_AllocateUnitPtr(&((*unitPtr)));
    if ((*unitPtr) == ((struct Language_UnitManager_UnitDef *) 0)) {
	TLSETL(100216);
	TLRESTORELF();
	return;
    };
    TLSETL(100218);
    (*unitPtr)->fileNo = fileNo;
    TLINCL();
    if (fileNo != 0) {
	TLSETL(100221);
	FileManager_AddReference((FileManager_FileNoType) fileNo);
    };
    TLSETL(100223);
    if (lastUnit == ((struct Language_UnitManager_UnitDef *) 0)) {
	TLSETL(100225);
	Language_UnitManager_firstUnit = (*unitPtr);
    } else {
	TLSETL(100227);
	lastUnit->next = (*unitPtr);
    };
    TLRESTORELF();
}

FileManager_FileNoType Language_UnitManager_FileNo (unitPtr)
struct Language_UnitManager_UnitDef	*unitPtr;
{
    TLSTKCHKSLF(100233);
    TLSETF();
    TLSETL(100233);
    if (unitPtr == ((struct Language_UnitManager_UnitDef *) 0)) {
	TLSETL(100234);
	TLRESTORELF();
	return (0);
    };
    TLSETL(100236);
    TLRESTORELF();
    return (unitPtr->fileNo);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

static void Language_UnitManager_FileBase (unitPtr, __x501)
struct Language_UnitManager_UnitDef	*unitPtr;
TLstring	__x501;
{
    TLstring	fileName;
    TLSTKCHKSLF(100240);
    TLSETF();
    TLSETL(100240);
    {
	TLstring	__x578;
	FileManager_FileName((FileManager_FileNoType) Language_UnitManager_FileNo(unitPtr), __x578);
	TLSTRASS(255, fileName, __x578);
    };
    TLSETL(100243);
    for(;;) {
	TLint4	slash;
	TLSETL(100243);
	slash = TL_TLS_TLSIND(fileName, "/");
	TLINCL();
	if (slash == 0) {
	    break;
	};
	TLSETL(100245);
	{
	    TLstring	__x579;
	    TL_TLS_TLSBXS(__x579, (TLint4) 0, (TLint4) (slash + 1), fileName);
	    TLSTRASS(255, fileName, __x579);
	};
    };
    TLSETL(100247);
    {
	TLstring	__x580;
	if ((TL_TLS_TLSLEN(fileName) > 2) && ((TL_TLS_TLSBSS(__x580, (TLint4) 0, (TLint4) -1, fileName), strcmp(__x580, ".t") == 0))) {
	    TLSETL(100248);
	    {
		{
		    TLstring	__x581;
		    TL_TLS_TLSBXS(__x581, (TLint4) -2, (TLint4) 1, fileName);
		    TLSTRASS(255, __x501, __x581);
		};
		TLRESTORELF();
		return;
	    };
	};
    };
    TLSETL(100250);
    {
	TLSTRASS(255, __x501, fileName);
	TLRESTORELF();
	return;
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}
static struct Language_UnitManager_UnitDef	*Language_UnitManager_configUnitPtr;

void Language_UnitManager_SetKind (unitPtr, kind)
struct Language_UnitManager_UnitDef	*unitPtr;
Language_UnitManager_UnitKind	kind;
{
    TLSTKCHKSLF(100256);
    TLSETF();
    TLSETL(100256);
    TLPRE ((((unitPtr != ((struct Language_UnitManager_UnitDef *) 0)) && ((unitPtr->compileState) >= 1)) && ((unitPtr->compileState) <= 2)) && ((unitPtr->kind) == 0));
    TLSETL(100260);
    unitPtr->kind = kind;
    TLINCL();
    if (kind == 3) {
	TLSETL(100262);
	TLASSERT (Language_UnitManager_configUnitPtr == ((struct Language_UnitManager_UnitDef *) 0));
	TLINCL();
	Language_UnitManager_configUnitPtr = unitPtr;
    };
    TLRESTORELF();
}

Language_UnitManager_UnitKind Language_UnitManager_Kind (unitPtr)
struct Language_UnitManager_UnitDef	*unitPtr;
{
    TLSTKCHKSLF(100268);
    TLSETF();
    TLSETL(100268);
    TLPRE (unitPtr != ((struct Language_UnitManager_UnitDef *) 0));
    TLINCL();
    TLRESTORELF();
    return (unitPtr->kind);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

void Language_UnitManager_ClearConfiguration () {
    TLSTKCHKSLF(100273);
    TLSETF();
    TLSETL(100273);
    if (Language_UnitManager_configUnitPtr != ((struct Language_UnitManager_UnitDef *) 0)) {
	register struct Language_UnitManager_UnitDef	*unitPtr;
	TLSETL(100274);
	unitPtr = Language_UnitManager_firstUnit;
	TLSETL(100276);
	for(;;) {
	    TLSETL(100276);
	    if (unitPtr == ((struct Language_UnitManager_UnitDef *) 0)) {
		break;
	    };
	    TLSETL(100277);
	    unitPtr->overrideBody = (struct Language_UnitManager_UnitDef *) 0;
	    TLINCL();
	    unitPtr = unitPtr->next;
	};
	TLSETL(100283);
	TLASSERT ((Language_UnitManager_configUnitPtr->compileState) == 0);
	TLINCL();
	Language_UnitManager_configUnitPtr->kind = 0;
	TLINCL();
	Language_UnitManager_configUnitPtr->timeStamp = 0;
	TLINCL();
	Language_UnitManager_configUnitPtr = (struct Language_UnitManager_UnitDef *) 0;
    };
    TLRESTORELF();
}

static void Language_UnitManager_ClearPredefs () {
    register struct Language_UnitManager_UnitDef	*unitPtr;
    TLSTKCHKSLF(100292);
    TLSETF();
    TLSETL(100292);
    unitPtr = Language_UnitManager_firstUnit;
    TLSETL(100294);
    for(;;) {
	TLSETL(100294);
	if (unitPtr == ((struct Language_UnitManager_UnitDef *) 0)) {
	    break;
	};
	TLSETL(100295);
	if (unitPtr->isPredef) {
	    TLSETL(100296);
	    unitPtr->isPredef = 0;
	    TLSETL(100300);
	    unitPtr->timeStamp = 0;
	};
	TLSETL(100302);
	unitPtr = unitPtr->next;
    };
    TLRESTORELF();
}

void Language_UnitManager_SetPredef (unitPtr)
struct Language_UnitManager_UnitDef	*unitPtr;
{
    TLSTKCHKSLF(100307);
    TLSETF();
    TLSETL(100307);
    TLPRE (unitPtr != ((struct Language_UnitManager_UnitDef *) 0));
    TLINCL();
    unitPtr->isPredef = 1;
    TLRESTORELF();
}

TLboolean Language_UnitManager_IsPredef (unitPtr)
struct Language_UnitManager_UnitDef	*unitPtr;
{
    TLSTKCHKSLF(100312);
    TLSETF();
    TLSETL(100312);
    TLRESTORELF();
    return ((unitPtr != ((struct Language_UnitManager_UnitDef *) 0)) && (unitPtr->isPredef));
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

void Language_UnitManager_ClearAllMarks () {
    register struct Language_UnitManager_UnitDef	*unitPtr;
    TLSTKCHKSLF(100328);
    TLSETF();
    TLSETL(100328);
    unitPtr = Language_UnitManager_firstUnit;
    TLSETL(100330);
    for(;;) {
	TLSETL(100330);
	if (unitPtr == ((struct Language_UnitManager_UnitDef *) 0)) {
	    break;
	};
	TLSETL(100331);
	unitPtr->isMarked = 0;
	TLINCL();
	unitPtr = unitPtr->next;
    };
    TLRESTORELF();
}

void Language_UnitManager_SetMark (unitPtr)
struct Language_UnitManager_UnitDef	*unitPtr;
{
    TLSTKCHKSLF(100337);
    TLSETF();
    TLSETL(100337);
    TLPRE (unitPtr != ((struct Language_UnitManager_UnitDef *) 0));
    TLINCL();
    unitPtr->isMarked = 1;
    TLRESTORELF();
}

TLboolean Language_UnitManager_IsMarked (unitPtr)
struct Language_UnitManager_UnitDef	*unitPtr;
{
    TLSTKCHKSLF(100342);
    TLSETF();
    TLSETL(100342);
    TLPRE (unitPtr != ((struct Language_UnitManager_UnitDef *) 0));
    TLINCL();
    TLRESTORELF();
    return (unitPtr->isMarked);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

void Language_UnitManager_SetStub (unitPtr, stubUnit)
struct Language_UnitManager_UnitDef	*unitPtr;
struct Language_UnitManager_UnitDef	*stubUnit;
{
    TLSTKCHKSLF(100348);
    TLSETF();
    TLSETL(100348);
    TLPRE (((unitPtr != ((struct Language_UnitManager_UnitDef *) 0)) && (stubUnit != ((struct Language_UnitManager_UnitDef *) 0))) && ((unitPtr->stubUnit) == ((struct Language_UnitManager_UnitDef *) 0)));
    TLSETL(100350);
    unitPtr->stubUnit = stubUnit;
    TLRESTORELF();
}

struct Language_UnitManager_UnitDef * Language_UnitManager_StubUnit (unitPtr)
struct Language_UnitManager_UnitDef	*unitPtr;
{
    TLSTKCHKSLF(100354);
    TLSETF();
    TLSETL(100354);
    TLPRE (unitPtr != ((struct Language_UnitManager_UnitDef *) 0));
    TLINCL();
    TLRESTORELF();
    return (unitPtr->stubUnit);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

void Language_UnitManager_SetOverrideBody (unitPtr, bodyUnit)
struct Language_UnitManager_UnitDef	*unitPtr;
struct Language_UnitManager_UnitDef	*bodyUnit;
{
    TLSTKCHKSLF(100360);
    TLSETF();
    TLSETL(100360);
    TLPRE (((unitPtr != ((struct Language_UnitManager_UnitDef *) 0)) && (bodyUnit != ((struct Language_UnitManager_UnitDef *) 0))) && ((unitPtr->overrideBody) == ((struct Language_UnitManager_UnitDef *) 0)));
    TLSETL(100362);
    unitPtr->overrideBody = bodyUnit;
    TLRESTORELF();
}

struct Language_UnitManager_UnitDef * Language_UnitManager_OverrideBody (unitPtr)
struct Language_UnitManager_UnitDef	*unitPtr;
{
    TLSTKCHKSLF(100366);
    TLSETF();
    TLSETL(100366);
    TLPRE (unitPtr != ((struct Language_UnitManager_UnitDef *) 0));
    TLINCL();
    TLRESTORELF();
    return (unitPtr->overrideBody);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

void Language_UnitManager_SetDefaultBody (unitPtr, bodyUnit)
struct Language_UnitManager_UnitDef	*unitPtr;
struct Language_UnitManager_UnitDef	*bodyUnit;
{
    TLSTKCHKSLF(100371);
    TLSETF();
    TLSETL(100371);
    TLPRE (((unitPtr != ((struct Language_UnitManager_UnitDef *) 0)) && (bodyUnit != ((struct Language_UnitManager_UnitDef *) 0))) && ((unitPtr->defaultBody) == ((struct Language_UnitManager_UnitDef *) 0)));
    TLSETL(100373);
    unitPtr->defaultBody = bodyUnit;
    TLRESTORELF();
}

struct Language_UnitManager_UnitDef * Language_UnitManager_BodyUnit (unitPtr)
struct Language_UnitManager_UnitDef	*unitPtr;
{
    TLSTKCHKSLF(100377);
    TLSETF();
    TLSETL(100377);
    TLPRE (unitPtr != ((struct Language_UnitManager_UnitDef *) 0));
    TLINCL();
    if ((unitPtr->defaultBody) == ((struct Language_UnitManager_UnitDef *) 0)) {
	TLSETL(100379);
	TLRESTORELF();
	return ((struct Language_UnitManager_UnitDef *) 0);
    } else {
	TLSETL(100380);
	if ((unitPtr->overrideBody) != ((struct Language_UnitManager_UnitDef *) 0)) {
	    TLSETL(100381);
	    TLRESTORELF();
	    return (unitPtr->overrideBody);
	} else {
	    TLSETL(100383);
	    TLRESTORELF();
	    return (unitPtr->defaultBody);
	};
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

void Language_UnitManager_AddDepend (unitPtr, dependUnit)
struct Language_UnitManager_UnitDef	*unitPtr;
struct Language_UnitManager_UnitDef	**dependUnit;
{
    TLBINDREG((*UNIT), struct Language_UnitManager_UnitDef);
    struct Language_UnitManager_DependDef	*dependPtr;
    TLSTKCHKSLF(100389);
    TLSETF();
    TLSETL(100389);
    TLPRE ((unitPtr != ((struct Language_UnitManager_UnitDef *) 0)) && ((*dependUnit) != ((struct Language_UnitManager_UnitDef *) 0)));
    TLINCL();
    UNIT = &((*(unitPtr)));
    TLINCL();
    dependPtr = (*UNIT).firstDepend;
    TLSETL(100393);
    for(;;) {
	TLSETL(100393);
	if (dependPtr == ((struct Language_UnitManager_DependDef *) 0)) {
	    break;
	};
	TLSETL(100394);
	if ((dependPtr->unitPtr) == (*dependUnit)) {
	    TLSETL(100397);
	    TLRESTORELF();
	    return;
	};
	TLSETL(100398);
	dependPtr = dependPtr->next;
    };
    TLSETL(100402);
    Language_UnitManager_AllocateDependPtr(&(dependPtr));
    if (dependPtr == ((struct Language_UnitManager_DependDef *) 0)) {
	TLSETL(100403);
	(*dependUnit) = (struct Language_UnitManager_UnitDef *) 0;
	TLSETL(100405);
	TLRESTORELF();
	return;
    };
    TLSETL(100407);
    dependPtr->unitPtr = (*dependUnit);
    TLSETL(100409);
    if (((*UNIT).currentDepend) == ((struct Language_UnitManager_DependDef *) 0)) {
	TLSETL(100411);
	TLASSERT (((*UNIT).firstDepend) == ((struct Language_UnitManager_DependDef *) 0));
	TLINCL();
	(*UNIT).firstDepend = dependPtr;
    } else {
	TLSETL(100414);
	(*UNIT).currentDepend->next = dependPtr;
    };
    TLSETL(100416);
    (*UNIT).currentDepend = dependPtr;
    TLRESTORELF();
}

void Language_UnitManager_AddIncludeFile (unitPtr, parentInclude, fileNo, includePtr)
struct Language_UnitManager_UnitDef	*unitPtr;
struct Language_UnitManager_IncludeDef	*parentInclude;
FileManager_FileNoType	fileNo;
struct Language_UnitManager_IncludeDef	**includePtr;
{
    TLSTKCHKSLF(100423);
    TLSETF();
    TLSETL(100423);
    TLPRE ((unitPtr != ((struct Language_UnitManager_UnitDef *) 0)) && (fileNo != 0));
    TLSETL(100426);
    Language_UnitManager_AllocateIncludePtr(&((*includePtr)));
    if ((*includePtr) == ((struct Language_UnitManager_IncludeDef *) 0)) {
	TLSETL(100428);
	TLRESTORELF();
	return;
    };
    TLSETL(100430);
    (*includePtr)->fileNo = fileNo;
    TLSETL(100433);
    FileManager_AddReference((FileManager_FileNoType) fileNo);
    if (parentInclude == ((struct Language_UnitManager_IncludeDef *) 0)) {
	TLSETL(100434);
	if ((unitPtr->lastInclude) == ((struct Language_UnitManager_IncludeDef *) 0)) {
	    TLSETL(100435);
	    unitPtr->firstInclude = (*includePtr);
	} else {
	    TLSETL(100437);
	    unitPtr->lastInclude->next = (*includePtr);
	};
	TLSETL(100439);
	unitPtr->lastInclude = (*includePtr);
    } else {
	TLSETL(100441);
	if ((parentInclude->lastInclude) == ((struct Language_UnitManager_IncludeDef *) 0)) {
	    TLSETL(100442);
	    parentInclude->firstInclude = (*includePtr);
	} else {
	    TLSETL(100444);
	    parentInclude->lastInclude->next = (*includePtr);
	};
	TLSETL(100446);
	parentInclude->lastInclude = (*includePtr);
    };
    TLRESTORELF();
}

void Language_UnitManager_StartNewProgram () {
    register struct Language_UnitManager_UnitDef	*unitPtr;
    TLSTKCHKSLF(100460);
    TLSETF();
    TLSETL(100460);
    unitPtr = Language_UnitManager_firstUnit;
    TLSETL(100462);
    for(;;) {
	TLSETL(100462);
	if (unitPtr == ((struct Language_UnitManager_UnitDef *) 0)) {
	    break;
	};
	TLSETL(100463);
	unitPtr->compileState = 0;
	TLINCL();
	unitPtr = unitPtr->next;
    };
    TLSETL(100471);
    FileManager_CheckReferencedFiles();
    TLRESTORELF();
}

static void Language_UnitManager_IncludeListUpToDate (includePtr, upToDate)
struct Language_UnitManager_IncludeDef	*includePtr;
TLboolean	*upToDate;
{
    register struct Language_UnitManager_IncludeDef	*currentInclude;
    FileManager_FileTimeStamp	timeStamp;
    TLSTKCHKSLF(100552);
    TLSETF();
    TLSETL(100552);
    TLPRE (includePtr != ((struct Language_UnitManager_IncludeDef *) 0));
    TLSETL(100554);
    currentInclude = includePtr;
    TLSETL(100561);
    for(;;) {
	TLSETL(100563);
	FileManager_ReadTimeStamp((FileManager_FileNoType) (currentInclude->fileNo), &(timeStamp));
	if ((currentInclude->timeStamp) != timeStamp) {
	    TLSETL(100564);
	    (*upToDate) = 0;
	    TLSETL(100566);
	    TLRESTORELF();
	    return;
	};
	TLSETL(100571);
	if ((currentInclude->firstInclude) != ((struct Language_UnitManager_IncludeDef *) 0)) {
	    TLSETL(100574);
	    Language_UnitManager_IncludeListUpToDate(currentInclude->firstInclude, &((*upToDate)));
	    if (!(*upToDate)) {
		TLSETL(100575);
		(*upToDate) = 0;
		TLSETL(100577);
		TLRESTORELF();
		return;
	    };
	};
	TLSETL(100583);
	currentInclude = currentInclude->next;
	TLINCL();
	if (currentInclude == ((struct Language_UnitManager_IncludeDef *) 0)) {
	    break;
	};
    };
    TLSETL(100587);
    (*upToDate) = 1;
    TLRESTORELF();
}

static void Language_UnitManager_UnitUpToDate (unitPtr, upToDate)
register struct Language_UnitManager_UnitDef	*unitPtr;
TLboolean	*upToDate;
{
    FileManager_FileTimeStamp	timeStamp;
    TLSTKCHKSLF(100597);
    TLSETF();
    TLSETL(100597);
    TLPRE (unitPtr != ((struct Language_UnitManager_UnitDef *) 0));
    TLSETL(100610);
    if ((unitPtr->fileNo) == 0) {
	TLSETL(100611);
	if ((unitPtr->timeStamp) == 0) {
	    TLSETL(100612);
	    (*upToDate) = 0;
	    TLSETL(100614);
	    TLRESTORELF();
	    return;
	};
    } else {
	TLSETL(100628);
	FileManager_ReadTimeStamp((FileManager_FileNoType) (unitPtr->fileNo), &(timeStamp));
	if ((unitPtr->timeStamp) != timeStamp) {
	    TLSETL(100629);
	    (*upToDate) = 0;
	    TLSETL(100631);
	    TLRESTORELF();
	    return;
	};
    };
    TLSETL(100644);
    if ((unitPtr->firstInclude) != ((struct Language_UnitManager_IncludeDef *) 0)) {
	TLSETL(100646);
	Language_UnitManager_IncludeListUpToDate(unitPtr->firstInclude, &((*upToDate)));
	if (!(*upToDate)) {
	    TLSETL(100648);
	    TLRESTORELF();
	    return;
	};
    };
    TLSETL(100651);
    (*upToDate) = 1;
    TLRESTORELF();
}

static TLboolean Language_UnitManager_DependsUpToDate (unitPtr)
struct Language_UnitManager_UnitDef	*unitPtr;
{
    register struct Language_UnitManager_DependDef	*dependPtr;
    TLSTKCHKSLF(100655);
    TLSETF();
    TLSETL(100655);
    TLPRE (unitPtr != ((struct Language_UnitManager_UnitDef *) 0));
    TLSETL(100657);
    dependPtr = unitPtr->firstDepend;
    TLSETL(100659);
    for(;;) {
	register struct Language_UnitManager_UnitDef	*dependUnit;
	TLSETL(100659);
	if (dependPtr == ((struct Language_UnitManager_DependDef *) 0)) {
	    break;
	};
	TLSETL(100660);
	dependUnit = dependPtr->unitPtr;
	TLINCL();
	if ((dependUnit->compileState) < 5) {
	    TLSETL(100662);
	    TLRESTORELF();
	    return (0);
	};
	TLSETL(100664);
	if ((dependPtr->compileStamp) != (dependUnit->compileStamp)) {
	    TLSETL(100666);
	    TLRESTORELF();
	    return (0);
	};
	TLSETL(100668);
	dependPtr = dependPtr->next;
    };
    TLSETL(100671);
    TLRESTORELF();
    return (1);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

static void Language_UnitManager_StampIncludeList (includePtr)
struct Language_UnitManager_IncludeDef	*includePtr;
{
    register struct Language_UnitManager_IncludeDef	*currentInclude;
    TLSTKCHKSLF(100798);
    TLSETF();
    TLSETL(100798);
    TLPRE (includePtr != ((struct Language_UnitManager_IncludeDef *) 0));
    TLINCL();
    currentInclude = includePtr;
    TLSETL(100804);
    for(;;) {
	TLSETL(100810);
	FileManager_ReadTimeStamp((FileManager_FileNoType) (currentInclude->fileNo), &(currentInclude->timeStamp));
	if ((currentInclude->firstInclude) != ((struct Language_UnitManager_IncludeDef *) 0)) {
	    TLSETL(100812);
	    Language_UnitManager_StampIncludeList(currentInclude->firstInclude);
	};
	TLSETL(100817);
	currentInclude = currentInclude->next;
	TLINCL();
	if (currentInclude == ((struct Language_UnitManager_IncludeDef *) 0)) {
	    break;
	};
    };
    TLRESTORELF();
}

static void Language_UnitManager_StampDependList (dependPtr)
struct Language_UnitManager_DependDef	*dependPtr;
{
    register struct Language_UnitManager_DependDef	*currentDepend;
    TLSTKCHKSLF(100823);
    TLSETF();
    TLSETL(100823);
    TLPRE (dependPtr != ((struct Language_UnitManager_DependDef *) 0));
    TLINCL();
    currentDepend = dependPtr;
    TLSETL(100826);
    for(;;) {
	TLSETL(100826);
	currentDepend->compileStamp = currentDepend->unitPtr->compileStamp;
	TLSETL(100828);
	currentDepend = currentDepend->next;
	TLINCL();
	if (currentDepend == ((struct Language_UnitManager_DependDef *) 0)) {
	    break;
	};
    };
    TLRESTORELF();
}

void Language_UnitManager_SuccessfulCompile (unitPtr)
struct Language_UnitManager_UnitDef	*unitPtr;
{
    TLSTKCHKSLF(100834);
    TLSETF();
    TLSETL(100834);
    TLPRE ((unitPtr != ((struct Language_UnitManager_UnitDef *) 0)) && ((unitPtr->compileState) == 4));
    TLSETL(100840);
    unitPtr->compileStamp += 1;
    TLINCL();
    if ((unitPtr->compileStamp) == 0) {
	TLSETL(100842);
	unitPtr->compileStamp = 1;
    };
    TLSETL(100848);
    if ((unitPtr->fileNo) == 0) {
	TLSETL(100849);
	unitPtr->timeStamp = 1;
    } else {
	TLSETL(100853);
	FileManager_ReadTimeStamp((FileManager_FileNoType) (unitPtr->fileNo), &(unitPtr->timeStamp));
    };
    TLSETL(100858);
    if ((unitPtr->firstInclude) != ((struct Language_UnitManager_IncludeDef *) 0)) {
	TLSETL(100860);
	Language_UnitManager_StampIncludeList(unitPtr->firstInclude);
    };
    TLSETL(100865);
    if ((unitPtr->firstDepend) != ((struct Language_UnitManager_DependDef *) 0)) {
	TLSETL(100867);
	Language_UnitManager_StampDependList(unitPtr->firstDepend);
    };
    TLSETL(100869);
    unitPtr->compileState = 5;
    TLRESTORELF();
}

static void Language_UnitManager_FreeIncludeList (includePtr)
struct Language_UnitManager_IncludeDef	*includePtr;
{
    register struct Language_UnitManager_IncludeDef	*currentInclude;
    TLSTKCHKSLF(100874);
    TLSETF();
    TLSETL(100874);
    TLPRE (includePtr != ((struct Language_UnitManager_IncludeDef *) 0));
    TLINCL();
    currentInclude = includePtr;
    TLSETL(100880);
    for(;;) {
	struct Language_UnitManager_IncludeDef	*oldInclude;
	TLSETL(100880);
	if ((currentInclude->firstInclude) != ((struct Language_UnitManager_IncludeDef *) 0)) {
	    TLSETL(100882);
	    Language_UnitManager_FreeIncludeList(currentInclude->firstInclude);
	};
	TLSETL(100887);
	oldInclude = currentInclude;
	TLINCL();
	currentInclude = currentInclude->next;
	TLSETL(100894);
	FileManager_DeleteReference((FileManager_FileNoType) (oldInclude->fileNo));
	TLSETL(100896);
	Language_UnitManager_FreeIncludePtr(&(oldInclude));
	if (currentInclude == ((struct Language_UnitManager_IncludeDef *) 0)) {
	    break;
	};
    };
    TLRESTORELF();
}

static void Language_UnitManager_FreeCompileInfo (unitPtr)
struct Language_UnitManager_UnitDef	*unitPtr;
{
    TLBINDREG((*UNIT), struct Language_UnitManager_UnitDef);
    TLSTKCHKSLF(100901);
    TLSETF();
    TLSETL(100901);
    TLPRE (unitPtr != ((struct Language_UnitManager_UnitDef *) 0));
    TLSETL(100903);
    UNIT = &((*(unitPtr)));
    TLSETL(100908);
    if (((*UNIT).firstInclude) != ((struct Language_UnitManager_IncludeDef *) 0)) {
	TLSETL(100910);
	Language_UnitManager_FreeIncludeList((*UNIT).firstInclude);
	(*UNIT).firstInclude = (struct Language_UnitManager_IncludeDef *) 0;
	TLINCL();
	(*UNIT).lastInclude = (struct Language_UnitManager_IncludeDef *) 0;
    };
    TLSETL(100918);
    {
	register struct Language_UnitManager_ChunkDef	*chunk;
	chunk = (*UNIT).compilerMemory;
	TLSETL(100920);
	for(;;) {
	    struct Language_UnitManager_ChunkDef	*oldChunk;
	    TLSETL(100920);
	    if (chunk == ((struct Language_UnitManager_ChunkDef *) 0)) {
		break;
	    };
	    TLSETL(100921);
	    oldChunk = chunk;
	    TLINCL();
	    chunk = chunk->next;
	    TLINCL();
	    TL_TLB_TLBFRU(& oldChunk, (TLint4)  sizeof (	    struct Language_UnitManager_ChunkDef));
	};
	TLSETL(100925);
	(*UNIT).compilerMemory = (struct Language_UnitManager_ChunkDef *) 0;
	TLINCL();
	(*UNIT).symbolTable = (TLaddressint) 0;
    };
    TLSETL(100932);
    if ((unsigned long) ((*UNIT).codeTable) != 0) {
	TLSETL(100934);
	free((TLaddressint) ((*UNIT).codeTable));
	(*UNIT).codeTable = (TLaddressint) 0;
    };
    TLSETL(100936);
    if ((unsigned long) ((*UNIT).manifestTable) != 0) {
	TLSETL(100938);
	free((TLaddressint) ((*UNIT).manifestTable));
	(*UNIT).manifestTable = (TLaddressint) 0;
    };
    TLSETL(100940);
    if ((unsigned long) ((*UNIT).globalArea) != 0) {
	TLSETL(100942);
	free((TLaddressint) ((*UNIT).globalArea));
	(*UNIT).globalArea = (TLaddressint) 0;
    };
    TLRESTORELF();
}

static void Language_UnitManager_FreeScanInfo (unitPtr)
struct Language_UnitManager_UnitDef	*unitPtr;
{
    TLBINDREG((*UNIT), struct Language_UnitManager_UnitDef);
    register struct Language_UnitManager_DependDef	*dependPtr;
    TLSTKCHKSLF(100947);
    TLSETF();
    TLSETL(100947);
    TLPRE (unitPtr != ((struct Language_UnitManager_UnitDef *) 0));
    TLSETL(100951);
    Language_UnitManager_FreeCompileInfo(unitPtr);
    UNIT = &((*(unitPtr)));
    TLINCL();
    dependPtr = (*UNIT).firstDepend;
    TLSETL(100954);
    for(;;) {
	struct Language_UnitManager_DependDef	*oldDepend;
	TLSETL(100954);
	if (dependPtr == ((struct Language_UnitManager_DependDef *) 0)) {
	    break;
	};
	TLSETL(100955);
	oldDepend = dependPtr;
	TLINCL();
	dependPtr = dependPtr->next;
	TLSETL(100958);
	Language_UnitManager_FreeDependPtr(&(oldDepend));
    };
    TLSETL(100959);
    (*UNIT).firstDepend = (struct Language_UnitManager_DependDef *) 0;
    TLINCL();
    (*UNIT).currentDepend = (struct Language_UnitManager_DependDef *) 0;
    TLSETL(100962);
    (*UNIT).stubUnit = (struct Language_UnitManager_UnitDef *) 0;
    TLINCL();
    (*UNIT).defaultBody = (struct Language_UnitManager_UnitDef *) 0;
    TLRESTORELF();
}

void Language_UnitManager_Reset () {
    register struct Language_UnitManager_UnitDef	*unitPtr;
    TLSTKCHKSLF(100967);
    TLSETF();
    TLSETL(100967);
    unitPtr = Language_UnitManager_firstUnit;
    TLSETL(100969);
    for(;;) {
	struct Language_UnitManager_UnitDef	*oldUnit;
	TLSETL(100969);
	if (unitPtr == ((struct Language_UnitManager_UnitDef *) 0)) {
	    break;
	};
	TLSETL(100971);
	Language_UnitManager_FreeScanInfo(unitPtr);
	if ((unitPtr->fileNo) != 0) {
	    TLSETL(100973);
	    FileManager_DeleteReference((FileManager_FileNoType) (unitPtr->fileNo));
	};
	TLSETL(100974);
	oldUnit = unitPtr;
	TLINCL();
	unitPtr = unitPtr->next;
	TLSETL(100977);
	Language_UnitManager_FreeUnitPtr(&(oldUnit));
    };
    TLSETL(100978);
    Language_UnitManager_firstUnit = (struct Language_UnitManager_UnitDef *) 0;
    TLRESTORELF();
}

void Language_UnitManager_PrepareForScan (unitPtr, unitStatus)
struct Language_UnitManager_UnitDef	*unitPtr;
Language_UnitManager_UnitStatus	*unitStatus;
{
    TLSTKCHKSLF(100989);
    TLSETF();
    TLSETL(100989);
    TLPRE (unitPtr != ((struct Language_UnitManager_UnitDef *) 0));
    TLSETL(100991);
    if ((unitPtr->compileState) == 0) {
	TLboolean	upToDate;
	TLSETL(101009);
	Language_UnitManager_UnitUpToDate(unitPtr, &(upToDate));
	if (upToDate) {
	    TLSETL(101010);
	    (*unitStatus) = 1;
	    TLINCL();
	    unitPtr->compileState = 2;
	} else {
	    TLSETL(101013);
	    (*unitStatus) = 0;
	    TLSETL(101015);
	    Language_UnitManager_FreeScanInfo(unitPtr);
	    switch (unitPtr->kind) {
		case 3:
		    {
			TLSETL(101018);
			Language_UnitManager_ClearConfiguration();
		    }
		    break;
		case 2:
		    {
			TLSETL(101020);
			Language_UnitManager_ClearPredefs();
		    }
		    break;
		default :
		    break;
	    };
	    TLSETL(101022);
	    unitPtr->compileState = 1;
	    TLINCL();
	    unitPtr->kind = 0;
	};
    } else {
	TLSETL(101027);
	(*unitStatus) = 2;
    };
    TLRESTORELF();
}

void Language_UnitManager_PrepareForDepends (unitPtr, unitStatus)
struct Language_UnitManager_UnitDef	*unitPtr;
Language_UnitManager_UnitStatus	*unitStatus;
{
    TLSTKCHKSLF(101033);
    TLSETF();
    TLSETL(101033);
    TLPRE (unitPtr != ((struct Language_UnitManager_UnitDef *) 0));
    TLSETL(101035);
    switch (unitPtr->compileState) {
	case 1:
	    {
		TLSETL(101037);
		(*unitStatus) = 0;
		TLINCL();
		unitPtr->compileState = 3;
	    }
	    break;
	case 2:
	    {
		TLSETL(101040);
		(*unitStatus) = 0;
		TLINCL();
		unitPtr->compileState = 4;
	    }
	    break;
	case 3:
	case 4:
	case 5:
	    {
		TLSETL(101044);
		(*unitStatus) = 2;
	    }
	    break;
	default:
	    TLCASEABORT;
    };
    TLRESTORELF();
}

void Language_UnitManager_PrepareForCompile (unitPtr, unitStatus)
struct Language_UnitManager_UnitDef	*unitPtr;
Language_UnitManager_UnitStatus	*unitStatus;
{
    TLSTKCHKSLF(101050);
    TLSETF();
    TLSETL(101050);
    TLPRE (unitPtr != ((struct Language_UnitManager_UnitDef *) 0));
    TLSETL(101052);
    switch (unitPtr->compileState) {
	case 3:
	    {
		TLSETL(101072);
		(*unitStatus) = 0;
		TLSETL(101074);
		Language_UnitManager_FreeCompileInfo(unitPtr);
		unitPtr->compileState = 4;
	    }
	    break;
	case 4:
	    {
		struct Language_UnitManager_UnitDef	*stubUnit;
		struct Language_UnitManager_UnitDef	*bodyUnit;
		TLSETL(101077);
		stubUnit = unitPtr->stubUnit;
		TLINCL();
		bodyUnit = Language_UnitManager_BodyUnit(unitPtr);
		TLINCL();
		if ((Language_UnitManager_DependsUpToDate(unitPtr) && ((stubUnit == ((struct Language_UnitManager_UnitDef *) 0)) || (Language_UnitManager_BodyUnit(stubUnit) == unitPtr))) && ((bodyUnit == ((struct Language_UnitManager_UnitDef *) 0)) || ((bodyUnit->stubUnit) == unitPtr))) {
		    TLSETL(101084);
		    (*unitStatus) = 1;
		    TLINCL();
		    unitPtr->compileState = 5;
		} else {
		    TLSETL(101087);
		    (*unitStatus) = 0;
		    TLSETL(101089);
		    Language_UnitManager_FreeCompileInfo(unitPtr);
		    unitPtr->compileState = 4;
		};
	    }
	    break;
	default:
	    TLCASEABORT;
    };
    TLRESTORELF();
}

TLboolean Language_UnitManager_IsCompiled (unitPtr)
struct Language_UnitManager_UnitDef	*unitPtr;
{
    TLSTKCHKSLF(101095);
    TLSETF();
    TLSETL(101095);
    TLPRE (unitPtr != ((struct Language_UnitManager_UnitDef *) 0));
    TLINCL();
    TLRESTORELF();
    return ((unitPtr->compileState) == 5);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

void Language_UnitManager_FlushOldUnits () {
    register struct Language_UnitManager_UnitDef	*unitPtr;
    register struct Language_UnitManager_UnitDef	*lastUnit;
    TLSTKCHKSLF(101102);
    TLSETF();
    TLSETL(101102);
    Language_UnitManager_ClearAllMarks();
    unitPtr = Language_UnitManager_firstUnit;
    TLSETL(101104);
    for(;;) {
	TLSETL(101104);
	if (unitPtr == ((struct Language_UnitManager_UnitDef *) 0)) {
	    break;
	};
	TLSETL(101105);
	if ((unitPtr->compileState) == 5) {
	    register struct Language_UnitManager_UnitDef	*bodyUnit;
	    TLSETL(101106);
	    bodyUnit = unitPtr->defaultBody;
	    TLINCL();
	    if (bodyUnit != ((struct Language_UnitManager_UnitDef *) 0)) {
		TLSETL(101108);
		bodyUnit->isMarked = 1;
	    };
	};
	TLSETL(101111);
	unitPtr = unitPtr->next;
    };
    TLSETL(101114);
    unitPtr = Language_UnitManager_firstUnit;
    TLINCL();
    lastUnit = (struct Language_UnitManager_UnitDef *) 0;
    TLSETL(101117);
    for(;;) {
	TLSETL(101117);
	if (unitPtr == ((struct Language_UnitManager_UnitDef *) 0)) {
	    break;
	};
	TLSETL(101119);
	if (((unitPtr->compileState) != 0) || (unitPtr->isMarked)) {
	    TLSETL(101121);
	    lastUnit = unitPtr;
	    TLINCL();
	    unitPtr = unitPtr->next;
	} else {
	    struct Language_UnitManager_UnitDef	*oldUnit;
	    TLSETL(101125);
	    Language_UnitManager_FreeScanInfo(unitPtr);
	    if ((unitPtr->fileNo) != 0) {
		TLSETL(101127);
		FileManager_DeleteReference((FileManager_FileNoType) (unitPtr->fileNo));
	    };
	    TLSETL(101128);
	    oldUnit = unitPtr;
	    TLINCL();
	    unitPtr = unitPtr->next;
	    TLINCL();
	    if (lastUnit == ((struct Language_UnitManager_UnitDef *) 0)) {
		TLSETL(101131);
		Language_UnitManager_firstUnit = unitPtr;
	    } else {
		TLSETL(101133);
		lastUnit->next = unitPtr;
	    };
	    TLSETL(101136);
	    Language_UnitManager_FreeUnitPtr(&(oldUnit));
	};
    };
    TLRESTORELF();
}
static struct Language_UnitManager_UnitDef	*Language_UnitManager_currentUnit;

void Language_UnitManager_RewindUnitList () {
    TLSTKCHKSLF(101149);
    TLSETF();
    TLSETL(101149);
    Language_UnitManager_currentUnit = Language_UnitManager_firstUnit;
    TLRESTORELF();
}

void Language_UnitManager_GetNextUnit (unitPtr)
struct Language_UnitManager_UnitDef	**unitPtr;
{
    TLSTKCHKSLF(101153);
    TLSETF();
    TLSETL(101153);
    (*unitPtr) = Language_UnitManager_currentUnit;
    TLINCL();
    if (Language_UnitManager_currentUnit != ((struct Language_UnitManager_UnitDef *) 0)) {
	TLSETL(101155);
	Language_UnitManager_currentUnit = Language_UnitManager_currentUnit->next;
    };
    TLRESTORELF();
}

void Language_UnitManager_RewindDependList (unitPtr)
struct Language_UnitManager_UnitDef	*unitPtr;
{
    TLSTKCHKSLF(101161);
    TLSETF();
    TLSETL(101161);
    TLPRE ((unitPtr != ((struct Language_UnitManager_UnitDef *) 0)) && ((unitPtr->compileState) >= 1));
    TLSETL(101163);
    unitPtr->currentDepend = unitPtr->firstDepend;
    TLRESTORELF();
}

void Language_UnitManager_GetNextDepend (unitPtr, dependUnit)
struct Language_UnitManager_UnitDef	*unitPtr;
struct Language_UnitManager_UnitDef	**dependUnit;
{
    TLBINDREG((*UNIT), struct Language_UnitManager_UnitDef);
    TLSTKCHKSLF(101167);
    TLSETF();
    TLSETL(101167);
    TLPRE (unitPtr != ((struct Language_UnitManager_UnitDef *) 0));
    TLINCL();
    UNIT = &((*(unitPtr)));
    TLINCL();
    if (((*UNIT).currentDepend) == ((struct Language_UnitManager_DependDef *) 0)) {
	TLSETL(101170);
	(*dependUnit) = (struct Language_UnitManager_UnitDef *) 0;
    } else {
	TLSETL(101172);
	(*dependUnit) = (*UNIT).currentDepend->unitPtr;
	TLINCL();
	(*UNIT).currentDepend = (*UNIT).currentDepend->next;
    };
    TLRESTORELF();
}

void Language_UnitManager_AllocateCompileChunk (unitPtr, newMemory, newMemorySize)
struct Language_UnitManager_UnitDef	*unitPtr;
TLaddressint	*newMemory;
TLint4	*newMemorySize;
{
    struct Language_UnitManager_ChunkDef	*newChunk;
    TLSTKCHKSLF(101185);
    TLSETF();
    TLSETL(101185);
    TLPRE (((unitPtr != ((struct Language_UnitManager_UnitDef *) 0)) && ((unitPtr->compileState) > 0)) && ((unitPtr->compileState) < 5));
    TLSETL(101191);
    TL_TLB_TLBNWU(& newChunk, (TLint4)  sizeof (    struct Language_UnitManager_ChunkDef));
    TLINCL();
    if (newChunk == ((struct Language_UnitManager_ChunkDef *) 0)) {
	TLSETL(101193);
	(*newMemory) = (TLaddressint) 0;
	TLINCL();
	(*newMemorySize) = 0;
	TLSETL(101196);
	TLRESTORELF();
	return;
    };
    TLSETL(101198);
    newChunk->next = unitPtr->compilerMemory;
    TLINCL();
    unitPtr->compilerMemory = newChunk;
    TLSETL(101201);
    (*newMemory) = (TLaddressint) ((unsigned long)newChunk->memory);
    TLINCL();
    (*newMemorySize) = 4084;
    TLRESTORELF();
}

void Language_UnitManager_SetSymbolTable (unitPtr, symbolTable)
struct Language_UnitManager_UnitDef	*unitPtr;
TLaddressint	symbolTable;
{
    TLSTKCHKSLF(101208);
    TLSETF();
    TLSETL(101208);
    TLPRE ((unitPtr != ((struct Language_UnitManager_UnitDef *) 0)) && ((unitPtr->compileState) == 4));
    TLSETL(101210);
    unitPtr->symbolTable = (TLaddressint) symbolTable;
    TLRESTORELF();
}

TLaddressint Language_UnitManager_SymbolTable (unitPtr)
struct Language_UnitManager_UnitDef	*unitPtr;
{
    TLSTKCHKSLF(101214);
    TLSETF();
    TLSETL(101214);
    TLPRE ((unitPtr != ((struct Language_UnitManager_UnitDef *) 0)) && ((unitPtr->compileState) == 5));
    TLSETL(101216);
    TLRESTORELF();
    return ((TLaddressint) unitPtr->symbolTable);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

void Language_UnitManager_SetCodeTable (unitPtr, codeTable)
struct Language_UnitManager_UnitDef	*unitPtr;
TLaddressint	codeTable;
{
    TLSTKCHKSLF(101221);
    TLSETF();
    TLSETL(101221);
    TLPRE ((unitPtr != ((struct Language_UnitManager_UnitDef *) 0)) && ((unitPtr->compileState) == 4));
    TLSETL(101223);
    unitPtr->codeTable = (TLaddressint) codeTable;
    TLRESTORELF();
}

TLaddressint Language_UnitManager_CodeTable (unitPtr)
struct Language_UnitManager_UnitDef	*unitPtr;
{
    TLSTKCHKSLF(101227);
    TLSETF();
    TLSETL(101227);
    TLPRE ((unitPtr != ((struct Language_UnitManager_UnitDef *) 0)) && ((unitPtr->compileState) >= 4));
    TLSETL(101229);
    TLRESTORELF();
    return ((TLaddressint) unitPtr->codeTable);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

void Language_UnitManager_SetManifestTable (unitPtr, manifestTable)
struct Language_UnitManager_UnitDef	*unitPtr;
TLaddressint	manifestTable;
{
    TLSTKCHKSLF(101235);
    TLSETF();
    TLSETL(101235);
    TLPRE ((unitPtr != ((struct Language_UnitManager_UnitDef *) 0)) && ((unitPtr->compileState) == 4));
    TLSETL(101237);
    unitPtr->manifestTable = (TLaddressint) manifestTable;
    TLRESTORELF();
}

TLaddressint Language_UnitManager_ManifestTable (unitPtr)
struct Language_UnitManager_UnitDef	*unitPtr;
{
    TLSTKCHKSLF(101241);
    TLSETF();
    TLSETL(101241);
    TLPRE ((unitPtr != ((struct Language_UnitManager_UnitDef *) 0)) && ((unitPtr->compileState) >= 4));
    TLSETL(101243);
    TLRESTORELF();
    return ((TLaddressint) unitPtr->manifestTable);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

void Language_UnitManager_SetGlobalArea (unitPtr, globalSize, globalArea)
struct Language_UnitManager_UnitDef	*unitPtr;
TLint4	globalSize;
TLaddressint	globalArea;
{
    TLBINDREG((*UNIT), struct Language_UnitManager_UnitDef);
    TLSTKCHKSLF(101249);
    TLSETF();
    TLSETL(101249);
    TLPRE (((unitPtr != ((struct Language_UnitManager_UnitDef *) 0)) && ((unsigned long) (unitPtr->globalArea) == 0)) && ((unitPtr->compileState) == 4));
    TLSETL(101251);
    UNIT = &((*(unitPtr)));
    TLINCL();
    (*UNIT).globalSize = globalSize;
    TLINCL();
    (*UNIT).globalArea = (TLaddressint) globalArea;
    TLRESTORELF();
}

TLaddressint Language_UnitManager_GlobalArea (unitPtr)
struct Language_UnitManager_UnitDef	*unitPtr;
{
    TLSTKCHKSLF(101257);
    TLSETF();
    TLSETL(101257);
    TLPRE ((unitPtr != ((struct Language_UnitManager_UnitDef *) 0)) && ((unitPtr->compileState) >= 4));
    TLSETL(101259);
    TLRESTORELF();
    return ((TLaddressint) unitPtr->globalArea);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

TLint4 Language_UnitManager_GlobalSize (unitPtr)
struct Language_UnitManager_UnitDef	*unitPtr;
{
    TLSTKCHKSLF(101263);
    TLSETF();
    TLSETL(101263);
    TLPRE ((unitPtr != ((struct Language_UnitManager_UnitDef *) 0)) && ((unitPtr->compileState) == 5));
    TLSETL(101265);
    TLRESTORELF();
    return (unitPtr->globalSize);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

void Language_UnitManager () {
    TLSAVELF();
    TLSETF();
    TLSETL(100086);
    Language_UnitManager_freeUnitPtr = (struct Language_UnitManager_UnitDef *) 0;
    TLSETL(100134);
    Language_UnitManager_freeDependPtr = (struct Language_UnitManager_DependDef *) 0;
    TLSETL(100158);
    Language_UnitManager_freeIncludePtr = (struct Language_UnitManager_IncludeDef *) 0;
    TLSETL(100190);
    Language_UnitManager_firstUnit = (struct Language_UnitManager_UnitDef *) 0;
    TLSETL(100253);
    Language_UnitManager_configUnitPtr = (struct Language_UnitManager_UnitDef *) 0;
    TLSETL(101146);
    Language_UnitManager_currentUnit = (struct Language_UnitManager_UnitDef *) 0;
    TLRESTORELF();
}
